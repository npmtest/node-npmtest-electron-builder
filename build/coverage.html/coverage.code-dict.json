{"/home/travis/build/npmtest/node-npmtest-electron-builder/test.js":"/* istanbul instrument in package npmtest_electron_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-builder/lib.npmtest_electron_builder.js":"/* istanbul instrument in package npmtest_electron_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_electron_builder = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_electron_builder = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-builder/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-electron-builder && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_electron_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_electron_builder\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_electron_builder.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_electron_builder.rollup.js'] =\n            local.assetsDict['/assets.npmtest_electron_builder.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_electron_builder.__dirname + '/lib.npmtest_electron_builder.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/index.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _packager;\n\nfunction _load_packager() {\n  return _packager = require(\"./packager\");\n}\n\nObject.defineProperty(exports, \"Packager\", {\n  enumerable: true,\n  get: function () {\n    return (_packager || _load_packager()).Packager;\n  }\n});\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n  return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nObject.defineProperty(exports, \"getArchSuffix\", {\n  enumerable: true,\n  get: function () {\n    return (_electronBuilderCore || _load_electronBuilderCore()).getArchSuffix;\n  }\n});\nObject.defineProperty(exports, \"Platform\", {\n  enumerable: true,\n  get: function () {\n    return (_electronBuilderCore || _load_electronBuilderCore()).Platform;\n  }\n});\nObject.defineProperty(exports, \"Arch\", {\n  enumerable: true,\n  get: function () {\n    return (_electronBuilderCore || _load_electronBuilderCore()).Arch;\n  }\n});\nObject.defineProperty(exports, \"archFromString\", {\n  enumerable: true,\n  get: function () {\n    return (_electronBuilderCore || _load_electronBuilderCore()).archFromString;\n  }\n});\nObject.defineProperty(exports, \"Target\", {\n  enumerable: true,\n  get: function () {\n    return (_electronBuilderCore || _load_electronBuilderCore()).Target;\n  }\n});\nObject.defineProperty(exports, \"DIR_TARGET\", {\n  enumerable: true,\n  get: function () {\n    return (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET;\n  }\n});\n\nvar _builder;\n\nfunction _load_builder() {\n  return _builder = require(\"./builder\");\n}\n\nObject.defineProperty(exports, \"build\", {\n  enumerable: true,\n  get: function () {\n    return (_builder || _load_builder()).build;\n  }\n});\nObject.defineProperty(exports, \"createTargets\", {\n  enumerable: true,\n  get: function () {\n    return (_builder || _load_builder()).createTargets;\n  }\n});\n\nvar _forgeMaker;\n\nfunction _load_forgeMaker() {\n  return _forgeMaker = require(\"./forge/forge-maker\");\n}\n\nObject.defineProperty(exports, \"buildForge\", {\n  enumerable: true,\n  get: function () {\n    return (_forgeMaker || _load_forgeMaker()).buildForge;\n  }\n});","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/packager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.checkWineVersion = exports.Packager = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\n * @private\n */\nlet checkWineVersion = exports.checkWineVersion = (() => {\n    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (checkPromise) {\n        function wineError(prefix) {\n            return `${prefix}, please see https://github.com/electron-userland/electron-builder/wiki/Multi-Platform-Build#${process.platform === \"linux\" ? \"linux\" : \"macos\"}`;\n        }\n        let wineVersion;\n        try {\n            wineVersion = (yield checkPromise).trim();\n        } catch (e) {\n            if (e.code === \"ENOENT\") {\n                throw new Error(wineError(\"wine is required\"));\n            } else {\n                throw new Error(`Cannot check wine version: ${e}`);\n            }\n        }\n        if (wineVersion.startsWith(\"wine-\")) {\n            wineVersion = wineVersion.substring(\"wine-\".length);\n        }\n        const spaceIndex = wineVersion.indexOf(\" \");\n        if (spaceIndex > 0) {\n            wineVersion = wineVersion.substring(0, spaceIndex);\n        }\n        const suffixIndex = wineVersion.indexOf(\"-\");\n        if (suffixIndex > 0) {\n            wineVersion = wineVersion.substring(0, suffixIndex);\n        }\n        if (wineVersion.split(\".\").length === 2) {\n            wineVersion += \".0\";\n        }\n        if ((0, (_semver || _load_semver()).lt)(wineVersion, \"1.8.0\")) {\n            throw new Error(wineError(`wine 1.8+ is required, but your version is ${wineVersion}`));\n        }\n    });\n\n    return function checkWineVersion(_x) {\n        return _ref5.apply(this, arguments);\n    };\n})();\n\nexports.normalizePlatforms = normalizePlatforms;\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _deepAssign;\n\nfunction _load_deepAssign() {\n    return _deepAssign = require(\"electron-builder-util/out/deepAssign\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _tmp;\n\nfunction _load_tmp() {\n    return _tmp = require(\"electron-builder-util/out/tmp\");\n}\n\nvar _events;\n\nfunction _load_events() {\n    return _events = require(\"events\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _semver;\n\nfunction _load_semver() {\n    return _semver = require(\"semver\");\n}\n\nvar _appInfo;\n\nfunction _load_appInfo() {\n    return _appInfo = require(\"./appInfo\");\n}\n\nvar _asar;\n\nfunction _load_asar() {\n    return _asar = require(\"./asar\");\n}\n\nvar _repositoryInfo;\n\nfunction _load_repositoryInfo() {\n    return _repositoryInfo = require(\"./repositoryInfo\");\n}\n\nvar _targetFactory;\n\nfunction _load_targetFactory() {\n    return _targetFactory = require(\"./targets/targetFactory\");\n}\n\nvar _readPackageJson;\n\nfunction _load_readPackageJson() {\n    return _readPackageJson = require(\"./util/readPackageJson\");\n}\n\nvar _yarn;\n\nfunction _load_yarn() {\n    return _yarn = require(\"./yarn\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addHandler(emitter, event, handler) {\n    emitter.on(event, handler);\n}\nclass Packager {\n    //noinspection JSUnusedGlobalSymbols\n    constructor(options, cancellationToken) {\n        this.options = options;\n        this.cancellationToken = cancellationToken;\n        this.isTwoPackageJsonProjectLayoutUsed = true;\n        this.eventEmitter = new (_events || _load_events()).EventEmitter();\n        this.tempDirManager = new (_tmp || _load_tmp()).TmpDir();\n        this._repositoryInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() => (0, (_repositoryInfo || _load_repositoryInfo()).getRepositoryInfo)(this.projectDir, this.metadata, this.devMetadata));\n        this.afterPackHandlers = [];\n        this.projectDir = options.projectDir == null ? process.cwd() : _path.resolve(options.projectDir);\n        this.prepackaged = options.prepackaged == null ? null : _path.resolve(this.projectDir, options.prepackaged);\n    }\n    get isPrepackedAppAsar() {\n        return this._isPrepackedAppAsar;\n    }\n    get config() {\n        return this._config;\n    }\n    get repositoryInfo() {\n        return this._repositoryInfo.value;\n    }\n    addAfterPackHandler(handler) {\n        this.afterPackHandlers.push(handler);\n    }\n    artifactCreated(handler) {\n        addHandler(this.eventEmitter, \"artifactCreated\", handler);\n        return this;\n    }\n    dispatchArtifactCreated(event) {\n        this.eventEmitter.emit(\"artifactCreated\", event);\n    }\n    build() {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            //noinspection JSDeprecatedSymbols\n            const devMetadataFromOptions = _this.options.devMetadata;\n            if (devMetadataFromOptions != null) {\n                (0, (_log || _load_log()).warn)(\"devMetadata is deprecated, please use config instead\");\n            }\n            let configPath = null;\n            let configFromOptions = _this.options.config;\n            if (typeof configFromOptions === \"string\") {\n                // it is a path to config file\n                configPath = configFromOptions;\n                configFromOptions = null;\n            }\n            if (devMetadataFromOptions != null) {\n                if (configFromOptions != null) {\n                    throw new Error(\"devMetadata and config cannot be used in conjunction\");\n                }\n                configFromOptions = devMetadataFromOptions.build;\n            }\n            const projectDir = _this.projectDir;\n            const fileOrPackageConfig = yield configPath == null ? (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(projectDir) : (0, (_readPackageJson || _load_readPackageJson()).doLoadConfig)(_path.resolve(projectDir, configPath), projectDir);\n            const config = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, fileOrPackageConfig, configFromOptions);\n            const extraMetadata = _this.options.extraMetadata;\n            if (extraMetadata != null) {\n                const extraBuildMetadata = extraMetadata.build;\n                if (extraBuildMetadata != null) {\n                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, extraBuildMetadata);\n                    delete extraMetadata.build;\n                }\n                if (extraMetadata.directories != null) {\n                    (0, (_log || _load_log()).warn)(`--em.directories is deprecated, please specify as --em.build.directories\"`);\n                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(config, { directories: extraMetadata.directories });\n                    delete extraMetadata.directories;\n                }\n            }\n            yield (0, (_readPackageJson || _load_readPackageJson()).validateConfig)(config);\n            _this._config = config;\n            _this.appDir = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).computeDefaultAppDirectory)(projectDir, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(config.directories, function (it) {\n                return it.app;\n            }));\n            _this.isTwoPackageJsonProjectLayoutUsed = _this.appDir !== projectDir;\n            const devPackageFile = _path.join(projectDir, \"package.json\");\n            const appPackageFile = _this.isTwoPackageJsonProjectLayoutUsed ? _path.join(_this.appDir, \"package.json\") : devPackageFile;\n            yield _this.readProjectMetadata(appPackageFile, extraMetadata);\n            if (_this.isTwoPackageJsonProjectLayoutUsed) {\n                _this.devMetadata = (0, (_deepAssign || _load_deepAssign()).deepAssign)((yield (0, (_readPackageJson || _load_readPackageJson()).readPackageJson)(devPackageFile)), devMetadataFromOptions);\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`Two package.json structure is used (dev: ${devPackageFile}, app: ${appPackageFile})`);\n            } else {\n                _this.devMetadata = _this.metadata;\n                if (_this.options.appMetadata != null) {\n                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(_this.devMetadata, _this.options.appMetadata);\n                }\n                if (extraMetadata != null) {\n                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(_this.devMetadata, extraMetadata);\n                }\n            }\n            _this.checkMetadata(appPackageFile, devPackageFile);\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`Effective config: ${(0, (_electronBuilderUtil || _load_electronBuilderUtil()).safeStringifyJson)(_this.config)}`);\n            checkConflictingOptions(_this.config);\n            _this.electronVersion = yield (0, (_readPackageJson || _load_readPackageJson()).getElectronVersion)(_this.config, projectDir, _this.isPrepackedAppAsar ? _this.metadata : null);\n            _this.muonVersion = _this.config.muonVersion;\n            _this.appInfo = new (_appInfo || _load_appInfo()).AppInfo(_this.metadata, _this);\n            const cleanupTasks = [];\n            const outDir = _path.resolve(_this.projectDir, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(_this.config.directories, function (it) {\n                return it.output;\n            }) || \"dist\");\n            return {\n                outDir: outDir,\n                platformToTargets: yield (0, (_promise || _load_promise()).executeFinally)(_this.doBuild(outDir, cleanupTasks), function () {\n                    return (0, (_promise || _load_promise()).all)(cleanupTasks.map(function (it) {\n                        return it();\n                    }).concat(_this.tempDirManager.cleanup()));\n                })\n            };\n        })();\n    }\n    readProjectMetadata(appPackageFile, extraMetadata) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            try {\n                _this2.metadata = (0, (_deepAssign || _load_deepAssign()).deepAssign)((yield (0, (_readPackageJson || _load_readPackageJson()).readPackageJson)(appPackageFile)), _this2.options.appMetadata, extraMetadata);\n            } catch (e) {\n                if (e.code !== \"ENOENT\") {\n                    throw e;\n                }\n                try {\n                    const data = yield (0, (_asar || _load_asar()).readAsarJson)(_path.join(_this2.projectDir, \"app.asar\"), \"package.json\");\n                    if (data != null) {\n                        _this2.metadata = data;\n                        _this2._isPrepackedAppAsar = true;\n                        return;\n                    }\n                } catch (e) {\n                    if (e.code !== \"ENOENT\") {\n                        throw e;\n                    }\n                }\n                throw new Error(`Cannot find package.json in the ${_path.dirname(appPackageFile)}`);\n            }\n        })();\n    }\n    doBuild(outDir, cleanupTasks) {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const distTasks = [];\n            const platformToTarget = new Map();\n            const createdOutDirs = new Set();\n            // custom packager - don't check wine\n            let checkWine = _this3.prepackaged == null && _this3.options.platformPackagerFactory == null;\n            for (const _ref of _this3.options.targets) {\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                const platform = _ref2[0];\n                const archToType = _ref2[1];\n\n                if (_this3.cancellationToken.cancelled) {\n                    break;\n                }\n                if (platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC && process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS.nodeName) {\n                    throw new Error(\"Build for macOS is supported only on macOS, please see https://github.com/electron-userland/electron-builder/wiki/Multi-Platform-Build\");\n                }\n                let wineCheck = null;\n                if (checkWine && process.platform !== \"win32\" && platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {\n                    wineCheck = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"wine\", [\"--version\"]);\n                }\n                const packager = _this3.createHelper(platform, cleanupTasks);\n                const nameToTarget = new Map();\n                platformToTarget.set(platform, nameToTarget);\n                for (const _ref3 of (0, (_targetFactory || _load_targetFactory()).computeArchToTargetNamesMap)(archToType, packager.platformSpecificBuildOptions, platform)) {\n                    var _ref4 = _slicedToArray(_ref3, 2);\n\n                    const arch = _ref4[0];\n                    const targetNames = _ref4[1];\n\n                    if (_this3.cancellationToken.cancelled) {\n                        break;\n                    }\n                    yield _this3.installAppDependencies(platform, arch);\n                    if (_this3.cancellationToken.cancelled) {\n                        break;\n                    }\n                    if (checkWine && wineCheck != null) {\n                        checkWine = false;\n                        yield checkWineVersion(wineCheck);\n                    }\n                    const targetList = (0, (_targetFactory || _load_targetFactory()).createTargets)(nameToTarget, targetNames.length === 0 ? packager.defaultTarget : targetNames, outDir, packager, cleanupTasks);\n                    const ourDirs = new Set();\n                    for (const target of targetList) {\n                        if (!(target instanceof (_targetFactory || _load_targetFactory()).NoOpTarget) && !createdOutDirs.has(target.outDir)) {\n                            ourDirs.add(target.outDir);\n                        }\n                    }\n                    if (ourDirs.size > 0) {\n                        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(Array.from(ourDirs).sort(), function (it) {\n                            createdOutDirs.add(it);\n                            return (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(it);\n                        });\n                    }\n                    yield packager.pack(outDir, arch, targetList, distTasks);\n                }\n                if (_this3.cancellationToken.cancelled) {\n                    break;\n                }\n                for (const target of nameToTarget.values()) {\n                    distTasks.push(target.finishBuild());\n                }\n            }\n            if (_this3.cancellationToken.cancelled) {\n                for (const task of distTasks) {\n                    if (\"cancel\" in task) {\n                        task.cancel();\n                    }\n                }\n            } else {\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(distTasks);\n            }\n            return platformToTarget;\n        })();\n    }\n    createHelper(platform, cleanupTasks) {\n        if (this.options.platformPackagerFactory != null) {\n            return this.options.platformPackagerFactory(this, platform, cleanupTasks);\n        }\n        switch (platform) {\n            case (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC:\n                {\n                    const helperClass = require(\"./macPackager\").default;\n                    return new helperClass(this);\n                }\n            case (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS:\n                {\n                    const helperClass = require(\"./winPackager\").WinPackager;\n                    return new helperClass(this);\n                }\n            case (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX:\n                return new (require(\"./linuxPackager\").LinuxPackager)(this);\n            default:\n                throw new Error(`Unknown platform: ${platform}`);\n        }\n    }\n    checkMetadata(appPackageFile, devAppPackageFile) {\n        const errors = [];\n        const reportError = missedFieldName => {\n            errors.push(`Please specify '${missedFieldName}' in the package.json (${appPackageFile})`);\n        };\n        const checkNotEmpty = (name, value) => {\n            if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(value)) {\n                reportError(name);\n            }\n        };\n        const appMetadata = this.metadata;\n        checkNotEmpty(\"name\", appMetadata.name);\n        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(appMetadata.description)) {\n            (0, (_log || _load_log()).warn)(`description is missed in the package.json (${appPackageFile})`);\n        }\n        checkNotEmpty(\"version\", appMetadata.version);\n        checkDependencies(this.devMetadata.dependencies, errors);\n        if (appMetadata !== this.devMetadata) {\n            checkDependencies(appMetadata.dependencies, errors);\n            if (appMetadata.build != null) {\n                errors.push(`'build' in the application package.json (${appPackageFile}) is not supported since 3.0 anymore. Please move 'build' into the development package.json (${devAppPackageFile})`);\n            }\n        }\n        const config = this.config;\n        if (config[\"osx-sign\"] != null) {\n            errors.push(\"osx-sign is deprecated and not supported — please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing\");\n        }\n        if (config[\"osx\"] != null) {\n            errors.push(`osx is deprecated and not supported — please use mac instead`);\n        }\n        if (config[\"app-copyright\"] != null) {\n            errors.push(`app-copyright is deprecated and not supported — please use copyright instead`);\n        }\n        if (config[\"app-category-type\"] != null) {\n            errors.push(`app-category-type is deprecated and not supported — please use mac.category instead`);\n        }\n        const author = appMetadata.author;\n        if (author == null) {\n            errors.push(`Please specify \"author\" in the application package.json (${appPackageFile}) — it is used as company name and copyright owner.`);\n        }\n        if (config.name != null) {\n            errors.push(`'name' in the config is forbidden. Please move 'name' into the package.json (${appPackageFile})`);\n        }\n        if (config.prune != null) {\n            errors.push(\"prune is deprecated — development dependencies are never copied in any case\");\n        }\n        if (errors.length > 0) {\n            throw new Error(errors.join(\"\\n\"));\n        }\n    }\n    installAppDependencies(platform, arch) {\n        var _this4 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            if (_this4.prepackaged != null) {\n                return;\n            }\n            const frameworkInfo = { version: _this4.muonVersion || _this4.electronVersion, useCustomDist: _this4.muonVersion == null };\n            const options = _this4.config;\n            if (options.nodeGypRebuild === true) {\n                (0, (_log || _load_log()).log)(`Executing node-gyp rebuild for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]}`);\n                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(process.platform === \"win32\" ? \"node-gyp.cmd\" : \"node-gyp\", [\"rebuild\"], {\n                    env: (0, (_yarn || _load_yarn()).getGypEnv)(frameworkInfo, platform.nodeName, (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch], true)\n                });\n            }\n            if (options.npmRebuild === false) {\n                (0, (_log || _load_log()).log)(\"Skip app dependencies rebuild because npmRebuild is set to false\");\n                return;\n            }\n            const beforeBuild = options.beforeBuild;\n            if (beforeBuild != null) {\n                const performDependenciesInstallOrRebuild = yield beforeBuild({\n                    appDir: _this4.appDir,\n                    electronVersion: _this4.electronVersion,\n                    platform,\n                    arch: (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]\n                });\n                if (!performDependenciesInstallOrRebuild) return;\n            }\n            if (options.npmSkipBuildFromSource !== true && platform.nodeName !== process.platform) {\n                (0, (_log || _load_log()).log)(\"Skip app dependencies rebuild because platform is different\");\n            } else {\n                yield (0, (_yarn || _load_yarn()).installOrRebuild)(options, _this4.appDir, frameworkInfo, platform.nodeName, (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]);\n            }\n        })();\n    }\n    afterPack(context) {\n        const afterPack = this.config.afterPack;\n        const handlers = this.afterPackHandlers.slice();\n        if (afterPack != null) {\n            // user handler should be last\n            handlers.push(afterPack);\n        }\n        return (_bluebirdLst2 || _load_bluebirdLst2()).default.each(handlers, it => it(context));\n    }\n}\nexports.Packager = Packager;\nfunction normalizePlatforms(rawPlatforms) {\n    const platforms = rawPlatforms == null || Array.isArray(rawPlatforms) ? rawPlatforms : [rawPlatforms];\n    if (platforms == null || platforms.length === 0) {\n        return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.fromString(process.platform)];\n    } else if (platforms[0] === \"all\") {\n        if (process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC.nodeName) {\n            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC, (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];\n        } else if (process.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX.nodeName) {\n            // macOS code sign works only on macOS\n            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];\n        } else {\n            return [(_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS];\n        }\n    } else {\n        return platforms.map(it => it instanceof (_electronBuilderCore || _load_electronBuilderCore()).Platform ? it : (_electronBuilderCore || _load_electronBuilderCore()).Platform.fromString(it));\n    }\n}\nfunction checkConflictingOptions(options) {\n    for (const name of [\"all\", \"out\", \"tmpdir\", \"version\", \"platform\", \"dir\", \"arch\", \"name\", \"extra-resource\"]) {\n        if (name in options) {\n            throw new Error(`Option ${name} is ignored, do not specify it.`);\n        }\n    }\n}\nfunction checkDependencies(dependencies, errors) {\n    if (dependencies == null) {\n        return;\n    }\n    for (const name of [\"electron\", \"electron-prebuilt\", \"electron-builder\", \"electron-rebuild\"]) {\n        if (name in dependencies) {\n            errors.push(`Package \"${name}\" is only allowed in \"devDependencies\". ` + `Please remove it from the \"dependencies\" section in your package.json.`);\n        }\n    }\n}\n//# sourceMappingURL=packager.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-core/out/core.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getArchSuffix = getArchSuffix;\nexports.toLinuxArchString = toLinuxArchString;\nexports.archFromString = archFromString;\nvar Arch = exports.Arch = undefined;\n(function (Arch) {\n    Arch[Arch[\"ia32\"] = 0] = \"ia32\";\n    Arch[Arch[\"x64\"] = 1] = \"x64\";\n    Arch[Arch[\"armv7l\"] = 2] = \"armv7l\";\n})(Arch || (exports.Arch = Arch = {}));\nfunction getArchSuffix(arch) {\n    return arch === Arch.x64 ? \"\" : `-${Arch[arch]}`;\n}\nfunction toLinuxArchString(arch) {\n    return arch === Arch.ia32 ? \"i386\" : arch === Arch.x64 ? \"amd64\" : \"armv7l\";\n}\nfunction archFromString(name) {\n    if (name === \"x64\") {\n        return Arch.x64;\n    }\n    if (name === \"ia32\") {\n        return Arch.ia32;\n    }\n    if (name === \"armv7l\") {\n        return Arch.armv7l;\n    }\n    throw new Error(`Unsupported arch ${name}`);\n}\nclass Platform {\n    constructor(name, buildConfigurationKey, nodeName) {\n        this.name = name;\n        this.buildConfigurationKey = buildConfigurationKey;\n        this.nodeName = nodeName;\n    }\n    toString() {\n        return this.name;\n    }\n    createTarget(type) {\n        for (var _len = arguments.length, archs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            archs[_key - 1] = arguments[_key];\n        }\n\n        if (type == null && (archs == null || archs.length === 0)) {\n            return new Map([[this, new Map()]]);\n        }\n        const archToType = new Map();\n        if (this === Platform.MAC) {\n            archs = [Arch.x64];\n        }\n        for (const arch of archs == null || archs.length === 0 ? [archFromString(process.arch)] : archs) {\n            archToType.set(arch, type == null ? [] : Array.isArray(type) ? type : [type]);\n        }\n        return new Map([[this, archToType]]);\n    }\n    static current() {\n        return Platform.fromString(process.platform);\n    }\n    static fromString(name) {\n        name = name.toLowerCase();\n        switch (name) {\n            case Platform.MAC.nodeName:\n            case Platform.MAC.name:\n                return Platform.MAC;\n            case Platform.WINDOWS.nodeName:\n            case Platform.WINDOWS.name:\n            case Platform.WINDOWS.buildConfigurationKey:\n                return Platform.WINDOWS;\n            case Platform.LINUX.nodeName:\n                return Platform.LINUX;\n            default:\n                throw new Error(`Unknown platform: ${name}`);\n        }\n    }\n}\nexports.Platform = Platform;\nPlatform.MAC = new Platform(\"mac\", \"mac\", \"darwin\");\nPlatform.LINUX = new Platform(\"linux\", \"linux\", \"linux\");\nPlatform.WINDOWS = new Platform(\"windows\", \"win\", \"win32\");\n// deprecated\n//noinspection JSUnusedGlobalSymbols\nPlatform.OSX = Platform.MAC;\nclass Target {\n    constructor(name) {\n        let isAsyncSupported = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        this.name = name;\n        this.isAsyncSupported = isAsyncSupported;\n    }\n    finishBuild() {\n        return Promise.resolve();\n    }\n}\nexports.Target = Target;\nconst DEFAULT_TARGET = exports.DEFAULT_TARGET = \"default\";\nconst DIR_TARGET = exports.DIR_TARGET = \"dir\";\n//# sourceMappingURL=core.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/builder.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.build = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet build = exports.build = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (rawOptions) {\n        const options = normalizeOptions(rawOptions || {});\n        if (options.cscLink === undefined && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.CSC_LINK)) {\n            options.cscLink = process.env.CSC_LINK;\n        }\n        if (options.cscInstallerLink === undefined && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.CSC_INSTALLER_LINK)) {\n            options.cscInstallerLink = process.env.CSC_INSTALLER_LINK;\n        }\n        if (options.cscKeyPassword === undefined && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.CSC_KEY_PASSWORD)) {\n            options.cscKeyPassword = process.env.CSC_KEY_PASSWORD;\n        }\n        if (options.cscInstallerKeyPassword === undefined && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.CSC_INSTALLER_KEY_PASSWORD)) {\n            options.cscInstallerKeyPassword = process.env.CSC_INSTALLER_KEY_PASSWORD;\n        }\n        if (options.draft === undefined && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.EP_DRAFT)) {\n            options.draft = process.env.EP_DRAFT.toLowerCase() === \"true\";\n        }\n        if (options.prerelease === undefined && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.EP_PRELEASE)) {\n            options.prerelease = process.env.EP_PRELEASE.toLowerCase() === \"true\";\n        }\n        const cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken();\n        const packager = new (_packager || _load_packager()).Packager(options, cancellationToken);\n        // because artifact event maybe dispatched several times for different publish providers\n        const artifactPaths = new Set();\n        packager.artifactCreated(function (event) {\n            if (event.file != null) {\n                artifactPaths.add(event.file);\n            }\n        });\n        const publishManager = new (_PublishManager || _load_PublishManager()).PublishManager(packager, options, cancellationToken);\n        const buildPromise = packager.build().then(function () {\n            return Array.from(artifactPaths);\n        });\n        process.on(\"SIGINT\", function () {\n            (0, (_log || _load_log()).warn)(\"Cancelled by SIGINT\");\n            cancellationToken.cancel();\n            publishManager.cancelTasks();\n        });\n        return yield (0, (_promise || _load_promise()).executeFinally)(buildPromise, function (errorOccurred) {\n            if (errorOccurred) {\n                publishManager.cancelTasks();\n                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);\n            } else {\n                return publishManager.awaitTasks();\n            }\n        });\n    });\n\n    return function build(_x) {\n        return _ref.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=builder.js.map\n\n\nexports.normalizeOptions = normalizeOptions;\nexports.createTargets = createTargets;\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _CancellationToken;\n\nfunction _load_CancellationToken() {\n    return _CancellationToken = require(\"electron-builder-http/out/CancellationToken\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _packager;\n\nfunction _load_packager() {\n    return _packager = require(\"./packager\");\n}\n\nvar _PublishManager;\n\nfunction _load_PublishManager() {\n    return _PublishManager = require(\"./publish/PublishManager\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction normalizeOptions(args) {\n    if (args.targets != null) {\n        return args;\n    }\n    let targets = new Map();\n    function processTargets(platform, types) {\n        function commonArch(currentIfNotSpecified) {\n            if (platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {\n                return args.x64 || currentIfNotSpecified ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64] : [];\n            }\n            const result = Array();\n            if (args.x64) {\n                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.x64);\n            }\n            if (args.armv7l) {\n                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.armv7l);\n            }\n            if (args.ia32) {\n                result.push((_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32);\n            }\n            return result.length === 0 && currentIfNotSpecified ? [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(process.arch)] : result;\n        }\n        if (args.platform != null) {\n            throw new Error(`--platform cannot be used if --${platform.buildConfigurationKey} is passed`);\n        }\n        if (args.arch != null) {\n            throw new Error(`--arch cannot be used if --${platform.buildConfigurationKey} is passed`);\n        }\n        let archToType = targets.get(platform);\n        if (archToType == null) {\n            archToType = new Map();\n            targets.set(platform, archToType);\n        }\n        if (types.length === 0) {\n            const defaultTargetValue = args.dir ? [(_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET] : [];\n            for (const arch of commonArch(args.dir === true)) {\n                archToType.set(arch, defaultTargetValue);\n            }\n            return;\n        }\n        for (const type of types) {\n            const suffixPos = type.lastIndexOf(\":\");\n            if (suffixPos > 0) {\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(archToType, (0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(type.substring(suffixPos + 1)), type.substring(0, suffixPos));\n            } else {\n                for (const arch of commonArch(true)) {\n                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(archToType, arch, type);\n                }\n            }\n        }\n    }\n    if (args.mac != null) {\n        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC, args.mac);\n    }\n    if (args.linux != null) {\n        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX, args.linux);\n    }\n    if (args.win != null) {\n        processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS, args.win);\n    }\n    if (targets.size === 0) {\n        if (args.platform == null && args.arch == null) {\n            processTargets((_electronBuilderCore || _load_electronBuilderCore()).Platform.current(), []);\n        } else {\n            targets = createTargets((0, (_packager || _load_packager()).normalizePlatforms)(args.platform), args.dir ? (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET : null, args.arch);\n        }\n    }\n    const result = Object.assign({}, args);\n    result.targets = targets;\n    delete result.dir;\n    delete result.mac;\n    delete result.linux;\n    delete result.win;\n    delete result.platform;\n    delete result.arch;\n    const r = result;\n    delete r.em;\n    delete r.m;\n    delete r.o;\n    delete r.l;\n    delete r.w;\n    delete r.windows;\n    delete r.macos;\n    delete r.$0;\n    delete r._;\n    delete r.version;\n    delete r.help;\n    delete result.ia32;\n    delete result.x64;\n    delete result.armv7l;\n    if (result.project != null && result.projectDir == null) {\n        result.projectDir = result.project;\n    }\n    delete result.project;\n    return result;\n}\nfunction createTargets(platforms, type, arch) {\n    const targets = new Map();\n    for (const platform of platforms) {\n        const archs = platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64] : arch === \"all\" ? [(_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32] : [(0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch == null ? process.arch : arch)];\n        const archToType = new Map();\n        targets.set(platform, archToType);\n        for (const arch of archs) {\n            archToType.set(arch, type == null ? [] : [type]);\n        }\n    }\n    return targets;\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/forge/forge-maker.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.buildForge = buildForge;\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _builder;\n\nfunction _load_builder() {\n    return _builder = require(\"../builder\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction buildForge(appDir, options) {\n    return (0, (_builder || _load_builder()).build)(Object.assign({\n        prepackaged: appDir,\n        config: {\n            directories: {\n                // https://github.com/electron-userland/electron-forge/blob/master/src/makers/generic/zip.js\n                output: _path.resolve(appDir, \"..\", \"make\")\n            }\n        }\n    }, options));\n}\n//# sourceMappingURL=forge-maker.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/appInfo.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AppInfo = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _sanitizeFilename;\n\nfunction _load_sanitizeFilename() {\n    return _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\n}\n\nvar _semver;\n\nfunction _load_semver() {\n    return _semver = require(\"semver\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass AppInfo {\n    constructor(metadata, info, buildVersion) {\n        this.metadata = metadata;\n        this.info = info;\n        this.description = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(this.metadata.description || \"\");\n        this.version = metadata.version;\n        this.buildNumber = this.config.buildVersion || process.env.TRAVIS_BUILD_NUMBER || process.env.APPVEYOR_BUILD_NUMBER || process.env.CIRCLE_BUILD_NUM || process.env.BUILD_NUMBER;\n        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(buildVersion)) {\n            buildVersion = this.version;\n            if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(this.buildNumber)) {\n                buildVersion += `.${this.buildNumber}`;\n            }\n            this.buildVersion = buildVersion;\n        } else {\n            this.buildVersion = buildVersion;\n        }\n        this.productName = this.config.productName || metadata.productName || metadata.name;\n        this.productFilename = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(this.productName);\n    }\n    get config() {\n        return this.info.config;\n    }\n    get versionInWeirdWindowsForm() {\n        const parsedVersion = new (_semver || _load_semver()).SemVer(this.version);\n        return `${parsedVersion.major}.${parsedVersion.minor}.${parsedVersion.patch}.${this.buildNumber || \"0\"}`;\n    }\n    get companyName() {\n        return this.metadata.author.name;\n    }\n    get id() {\n        let appId;\n        if (this.config.appId != null) {\n            appId = this.config.appId;\n        }\n        const generateDefaultAppId = () => {\n            return `com.electron.${this.metadata.name.toLowerCase()}`;\n        };\n        if (appId != null && (appId === \"your.id\" || (0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(appId))) {\n            const incorrectAppId = appId;\n            appId = generateDefaultAppId();\n            (0, (_log || _load_log()).warn)(`Do not use \"${incorrectAppId}\" as appId, \"${appId}\" will be used instead`);\n        }\n        return appId == null ? generateDefaultAppId() : appId;\n    }\n    get name() {\n        return this.metadata.name;\n    }\n    get copyright() {\n        const copyright = this.config.copyright;\n        if (copyright != null) {\n            return copyright;\n        }\n        return `Copyright © ${new Date().getFullYear()} ${this.metadata.author.name || this.productName}`;\n    }\n    computePackageUrl() {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const url = _this.metadata.homepage;\n            if (url != null) {\n                return url;\n            }\n            const info = yield _this.info.repositoryInfo;\n            return info == null || info.type !== \"github\" ? null : `https://${info.domain}/${info.user}/${info.project}`;\n        })();\n    }\n}\nexports.AppInfo = AppInfo; //# sourceMappingURL=appInfo.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/asar.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.readAsarJson = exports.readAsar = exports.AsarFilesystem = exports.Node = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet readAsar = exports.readAsar = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (archive) {\n        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(archive, \"r\");\n        let size;\n        let headerBuf;\n        try {\n            const sizeBuf = new Buffer(8);\n            if ((yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, sizeBuf, 0, 8, null)) !== 8) {\n                throw new Error(\"Unable to read header size\");\n            }\n            const sizePickle = (0, (_chromiumPickleJs || _load_chromiumPickleJs()).createFromBuffer)(sizeBuf);\n            size = sizePickle.createIterator().readUInt32();\n            headerBuf = new Buffer(size);\n            if ((yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, headerBuf, 0, size, null)) !== size) {\n                throw new Error(\"Unable to read header\");\n            }\n        } finally {\n            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);\n        }\n        const headerPickle = (0, (_chromiumPickleJs || _load_chromiumPickleJs()).createFromBuffer)(headerBuf);\n        const header = headerPickle.createIterator().readString();\n        return new AsarFilesystem(archive, JSON.parse(header), size);\n    });\n\n    return function readAsar(_x5) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet readAsarJson = exports.readAsarJson = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (archive, file) {\n        const fs = yield readAsar(archive);\n        return yield fs.readJson(file);\n    });\n\n    return function readAsarJson(_x6, _x7) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet readFileFromAsar = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (filesystem, filename, info) {\n        let buffer = new Buffer(info.size);\n        if (info.size <= 0) {\n            return buffer;\n        }\n        if (info.unpacked) {\n            return yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(`${filesystem.src}.unpacked`, filename));\n        }\n        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(filesystem.src, \"r\");\n        try {\n            const offset = 8 + filesystem.headerSize + parseInt(info.offset);\n            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, buffer, 0, info.size, offset);\n        } finally {\n            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);\n        }\n        return buffer;\n    });\n\n    return function readFileFromAsar(_x8, _x9, _x10) {\n        return _ref3.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=asar.js.map\n\n\nvar _chromiumPickleJs;\n\nfunction _load_chromiumPickleJs() {\n    return _chromiumPickleJs = require(\"chromium-pickle-js\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nconst UINT64 = require(\"cuint\").UINT64;\nclass Node {}\nexports.Node = Node;\nclass AsarFilesystem {\n    constructor(src) {\n        let header = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Node();\n        let headerSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n        this.src = src;\n        this.header = header;\n        this.headerSize = headerSize;\n        this.offset = UINT64(0);\n        if (this.header.files == null) {\n            this.header.files = {};\n        }\n    }\n    searchNodeFromDirectory(p) {\n        let node = this.header;\n        for (const dir of p.split(_path.sep)) {\n            if (dir !== \".\") {\n                node = node.files[dir];\n            }\n        }\n        return node;\n    }\n    getOrCreateNode(p) {\n        p = _path.relative(this.src, p);\n        if (p == null || p.length === 0) {\n            return this.header;\n        }\n        const name = _path.basename(p);\n        const dirNode = this.searchNodeFromDirectory(_path.dirname(p));\n        if (dirNode.files == null) {\n            dirNode.files = {};\n        }\n        let result = dirNode.files[name];\n        if (result == null) {\n            result = new Node();\n            dirNode.files[name] = result;\n        }\n        return result;\n    }\n    insertDirectory(p) {\n        let unpacked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        const node = this.getOrCreateNode(p);\n        node.files = {};\n        if (unpacked) {\n            node.unpacked = unpacked;\n        }\n        return node.files;\n    }\n    insertFileNode(node, stat, file) {\n        if (node.size > 4294967295) {\n            throw new Error(`${file}: file size can not be larger than 4.2GB`);\n        }\n        node.offset = this.offset.toString();\n        if (process.platform !== \"win32\" && stat.mode & 0o100) {\n            node.executable = true;\n        }\n        this.offset.add(UINT64(node.size));\n    }\n    getNode(p) {\n        const node = this.searchNodeFromDirectory(_path.dirname(p));\n        return node.files[_path.basename(p)];\n    }\n    getFile(p) {\n        let followLinks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        const info = this.getNode(p);\n        // if followLinks is false we don't resolve symlinks\n        return followLinks && info.link != null ? this.getFile(info.link) : info;\n    }\n    readJson(file) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            return JSON.parse((yield _this.readFile(file)).toString());\n        })();\n    }\n    readFile(file) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            return yield readFileFromAsar(_this2, file, _this2.getFile(file));\n        })();\n    }\n}\nexports.AsarFilesystem = AsarFilesystem;","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/asarUtil.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.checkFileInArchive = exports.AsarPackager = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet checkFileInArchive = exports.checkFileInArchive = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (asarFile, relativeFile, messagePrefix) {\n        function error(text) {\n            return new Error(`${messagePrefix} \"${relativeFile}\" in the \"${asarFile}\" ${text}`);\n        }\n        let fs;\n        try {\n            fs = yield (0, (_asar || _load_asar()).readAsar)(asarFile);\n        } catch (e) {\n            throw error(`is corrupted: ${e}`);\n        }\n        let stat;\n        try {\n            stat = fs.getFile(relativeFile);\n        } catch (e) {\n            const fileStat = yield (0, (_fs || _load_fs()).statOrNull)(asarFile);\n            if (fileStat == null) {\n                throw error(`does not exist. Seems like a wrong configuration.`);\n            }\n            // asar throws error on access to undefined object (info.link)\n            stat = null;\n        }\n        if (stat == null) {\n            throw error(`does not exist. Seems like a wrong configuration.`);\n        }\n        if (stat.size === 0) {\n            throw error(`is corrupted: size 0`);\n        }\n    });\n\n    return function checkFileInArchive(_x2, _x3, _x4) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=asarUtil.js.map\n\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _asar;\n\nfunction _load_asar() {\n    return _asar = require(\"./asar\");\n}\n\nvar _fileTransformer;\n\nfunction _load_fileTransformer() {\n    return _fileTransformer = require(\"./fileTransformer\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst isBinaryFile = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require(\"isbinaryfile\"));\nconst pickle = require(\"chromium-pickle-js\");\nconst NODE_MODULES_PATTERN = `${_path.sep}node_modules${_path.sep}`;\nfunction addValue(map, key, value) {\n    let list = map.get(key);\n    if (list == null) {\n        list = [value];\n        map.set(key, list);\n    } else {\n        list.push(value);\n    }\n}\nfunction writeUnpackedFiles(filesToUnpack, fileCopier) {\n    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map(filesToUnpack, it => {\n        if (it.data == null) {\n            return fileCopier.copy(it.src, it.destination, it.stats);\n        } else {\n            return (0, (_fsExtraP || _load_fsExtraP()).writeFile)(it.destination, it.data);\n        }\n    });\n}\nclass AsarPackager {\n    constructor(src, destination, options, unpackPattern, transformer) {\n        this.src = src;\n        this.options = options;\n        this.unpackPattern = unpackPattern;\n        this.transformer = transformer;\n        this.fs = new (_asar || _load_asar()).AsarFilesystem(this.src);\n        this.metadata = new Map();\n        this.outFile = _path.join(destination, \"app.asar\");\n    }\n    // sort files to minimize file change (i.e. asar file is not changed dramatically on small change)\n    pack(filter, isElectronCompile) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const metadata = _this.metadata;\n            let files = yield (0, (_fs || _load_fs()).walk)(_this.src, filter, function (file, fileStat) {\n                metadata.set(file, fileStat);\n                if (fileStat.isSymbolicLink()) {\n                    return (0, (_fsExtraP || _load_fsExtraP()).readlink)(file).then(function (linkTarget) {\n                        // http://unix.stackexchange.com/questions/105637/is-symlinks-target-relative-to-the-destinations-parent-directory-and-if-so-wh\n                        const resolved = _path.resolve(_path.dirname(file), linkTarget);\n                        const link = _path.relative(_this.src, linkTarget);\n                        if (link.startsWith(\"..\")) {\n                            // outside of project, linked module (https://github.com/electron-userland/electron-builder/issues/675)\n                            return (0, (_fsExtraP || _load_fsExtraP()).stat)(resolved).then(function (targetFileStat) {\n                                metadata.set(file, targetFileStat);\n                                return targetFileStat;\n                            });\n                        } else {\n                            fileStat.relativeLink = link;\n                        }\n                        return null;\n                    });\n                }\n                return null;\n            });\n            // transform before electron-compile to avoid filtering (cache files in any case should be not transformed)\n            const transformer = _this.transformer;\n            _this.transformedFiles = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (it) {\n                return metadata.get(it).isFile() ? transformer(it) : null;\n            }, (_fs || _load_fs()).CONCURRENCY);\n            if (isElectronCompile) {\n                files = yield _this.compileUsingElectronCompile(files);\n            }\n            yield _this.createPackageFromFiles(_this.options.ordering == null ? files : yield _this.order(files));\n        })();\n    }\n    compileUsingElectronCompile(files) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            (0, (_log || _load_log()).log)(\"Compiling using electron-compile\");\n            const metadata = _this2.metadata;\n            const cacheDir = _path.join(_this2.src, \".cache\");\n            // clear and create cache dir\n            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(cacheDir);\n            const compilerHost = yield (0, (_fileTransformer || _load_fileTransformer()).createElectronCompilerHost)(_this2.src, cacheDir);\n            const nextSlashIndex = _this2.src.length + 1;\n            // pre-compute electron-compile to cache dir - we need to process only subdirectories, not direct files of app dir\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (file) {\n                if (file.indexOf(\"/node_modules/\") !== -1 || file.indexOf(\"/bower_components/\") !== -1 || !(file.indexOf(\"/\", nextSlashIndex) !== -1) // ignore not root files \n                || !metadata.get(file).isFile()) {\n                    return null;\n                }\n                return compilerHost.compile(file).then(function (it) {\n                    return null;\n                });\n            }, (_fs || _load_fs()).CONCURRENCY);\n            yield compilerHost.saveConfiguration();\n            const cacheFiles = yield (0, (_fs || _load_fs()).walk)(cacheDir, function (file, stat) {\n                return !file.startsWith(\".\");\n            }, function (file, fileStat) {\n                _this2.metadata.set(file, fileStat);\n                return null;\n            });\n            // add es6-shim.js\n            const es6ShimPath = `${_this2.src}/es6-shim.js`;\n            cacheFiles.push(es6ShimPath);\n            metadata.set(es6ShimPath, { isFile: function () {\n                    return true;\n                }, isDirectory: function () {\n                    return false;\n                } });\n            _this2.transformedFiles = new Array(cacheFiles.length).concat(_this2.transformedFiles);\n            _this2.transformedFiles[cacheFiles.length - 1] = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(_this2.src, \"node_modules\", \"electron-compile\", \"lib\", \"es6-shim.js\"));\n            // cache files should be first (better IO)\n            return cacheFiles.concat(files);\n        })();\n    }\n    detectUnpackedDirs(files, autoUnpackDirs, unpackedDest) {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const dirToCreate = new Map();\n            const metadata = _this3.metadata;\n            /* tslint:disable:rule1 prefer-const */\n            for (let i = 0, n = files.length; i < n; i++) {\n                const file = files[i];\n                const index = file.lastIndexOf(NODE_MODULES_PATTERN);\n                if (index < 0) {\n                    continue;\n                }\n                const nextSlashIndex = file.indexOf(_path.sep, index + NODE_MODULES_PATTERN.length + 1);\n                if (nextSlashIndex < 0) {\n                    continue;\n                }\n                if (!metadata.get(file).isFile()) {\n                    continue;\n                }\n                const nodeModuleDir = file.substring(0, nextSlashIndex);\n                if (autoUnpackDirs.has(nodeModuleDir)) {\n                    const fileParent = _path.dirname(file);\n                    if (fileParent !== nodeModuleDir && !autoUnpackDirs.has(fileParent)) {\n                        autoUnpackDirs.add(fileParent);\n                        addValue(dirToCreate, _path.relative(_this3.src, nodeModuleDir), _path.relative(nodeModuleDir, fileParent));\n                    }\n                    continue;\n                }\n                const ext = _path.extname(file);\n                let shouldUnpack = false;\n                if (ext === \".dll\" || ext === \".exe\") {\n                    shouldUnpack = true;\n                } else if (ext === \"\") {\n                    shouldUnpack = yield isBinaryFile(file);\n                }\n                if (!shouldUnpack) {\n                    continue;\n                }\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`${_path.relative(_this3.src, nodeModuleDir)} is not packed into asar archive - contains executable code`);\n                let fileParent = _path.dirname(file);\n                // create parent dir to be able to copy file later without directory existence check\n                addValue(dirToCreate, _path.relative(_this3.src, nodeModuleDir), _path.relative(nodeModuleDir, fileParent));\n                while (fileParent !== nodeModuleDir) {\n                    autoUnpackDirs.add(fileParent);\n                    fileParent = _path.dirname(fileParent);\n                }\n                autoUnpackDirs.add(nodeModuleDir);\n            }\n            if (dirToCreate.size > 0) {\n                // child directories should be not created asynchronously - parent directories should be created first\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(dirToCreate.keys(), (() => {\n                    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (it) {\n                        const base = _path.join(unpackedDest, it);\n                        yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(base);\n                        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.each(dirToCreate.get(it), function (it) {\n                            return (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.join(base, it));\n                        });\n                    });\n\n                    return function (_x) {\n                        return _ref.apply(this, arguments);\n                    };\n                })(), (_fs || _load_fs()).CONCURRENCY);\n            }\n        })();\n    }\n    createPackageFromFiles(files) {\n        var _this4 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const metadata = _this4.metadata;\n            // search auto unpacked dir\n            const unpackedDirs = new Set();\n            const unpackedDest = `${_this4.outFile}.unpacked`;\n            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(_this4.outFile));\n            if (_this4.options.smartUnpack !== false) {\n                yield _this4.detectUnpackedDirs(files, unpackedDirs, unpackedDest);\n            }\n            const dirToCreateForUnpackedFiles = new Set(unpackedDirs);\n            const transformedFiles = _this4.transformedFiles;\n            const filesToUnpack = [];\n            const fileCopier = new (_fs || _load_fs()).FileCopier();\n            /* tslint:disable:rule1 prefer-const */\n            for (let i = 0, n = files.length; i < n; i++) {\n                const file = files[i];\n                const stat = metadata.get(file);\n                if (stat.isFile()) {\n                    const fileParent = _path.dirname(file);\n                    const dirNode = _this4.fs.getOrCreateNode(fileParent);\n                    const newData = transformedFiles == null ? null : transformedFiles[i];\n                    const node = _this4.fs.getOrCreateNode(file);\n                    node.size = newData == null ? stat.size : Buffer.byteLength(newData);\n                    if (dirNode.unpacked || _this4.unpackPattern != null && _this4.unpackPattern(file, stat)) {\n                        node.unpacked = true;\n                        if (newData != null) {\n                            transformedFiles[i] = null;\n                        }\n                        if (!dirNode.unpacked && !dirToCreateForUnpackedFiles.has(fileParent)) {\n                            dirToCreateForUnpackedFiles.add(fileParent);\n                            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(fileParent.replace(_this4.src, unpackedDest));\n                        }\n                        const unpackedFile = file.replace(_this4.src, unpackedDest);\n                        filesToUnpack.push(newData == null ? { src: file, destination: unpackedFile, stats: stat } : { destination: unpackedFile, data: newData, stats: stat });\n                        if (filesToUnpack.length > (_fs || _load_fs()).MAX_FILE_REQUESTS) {\n                            yield writeUnpackedFiles(filesToUnpack, fileCopier);\n                            filesToUnpack.length = 0;\n                        }\n                    } else {\n                        if (newData == null) {\n                            transformedFiles[i] = true;\n                        }\n                        _this4.fs.insertFileNode(node, stat, file);\n                    }\n                } else if (stat.isDirectory()) {\n                    let unpacked = false;\n                    if (unpackedDirs.has(file)) {\n                        unpacked = true;\n                    } else {\n                        for (const dir of unpackedDirs) {\n                            if (file.length > dir.length + 2 && file[dir.length] === _path.sep && file.startsWith(dir)) {\n                                unpacked = true;\n                                unpackedDirs.add(file);\n                                // not all dirs marked as unpacked after first iteration - because node module dir can be marked as unpacked after processing node module dir content\n                                // e.g. node-notifier/example/advanced.js processed, but only on process vendor/terminal-notifier.app module will be marked as unpacked\n                                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(file.replace(_this4.src, unpackedDest));\n                                break;\n                            }\n                        }\n                    }\n                    _this4.fs.insertDirectory(file, unpacked);\n                } else if (stat.isSymbolicLink()) {\n                    _this4.fs.getOrCreateNode(file).link = stat.relativeLink;\n                }\n            }\n            if (filesToUnpack.length > 0) {\n                yield writeUnpackedFiles(filesToUnpack, fileCopier);\n            }\n            yield _this4.writeAsarFile(files);\n        })();\n    }\n    writeAsarFile(files) {\n        const headerPickle = pickle.createEmpty();\n        headerPickle.writeString(JSON.stringify(this.fs.header));\n        const headerBuf = headerPickle.toBuffer();\n        const sizePickle = pickle.createEmpty();\n        sizePickle.writeUInt32(headerBuf.length);\n        const sizeBuf = sizePickle.toBuffer();\n        const transformedFiles = this.transformedFiles;\n        const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);\n        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {\n            writeStream.on(\"error\", reject);\n            writeStream.on(\"close\", resolve);\n            writeStream.write(sizeBuf);\n            const w = index => {\n                let data;\n                while (true) {\n                    if (index >= files.length) {\n                        writeStream.end();\n                        return;\n                    }\n                    if ((data = transformedFiles[index++]) != null) {\n                        break;\n                    }\n                }\n                const file = files[index - 1];\n                if (data !== true) {\n                    writeStream.write(data, () => w(index));\n                    return;\n                }\n                const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(file);\n                readStream.on(\"error\", reject);\n                readStream.once(\"end\", () => w(index));\n                readStream.pipe(writeStream, {\n                    end: false\n                });\n            };\n            writeStream.write(headerBuf, () => w(0));\n        });\n    }\n    order(filenames) {\n        var _this5 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const orderingFiles = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_this5.options.ordering, \"utf8\")).split(\"\\n\").map(function (line) {\n                if (line.indexOf(\":\") !== -1) {\n                    line = line.split(\":\").pop();\n                }\n                line = line.trim();\n                if (line[0] === \"/\") {\n                    line = line.slice(1);\n                }\n                return line;\n            });\n            const ordering = [];\n            for (const file of orderingFiles) {\n                const pathComponents = file.split(_path.sep);\n                let str = _this5.src;\n                for (const pathComponent of pathComponents) {\n                    str = _path.join(str, pathComponent);\n                    ordering.push(str);\n                }\n            }\n            const filenamesSorted = [];\n            let missing = 0;\n            const total = filenames.length;\n            for (const file of ordering) {\n                if (!(filenamesSorted.indexOf(file) !== -1) && filenames.indexOf(file) !== -1) {\n                    filenamesSorted.push(file);\n                }\n            }\n            for (const file of filenames) {\n                if (!(filenamesSorted.indexOf(file) !== -1)) {\n                    filenamesSorted.push(file);\n                    missing += 1;\n                }\n            }\n            (0, (_log || _load_log()).log)(`Ordering file has ${(total - missing) / total * 100}% coverage.`);\n            return filenamesSorted;\n        })();\n    }\n}\nexports.AsarPackager = AsarPackager;","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/codeSign.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.findIdentityRawResult = exports.createKeychain = exports.downloadCertificate = exports.appleCertificatePrefixes = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet downloadCertificate = exports.downloadCertificate = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (urlOrBase64, tmpDir) {\n        let file = null;\n        if (urlOrBase64.length > 3 && urlOrBase64[1] === \":\" || urlOrBase64.startsWith(\"/\")) {\n            file = urlOrBase64;\n        } else if (urlOrBase64.startsWith(\"file://\")) {\n            file = urlOrBase64.substring(\"file://\".length);\n        } else if (urlOrBase64.startsWith(\"~/\")) {\n            file = _path.join((0, (_os || _load_os()).homedir)(), urlOrBase64.substring(\"~/\".length));\n        } else {\n            const tempFile = yield tmpDir.getTempFile(\".p12\");\n            if (urlOrBase64.startsWith(\"https://\")) {\n                yield (0, (_electronBuilderHttp || _load_electronBuilderHttp()).download)(urlOrBase64, tempFile);\n            } else {\n                yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(tempFile, new Buffer(urlOrBase64, \"base64\"));\n            }\n            return tempFile;\n        }\n        const stat = yield (0, (_fs || _load_fs()).statOrNull)(file);\n        if (stat == null) {\n            throw new Error(`${file} doesn't exist`);\n        } else if (!stat.isFile()) {\n            throw new Error(`${file} not a file`);\n        } else {\n            return file;\n        }\n    });\n\n    return function downloadCertificate(_x, _x2) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\n// \"Note that filename will not be searched to resolve the signing identity's certificate chain unless it is also on the user's keychain search list.\"\n// but \"security list-keychains\" doesn't support add - we should 1) get current list 2) set new list - it is very bad http://stackoverflow.com/questions/10538942/add-a-keychain-to-search-list\n// \"overly complicated and introduces a race condition.\"\n// https://github.com/electron-userland/electron-builder/issues/398\nlet createCustomCertKeychain = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n        // copy to temp and then atomic rename to final path\n        const tmpKeychainPath = _path.join((0, (_electronBuilderUtil || _load_electronBuilderUtil()).getCacheDirectory)(), (0, (_electronBuilderUtil || _load_electronBuilderUtil()).getTempName)(\"electron-builder-root-certs\"));\n        const keychainPath = _path.join((0, (_electronBuilderUtil || _load_electronBuilderUtil()).getCacheDirectory)(), \"electron-builder-root-certs.keychain\");\n        const results = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"security\", [\"list-keychains\"]), (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(__dirname, \"..\", \"certs\", \"root_certs.keychain\"), tmpKeychainPath).then(function () {\n            return (0, (_fsExtraP || _load_fsExtraP()).rename)(tmpKeychainPath, keychainPath);\n        })]);\n        const list = results[0].split(\"\\n\").map(function (it) {\n            const r = it.trim();\n            return r.substring(1, r.length - 1);\n        }).filter(function (it) {\n            return it.length > 0;\n        });\n        if (!(list.indexOf(keychainPath) !== -1)) {\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"security\", [\"list-keychains\", \"-d\", \"user\", \"-s\", keychainPath].concat(list));\n        }\n    });\n\n    return function createCustomCertKeychain() {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet createKeychain = exports.createKeychain = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tmpDir, cscLink, cscKeyPassword, cscILink, cscIKeyPassword) {\n        if (bundledCertKeychainAdded == null) {\n            bundledCertKeychainAdded = createCustomCertKeychain();\n        }\n        yield bundledCertKeychainAdded;\n        const keychainName = yield tmpDir.getTempFile(\".keychain\");\n        const certLinks = [cscLink];\n        if (cscILink != null) {\n            certLinks.push(cscILink);\n        }\n        const certPaths = new Array(certLinks.length);\n        const keychainPassword = (0, (_crypto || _load_crypto()).randomBytes)(8).toString(\"hex\");\n        return yield (0, (_promise || _load_promise()).executeFinally)((_bluebirdLst2 || _load_bluebirdLst2()).default.all([(_bluebirdLst2 || _load_bluebirdLst2()).default.map(certLinks, function (link, i) {\n            return downloadCertificate(link, tmpDir).then(function (it) {\n                return certPaths[i] = it;\n            });\n        }), (_bluebirdLst2 || _load_bluebirdLst2()).default.mapSeries([[\"create-keychain\", \"-p\", keychainPassword, keychainName], [\"unlock-keychain\", \"-p\", keychainPassword, keychainName], [\"set-keychain-settings\", \"-t\", \"3600\", \"-u\", keychainName]], function (it) {\n            return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"security\", it);\n        })]).then(function () {\n            return importCerts(keychainName, certPaths, [cscKeyPassword, cscIKeyPassword].filter(function (it) {\n                return it != null;\n            }));\n        }), function () {\n            return (0, (_promise || _load_promise()).all)(certPaths.map(function (it, index) {\n                return certLinks[index].startsWith(\"https://\") ? (0, (_fsExtraP || _load_fsExtraP()).deleteFile)(it, true) : (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();\n            }));\n        });\n    });\n\n    return function createKeychain(_x3, _x4, _x5, _x6, _x7) {\n        return _ref3.apply(this, arguments);\n    };\n})();\n\nlet importCerts = (() => {\n    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (keychainName, paths, keyPasswords) {\n        for (let i = 0; i < paths.length; i++) {\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"security\", [\"import\", paths[i], \"-k\", keychainName, \"-T\", \"/usr/bin/codesign\", \"-T\", \"/usr/bin/productbuild\", \"-P\", keyPasswords[i]]);\n        }\n        return {\n            keychainName: keychainName\n        };\n    });\n\n    return function importCerts(_x8, _x9, _x10) {\n        return _ref4.apply(this, arguments);\n    };\n})();\n\nlet getValidIdentities = (() => {\n    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (keychain) {\n        function addKeychain(args) {\n            if (keychain != null) {\n                args.push(keychain);\n            }\n            return args;\n        }\n        let result = findIdentityRawResult;\n        if (result == null || keychain != null) {\n            // https://github.com/electron-userland/electron-builder/issues/481\n            // https://github.com/electron-userland/electron-builder/issues/535\n            result = (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"security\", addKeychain([\"find-identity\", \"-v\"])).then(function (it) {\n                return it.trim().split(\"\\n\").filter(function (it) {\n                    for (const prefix of appleCertificatePrefixes) {\n                        if (it.indexOf(prefix) !== -1) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n            }), (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"security\", addKeychain([\"find-identity\", \"-v\", \"-p\", \"codesigning\"])).then(function (it) {\n                return it.trim().split(\"\\n\");\n            })]).then(function (it) {\n                const array = it[0].concat(it[1]).filter(function (it) {\n                    return !(it.indexOf(\"(Missing required extension)\") !== -1) && !(it.indexOf(\"valid identities found\") !== -1) && !(it.indexOf(\"iPhone \") !== -1) && !(it.indexOf(\"com.apple.idms.appleid.prd.\") !== -1);\n                }).map(function (it) {\n                    return it.substring(it.indexOf(\")\") + 1).trim();\n                });\n                return Array.from(new Set(array));\n            });\n            if (keychain == null) {\n                exports.findIdentityRawResult = findIdentityRawResult = result;\n            }\n        }\n        return result;\n    });\n\n    return function getValidIdentities(_x11) {\n        return _ref5.apply(this, arguments);\n    };\n})();\n\nlet _findIdentity = (() => {\n    var _ref6 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (type, qualifier, keychain) {\n        // https://github.com/electron-userland/electron-builder/issues/484\n        //noinspection SpellCheckingInspection\n        const lines = yield getValidIdentities(keychain);\n        const namePrefix = `${type}:`;\n        for (const line of lines) {\n            if (qualifier != null && !(line.indexOf(qualifier) !== -1)) {\n                continue;\n            }\n            if (line.indexOf(namePrefix) !== -1) {\n                return line.substring(line.indexOf('\"') + 1, line.lastIndexOf('\"'));\n            }\n        }\n        if (type === \"Developer ID Application\") {\n            // find non-Apple certificate\n            // https://github.com/electron-userland/electron-builder/issues/458\n            l: for (const line of lines) {\n                if (qualifier != null && !(line.indexOf(qualifier) !== -1)) {\n                    continue;\n                }\n                if (line.indexOf(\"Mac Developer:\") !== -1) {\n                    continue;\n                }\n                for (const prefix of appleCertificatePrefixes) {\n                    if (line.indexOf(prefix) !== -1) {\n                        continue l;\n                    }\n                }\n                return line.substring(line.indexOf('\"') + 1, line.lastIndexOf('\"'));\n            }\n        }\n        return null;\n    });\n\n    return function _findIdentity(_x12, _x13, _x14) {\n        return _ref6.apply(this, arguments);\n    };\n})();\n\nexports.sign = sign;\nexports.findIdentity = findIdentity;\n\nvar _crypto;\n\nfunction _load_crypto() {\n    return _crypto = require(\"crypto\");\n}\n\nvar _electronBuilderHttp;\n\nfunction _load_electronBuilderHttp() {\n    return _electronBuilderHttp = require(\"electron-builder-http\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n    return _isCi = _interopRequireDefault(require(\"is-ci\"));\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst appleCertificatePrefixes = exports.appleCertificatePrefixes = [\"Developer ID Application:\", \"Developer ID Installer:\", \"3rd Party Mac Developer Application:\", \"3rd Party Mac Developer Installer:\"];\n\nlet bundledCertKeychainAdded = null;function sign(path, name, keychain) {\n    const args = [\"--deep\", \"--force\", \"--sign\", name, path];\n    if (keychain != null) {\n        args.push(\"--keychain\", keychain);\n    }\n    return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"codesign\", args);\n}\nlet findIdentityRawResult = exports.findIdentityRawResult = null;\nfunction findIdentity(certType, qualifier, keychain) {\n    let identity = qualifier || process.env.CSC_NAME;\n    if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(identity)) {\n        if (keychain == null && !(_isCi || _load_isCi()).default && process.env.CSC_IDENTITY_AUTO_DISCOVERY === \"false\") {\n            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);\n        } else {\n            return _findIdentity(certType, null, keychain);\n        }\n    } else {\n        identity = identity.trim();\n        for (const prefix of appleCertificatePrefixes) {\n            checkPrefix(identity, prefix);\n        }\n        return _findIdentity(certType, identity, keychain);\n    }\n}\nfunction checkPrefix(name, prefix) {\n    if (name.startsWith(prefix)) {\n        throw new Error(`Please remove prefix \"${prefix}\" from the specified name — appropriate certificate will be chosen automatically`);\n    }\n}\n//# sourceMappingURL=codeSign.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/errorMessages.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst authorEmailIsMissed = exports.authorEmailIsMissed = `Please specify author 'email' in the application package.json\n\nSee https://docs.npmjs.com/files/package.json#people-fields-author-contributors\n\nIt is required to set Linux .deb package maintainer. Or you can set maintainer in the custom linux options.\n(see https://github.com/electron-userland/electron-builder#distributable-format-configuration).\n`;\n//# sourceMappingURL=errorMessages.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/fileMatcher.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.FileMatcher = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nexports.createFileMatcher = createFileMatcher;\nexports.getFileMatchers = getFileMatchers;\nexports.copyFiles = copyFiles;\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _minimatch;\n\nfunction _load_minimatch() {\n    return _minimatch = require(\"minimatch\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _filter;\n\nfunction _load_filter() {\n    return _filter = require(\"./util/filter\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass FileMatcher {\n    constructor(from, to, macroExpander, patterns) {\n        this.macroExpander = macroExpander;\n        this.from = macroExpander(from);\n        this.to = macroExpander(to);\n        this.patterns = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(patterns).map(it => _path.posix.normalize(macroExpander(it)));\n    }\n    addPattern(pattern) {\n        this.patterns.push(_path.posix.normalize(this.macroExpander(pattern)));\n    }\n    addAllPattern() {\n        // must be first, see minimatchAll implementation\n        this.patterns.unshift(\"**/*\");\n    }\n    isEmpty() {\n        return this.patterns.length === 0;\n    }\n    containsOnlyIgnore() {\n        return !this.isEmpty() && this.patterns.find(it => !it.startsWith(\"!\")) == null;\n    }\n    computeParsedPatterns(result, fromDir) {\n        // https://github.com/electron-userland/electron-builder/issues/733\n        const minimatchOptions = { dot: true };\n        const relativeFrom = fromDir == null ? null : _path.relative(fromDir, this.from);\n        if (this.patterns.length === 0 && relativeFrom != null) {\n            // file mappings, from here is a file\n            result.push(new (_minimatch || _load_minimatch()).Minimatch(relativeFrom, minimatchOptions));\n            return;\n        }\n        for (let pattern of this.patterns) {\n            if (relativeFrom != null) {\n                pattern = _path.join(relativeFrom, pattern);\n            }\n            const parsedPattern = new (_minimatch || _load_minimatch()).Minimatch(pattern, minimatchOptions);\n            result.push(parsedPattern);\n            if (!(0, (_filter || _load_filter()).hasMagic)(parsedPattern)) {\n                // https://github.com/electron-userland/electron-builder/issues/545\n                // add **/*\n                result.push(new (_minimatch || _load_minimatch()).Minimatch(`${pattern}/**/*`, minimatchOptions));\n            }\n        }\n    }\n    createFilter(ignoreFiles, rawFilter, excludePatterns) {\n        const parsedPatterns = [];\n        this.computeParsedPatterns(parsedPatterns);\n        return (0, (_filter || _load_filter()).createFilter)(this.from, parsedPatterns, ignoreFiles, rawFilter, excludePatterns);\n    }\n}\nexports.FileMatcher = FileMatcher;\nfunction createFileMatcher(info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions) {\n    const patterns = info.isPrepackedAppAsar ? null : getFileMatchers(info.config, \"files\", appDir, _path.join(resourcesPath, \"app\"), false, macroExpander, platformSpecificBuildOptions);\n    const matcher = patterns == null ? new FileMatcher(appDir, _path.join(resourcesPath, \"app\"), macroExpander) : patterns[0];\n    if (matcher.isEmpty() || matcher.containsOnlyIgnore()) {\n        matcher.addAllPattern();\n    } else {\n        matcher.addPattern(\"package.json\");\n    }\n    matcher.addPattern(\"!**/node_modules/*/{CHANGELOG.md,ChangeLog,changelog.md,README.md,README,readme.md,readme,test,__tests__,tests,powered-test,example,examples,*.d.ts}\");\n    matcher.addPattern(\"!**/node_modules/.bin\");\n    matcher.addPattern(\"!**/*.{o,hprof,orig,pyc,pyo,rbc,swp}\");\n    matcher.addPattern(\"!**/._*\");\n    matcher.addPattern(\"!*.iml\");\n    //noinspection SpellCheckingInspection\n    matcher.addPattern(\"!**/{.git,.hg,.svn,CVS,RCS,SCCS,\" + \"__pycache__,.DS_Store,thumbs.db,.gitignore,.gitattributes,\" + \".editorconfig,.flowconfig,.jshintrc,.eslintrc,\" + \".yarn-integrity,.yarn-metadata.json,yarn-error.log,yarn.lock,npm-debug.log,\" + \".idea,\" + \"appveyor.yml,.travis.yml,circle.yml,\" + \".nyc_output}\");\n    return matcher;\n}\nfunction getFileMatchers(config, name, defaultSrc, defaultDest, allowAdvancedMatching, macroExpander, customBuildOptions) {\n    const globalPatterns = config[name];\n    const platformSpecificPatterns = customBuildOptions[name];\n    const defaultMatcher = new FileMatcher(defaultSrc, defaultDest, macroExpander);\n    const fileMatchers = [];\n    function addPatterns(patterns) {\n        if (patterns == null) {\n            return;\n        } else if (!Array.isArray(patterns)) {\n            if (typeof patterns === \"string\") {\n                defaultMatcher.addPattern(patterns);\n                return;\n            }\n            patterns = [patterns];\n        }\n        for (const pattern of patterns) {\n            if (typeof pattern === \"string\") {\n                // use normalize to transform ./foo to foo\n                defaultMatcher.addPattern(pattern);\n            } else if (allowAdvancedMatching) {\n                const from = pattern.from == null ? defaultSrc : _path.resolve(defaultSrc, pattern.from);\n                const to = pattern.to == null ? defaultDest : _path.resolve(defaultDest, pattern.to);\n                fileMatchers.push(new FileMatcher(from, to, macroExpander, pattern.filter));\n            } else {\n                throw new Error(`Advanced file copying not supported for \"${name}\"`);\n            }\n        }\n    }\n    addPatterns(globalPatterns);\n    addPatterns(platformSpecificPatterns);\n    if (!defaultMatcher.isEmpty()) {\n        // default matcher should be first in the array\n        fileMatchers.unshift(defaultMatcher);\n    }\n    return fileMatchers.length === 0 ? null : fileMatchers;\n}\nfunction copyFiles(patterns) {\n    if (patterns == null || patterns.length === 0) {\n        return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();\n    }\n    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map(patterns, (() => {\n        var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (pattern) {\n            const fromStat = yield (0, (_fs || _load_fs()).statOrNull)(pattern.from);\n            if (fromStat == null) {\n                (0, (_log || _load_log()).warn)(`File source ${pattern.from} doesn't exist`);\n                return;\n            }\n            if (fromStat.isFile()) {\n                const toStat = yield (0, (_fs || _load_fs()).statOrNull)(pattern.to);\n                // https://github.com/electron-userland/electron-builder/issues/1245\n                if (toStat != null && toStat.isDirectory()) {\n                    return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, _path.join(pattern.to, _path.basename(pattern.from)), fromStat);\n                }\n                yield (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(_path.dirname(pattern.to));\n                return yield (0, (_fs || _load_fs()).copyFile)(pattern.from, pattern.to, fromStat);\n            }\n            if (pattern.isEmpty() || pattern.containsOnlyIgnore()) {\n                pattern.addAllPattern();\n            }\n            return yield (0, (_fs || _load_fs()).copyDir)(pattern.from, pattern.to, pattern.createFilter());\n        });\n\n        return function (_x) {\n            return _ref.apply(this, arguments);\n        };\n    })());\n}\n//# sourceMappingURL=fileMatcher.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/fileTransformer.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createTransformer = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet createTransformer = exports.createTransformer = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (srcDir, extraMetadata) {\n        const mainPackageJson = _path.join(srcDir, \"package.json\");\n        return function (file) {\n            if (file === mainPackageJson) {\n                return modifyMainPackageJson(file, extraMetadata);\n            } else if (file.endsWith(\"/package.json\") && file.indexOf(\"/node_modules/\") !== -1) {\n                return (0, (_fsExtraP || _load_fsExtraP()).readJson)(file).then(function (it) {\n                    return cleanupPackageJson(it, false);\n                }).catch(function (e) {\n                    return (0, (_log || _load_log()).warn)(e);\n                });\n            } else {\n                return null;\n            }\n        };\n    });\n\n    return function createTransformer(_x, _x2) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet modifyMainPackageJson = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file, extraMetadata) {\n        const mainPackageData = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(file);\n        if (extraMetadata != null) {\n            (0, (_deepAssign || _load_deepAssign()).deepAssign)(mainPackageData, extraMetadata);\n        }\n        // https://github.com/electron-userland/electron-builder/issues/1212\n        const serializedDataIfChanged = cleanupPackageJson(mainPackageData, true);\n        if (serializedDataIfChanged != null) {\n            return serializedDataIfChanged;\n        } else if (extraMetadata != null) {\n            return JSON.stringify(mainPackageData, null, 2);\n        }\n        return null;\n    });\n\n    return function modifyMainPackageJson(_x3, _x4) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=fileTransformer.js.map\n\n\nexports.isElectronCompileUsed = isElectronCompileUsed;\nexports.createElectronCompilerHost = createElectronCompilerHost;\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _deepAssign;\n\nfunction _load_deepAssign() {\n    return _deepAssign = require(\"electron-builder-util/out/deepAssign\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction isElectronCompileUsed(info) {\n    if (info.config.electronCompile != null) {\n        return info.config.electronCompile;\n    }\n    // if in devDependencies - it means that babel is used for precompilation or for some reason user decided to not use electron-compile for production\n    const deps = info.metadata.dependencies;\n    return deps != null && \"electron-compile\" in deps;\n}\nfunction createElectronCompilerHost(projectDir, cacheDir) {\n    const electronCompilePath = _path.join(projectDir, \"node_modules\", \"electron-compile\", \"lib\");\n    return require(_path.join(electronCompilePath, \"config-parser\")).createCompilerHostFromProjectRoot(projectDir, cacheDir);\n}\nfunction cleanupPackageJson(data, isMain) {\n    try {\n        let changed = false;\n        for (const prop of Object.getOwnPropertyNames(data)) {\n            if (prop[0] === \"_\" || prop === \"dist\" || prop === \"gitHead\" || prop === \"keywords\" || prop === \"build\" || isMain && prop === \"devDependencies\" || prop === \"scripts\") {\n                delete data[prop];\n                changed = true;\n            }\n        }\n        if (changed) {\n            return JSON.stringify(data, null, 2);\n        }\n    } catch (e) {\n        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(e);\n    }\n    return null;\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/linuxPackager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LinuxPackager = undefined;\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _sanitizeFilename;\n\nfunction _load_sanitizeFilename() {\n    return _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\n}\n\nvar _platformPackager;\n\nfunction _load_platformPackager() {\n    return _platformPackager = require(\"./platformPackager\");\n}\n\nvar _LinuxTargetHelper;\n\nfunction _load_LinuxTargetHelper() {\n    return _LinuxTargetHelper = require(\"./targets/LinuxTargetHelper\");\n}\n\nvar _targetFactory;\n\nfunction _load_targetFactory() {\n    return _targetFactory = require(\"./targets/targetFactory\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nclass LinuxPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {\n    constructor(info) {\n        super(info);\n        const executableName = this.platformSpecificBuildOptions.executableName;\n        this.executableName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(executableName == null ? this.appInfo.name.toLowerCase() : executableName);\n    }\n    get defaultTarget() {\n        return [\"appimage\"];\n    }\n    createTargets(targets, mapper, cleanupTasks) {\n        let helper;\n        const getHelper = () => {\n            if (helper == null) {\n                helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).LinuxTargetHelper(this);\n            }\n            return helper;\n        };\n        for (const name of targets) {\n            if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {\n                continue;\n            }\n            const targetClass = (() => {\n                switch (name) {\n                    case \"appimage\":\n                        return require(\"./targets/appImage\").default;\n                    case \"snap\":\n                        return require(\"./targets/snap\").default;\n                    case \"deb\":\n                    case \"rpm\":\n                    case \"sh\":\n                    case \"freebsd\":\n                    case \"pacman\":\n                    case \"apk\":\n                    case \"p5p\":\n                        return require(\"./targets/fpm\").default;\n                    default:\n                        return null;\n                }\n            })();\n            mapper(name, outDir => targetClass === null ? (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this) : new targetClass(name, this, getHelper(), outDir));\n        }\n    }\n    get platform() {\n        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX;\n    }\n    postInitApp(appOutDir) {\n        return (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, this.electronDistExecutableName), _path.join(appOutDir, this.executableName));\n    }\n}\nexports.LinuxPackager = LinuxPackager; //# sourceMappingURL=linuxPackager.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/platformPackager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PlatformPackager = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet dependencies = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (dir, result) {\n        const pathToDep = yield (0, (_readInstalled || _load_readInstalled()).readInstalled)(dir);\n        for (const dep of pathToDep.values()) {\n            if (dep.extraneous) {\n                result.add(dep.path);\n            }\n        }\n    });\n\n    return function dependencies(_x3, _x4) {\n        return _ref.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=platformPackager.js.map\n\n\nexports.normalizeExt = normalizeExt;\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _deepAssign;\n\nfunction _load_deepAssign() {\n    return _deepAssign = require(\"electron-builder-util/out/deepAssign\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _asarUtil;\n\nfunction _load_asarUtil() {\n    return _asarUtil = require(\"./asarUtil\");\n}\n\nvar _fileMatcher;\n\nfunction _load_fileMatcher() {\n    return _fileMatcher = require(\"./fileMatcher\");\n}\n\nvar _fileTransformer;\n\nfunction _load_fileTransformer() {\n    return _fileTransformer = require(\"./fileTransformer\");\n}\n\nvar _dirPackager;\n\nfunction _load_dirPackager() {\n    return _dirPackager = require(\"./packager/dirPackager\");\n}\n\nvar _readInstalled;\n\nfunction _load_readInstalled() {\n    return _readInstalled = require(\"./readInstalled\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PlatformPackager {\n    constructor(info) {\n        this.info = info;\n        this._resourceList = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() => {\n            return (0, (_fsExtraP || _load_fsExtraP()).readdir)(this.buildResourcesDir).catch(e => {\n                if (e.code !== \"ENOENT\") {\n                    throw e;\n                }\n                return [];\n            });\n        });\n        this.config = info.config;\n        this.platformSpecificBuildOptions = PlatformPackager.normalizePlatformSpecificBuildOptions(this.config[this.platform.buildConfigurationKey]);\n        this.appInfo = this.prepareAppInfo(info.appInfo);\n        this.packagerOptions = info.options;\n        this.projectDir = info.projectDir;\n        this.buildResourcesDir = _path.resolve(this.projectDir, this.relativeBuildResourcesDirname);\n    }\n    get resourceList() {\n        return this._resourceList.value;\n    }\n    prepareAppInfo(appInfo) {\n        return appInfo;\n    }\n    static normalizePlatformSpecificBuildOptions(options) {\n        return options == null ? Object.create(null) : options;\n    }\n    getCscPassword() {\n        const password = this.doGetCscPassword();\n        if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(password)) {\n            (0, (_log || _load_log()).log)(\"CSC_KEY_PASSWORD is not defined, empty password will be used\");\n            return \"\";\n        } else {\n            return password.trim();\n        }\n    }\n    doGetCscPassword() {\n        return this.packagerOptions.cscKeyPassword || process.env.CSC_KEY_PASSWORD;\n    }\n    get relativeBuildResourcesDirname() {\n        return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(this.config.directories, it => it.buildResources) || \"build\";\n    }\n    computeAppOutDir(outDir, arch) {\n        return this.info.prepackaged || _path.join(outDir, `${this.platform.buildConfigurationKey}${(0, (_electronBuilderCore || _load_electronBuilderCore()).getArchSuffix)(arch)}${this.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? \"\" : \"-unpacked\"}`);\n    }\n    dispatchArtifactCreated(file, target, arch, safeArtifactName) {\n        this.info.dispatchArtifactCreated({\n            file, safeArtifactName, target, arch,\n            packager: this\n        });\n    }\n    pack(outDir, arch, targets, postAsyncTasks) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const appOutDir = _this.computeAppOutDir(outDir, arch);\n            yield _this.doPack(outDir, appOutDir, _this.platform.nodeName, arch, _this.platformSpecificBuildOptions, targets);\n            _this.packageInDistributableFormat(appOutDir, arch, targets, postAsyncTasks);\n        })();\n    }\n    packageInDistributableFormat(appOutDir, arch, targets, postAsyncTasks) {\n        postAsyncTasks.push((_bluebirdLst2 || _load_bluebirdLst2()).default.map(targets, it => it.isAsyncSupported ? it.build(appOutDir, arch) : null).then(() => (_bluebirdLst2 || _load_bluebirdLst2()).default.each(targets, it => it.isAsyncSupported ? null : it.build(appOutDir, arch))));\n    }\n    getExtraFileMatchers(isResources, appOutDir, macroExpander, customBuildOptions) {\n        const base = isResources ? this.getResourcesDir(appOutDir) : this.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? _path.join(appOutDir, `${this.appInfo.productFilename}.app`, \"Contents\") : appOutDir;\n        return (0, (_fileMatcher || _load_fileMatcher()).getFileMatchers)(this.config, isResources ? \"extraResources\" : \"extraFiles\", this.projectDir, base, true, macroExpander, customBuildOptions);\n    }\n    get electronDistMacOsAppName() {\n        return this.info.muonVersion == null ? \"Electron.app\" : \"Brave.app\";\n    }\n    get electronDistExecutableName() {\n        return this.info.muonVersion == null ? \"electron\" : \"brave\";\n    }\n    get electronDistMacOsExecutableName() {\n        return this.info.muonVersion == null ? \"Electron\" : \"Brave\";\n    }\n    doPack(outDir, appOutDir, platformName, arch, platformSpecificBuildOptions, targets) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            if (_this2.info.prepackaged != null) {\n                return;\n            }\n            const asarOptions = yield _this2.computeAsarOptions(platformSpecificBuildOptions);\n            const macroExpander = function (it) {\n                return _this2.expandMacro(it, arch, { \"/*\": \"{,/**/*}\" });\n            };\n            const extraResourceMatchers = _this2.getExtraFileMatchers(true, appOutDir, macroExpander, platformSpecificBuildOptions);\n            const extraFileMatchers = _this2.getExtraFileMatchers(false, appOutDir, macroExpander, platformSpecificBuildOptions);\n            const resourcesPath = _this2.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? _path.join(appOutDir, _this2.electronDistMacOsAppName, \"Contents\", \"Resources\") : _path.join(appOutDir, \"resources\");\n            const muonVersion = _this2.info.muonVersion;\n            const isElectron = muonVersion == null;\n            (0, (_log || _load_log()).log)(`Packaging for ${platformName} ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]} using ${isElectron ? `electron ${_this2.info.electronVersion}` : `muon ${muonVersion}`} to ${_path.relative(_this2.projectDir, appOutDir)}`);\n            const appDir = _this2.info.appDir;\n            const ignoreFiles = new Set([_path.resolve(_this2.info.projectDir, outDir), _path.resolve(_this2.info.projectDir, _this2.buildResourcesDir), _path.resolve(_this2.info.projectDir, \"electron-builder.yml\"), _path.resolve(_this2.info.projectDir, \"electron-builder.json\"), _path.resolve(_this2.info.projectDir, \"electron-builder.json5\")]);\n            if (_this2.info.isPrepackedAppAsar) {\n                yield (0, (_dirPackager || _load_dirPackager()).unpackElectron)(_this2, appOutDir, platformName, (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch], _this2.info.electronVersion);\n            } else {\n                // prune dev or not listed dependencies\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([dependencies(appDir, ignoreFiles), isElectron ? (0, (_dirPackager || _load_dirPackager()).unpackElectron)(_this2, appOutDir, platformName, (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch], _this2.info.electronVersion) : (0, (_dirPackager || _load_dirPackager()).unpackMuon)(_this2, appOutDir, platformName, (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch], muonVersion)]);\n                if ((_electronBuilderUtil || _load_electronBuilderUtil()).debug.enabled) {\n                    const nodeModulesDir = _path.join(appDir, \"node_modules\");\n                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`Dev or extraneous dependencies: ${Array.from(ignoreFiles).slice(2).map(function (it) {\n                        return _path.relative(nodeModulesDir, it);\n                    }).join(\", \")}`);\n                }\n            }\n            let rawFilter = null;\n            const excludePatterns = [];\n            if (extraResourceMatchers != null) {\n                for (const matcher of extraResourceMatchers) {\n                    matcher.computeParsedPatterns(excludePatterns, _this2.info.projectDir);\n                }\n            }\n            if (extraFileMatchers != null) {\n                for (const matcher of extraFileMatchers) {\n                    matcher.computeParsedPatterns(excludePatterns, _this2.info.projectDir);\n                }\n            }\n            const defaultMatcher = (0, (_fileMatcher || _load_fileMatcher()).createFileMatcher)(_this2.info, appDir, resourcesPath, macroExpander, platformSpecificBuildOptions);\n            const isElectronCompile = asarOptions != null && (0, (_fileTransformer || _load_fileTransformer()).isElectronCompileUsed)(_this2.info);\n            if (isElectronCompile) {\n                defaultMatcher.addPattern(\"!.cache{,/**/*}\");\n            }\n            const filter = defaultMatcher.createFilter(ignoreFiles, rawFilter, excludePatterns.length > 0 ? excludePatterns : null);\n            const transformer = yield (0, (_fileTransformer || _load_fileTransformer()).createTransformer)(appDir, isElectronCompile ? Object.assign({\n                originalMain: _this2.info.metadata.main,\n                main: \"es6-shim.js\"\n            }, _this2.packagerOptions.extraMetadata) : _this2.packagerOptions.extraMetadata);\n            let promise;\n            if (_this2.info.isPrepackedAppAsar) {\n                promise = (0, (_fs || _load_fs()).copyDir)(appDir, _path.join(resourcesPath), filter, transformer);\n            } else if (asarOptions == null) {\n                promise = (0, (_fs || _load_fs()).copyDir)(appDir, _path.join(resourcesPath, \"app\"), filter, transformer);\n            } else {\n                const unpackPattern = (0, (_fileMatcher || _load_fileMatcher()).getFileMatchers)(_this2.config, \"asarUnpack\", appDir, _path.join(resourcesPath, \"app\"), false, macroExpander, platformSpecificBuildOptions);\n                const fileMatcher = unpackPattern == null ? null : unpackPattern[0];\n                promise = new (_asarUtil || _load_asarUtil()).AsarPackager(appDir, resourcesPath, asarOptions, fileMatcher == null ? null : fileMatcher.createFilter(), transformer).pack(filter, isElectronCompile);\n            }\n            //noinspection ES6MissingAwait\n            const promises = [promise, (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(resourcesPath, \"default_app.asar\")), (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, \"version\")), _this2.postInitApp(appOutDir)];\n            if (_this2.platform !== (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {\n                promises.push((0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, \"LICENSE\"), _path.join(appOutDir, \"LICENSE.electron.txt\")).catch(function () {}));\n            }\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);\n            if (platformName === \"darwin\" || platformName === \"mas\") {\n                yield require(\"./packager/mac\").createApp(_this2, appOutDir);\n            }\n            yield (0, (_fileMatcher || _load_fileMatcher()).copyFiles)(extraResourceMatchers);\n            yield (0, (_fileMatcher || _load_fileMatcher()).copyFiles)(extraFileMatchers);\n            if (_this2.info.cancellationToken.cancelled) {\n                return;\n            }\n            yield _this2.info.afterPack({\n                appOutDir: appOutDir,\n                packager: _this2,\n                electronPlatformName: platformName,\n                arch: arch,\n                targets: targets\n            });\n            yield _this2.sanityCheckPackage(appOutDir, asarOptions != null);\n        })();\n    }\n    postInitApp(executableFile) {\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {})();\n    }\n    getIconPath() {\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            return null;\n        })();\n    }\n    computeAsarOptions(customBuildOptions) {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            function errorMessage(name) {\n                return `${name} is deprecated is deprecated and not supported — please use asarUnpack`;\n            }\n            const buildMetadata = _this3.config;\n            if (buildMetadata[\"asar-unpack\"] != null) {\n                throw new Error(errorMessage(\"asar-unpack\"));\n            }\n            if (buildMetadata[\"asar-unpack-dir\"] != null) {\n                throw new Error(errorMessage(\"asar-unpack-dir\"));\n            }\n            const platformSpecific = customBuildOptions.asar;\n            const result = platformSpecific == null ? _this3.config.asar : platformSpecific;\n            if (result === false) {\n                const appAsarStat = yield (0, (_fs || _load_fs()).statOrNull)(_path.join(_this3.info.appDir, \"app.asar\"));\n                //noinspection ES6MissingAwait\n                if (appAsarStat == null || !appAsarStat.isFile()) {\n                    (0, (_log || _load_log()).warn)(\"Packaging using asar archive is disabled — it is strongly not recommended.\\n\" + \"Please enable asar and use asarUnpack to unpack files that must be externally available.\");\n                }\n                return null;\n            }\n            if (result == null || result === true) {\n                return {};\n            }\n            for (const name of [\"unpackDir\", \"unpack\"]) {\n                if (result[name] != null) {\n                    throw new Error(errorMessage(`asar.${name}`));\n                }\n            }\n            return (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, result);\n        })();\n    }\n    getResourcesDir(appOutDir) {\n        return this.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? this.getMacOsResourcesDir(appOutDir) : _path.join(appOutDir, \"resources\");\n    }\n    getMacOsResourcesDir(appOutDir) {\n        return _path.join(appOutDir, `${this.appInfo.productFilename}.app`, \"Contents\", \"Resources\");\n    }\n    checkFileInPackage(resourcesDir, file, messagePrefix, isAsar) {\n        var _this4 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const relativeFile = _path.relative(_this4.info.appDir, _path.resolve(_this4.info.appDir, file));\n            if (isAsar) {\n                yield (0, (_asarUtil || _load_asarUtil()).checkFileInArchive)(_path.join(resourcesDir, \"app.asar\"), relativeFile, messagePrefix);\n                return;\n            }\n            const pathParsed = _path.parse(file);\n            // Even when packaging to asar is disabled, it does not imply that the main file can not be inside an .asar archive.\n            // This may occur when the packaging is done manually before processing with electron-builder.\n            if (pathParsed.dir.indexOf(\".asar\") !== -1) {\n                // The path needs to be split to the part with an asar archive which acts like a directory and the part with\n                // the path to main file itself. (e.g. path/arch.asar/dir/index.js -> path/arch.asar, dir/index.js)\n                const pathSplit = pathParsed.dir.split(_path.sep);\n                let partWithAsarIndex = 0;\n                pathSplit.some(function (pathPart, index) {\n                    partWithAsarIndex = index;\n                    return pathPart.endsWith(\".asar\");\n                });\n                const asarPath = _path.join.apply(_path, pathSplit.slice(0, partWithAsarIndex + 1));\n                let mainPath = pathSplit.length > partWithAsarIndex + 1 ? _path.join.apply(pathSplit.slice(partWithAsarIndex + 1)) : \"\";\n                mainPath += _path.join(mainPath, pathParsed.base);\n                yield (0, (_asarUtil || _load_asarUtil()).checkFileInArchive)(_path.join(resourcesDir, \"app\", asarPath), mainPath, messagePrefix);\n            } else {\n                const outStat = yield (0, (_fs || _load_fs()).statOrNull)(_path.join(resourcesDir, \"app\", relativeFile));\n                if (outStat == null) {\n                    throw new Error(`${messagePrefix} \"${relativeFile}\" does not exist. Seems like a wrong configuration.`);\n                } else {\n                    //noinspection ES6MissingAwait\n                    if (!outStat.isFile()) {\n                        throw new Error(`${messagePrefix} \"${relativeFile}\" is not a file. Seems like a wrong configuration.`);\n                    }\n                }\n            }\n        })();\n    }\n    sanityCheckPackage(appOutDir, isAsar) {\n        var _this5 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const outStat = yield (0, (_fs || _load_fs()).statOrNull)(appOutDir);\n            if (outStat == null) {\n                throw new Error(`Output directory \"${appOutDir}\" does not exist. Seems like a wrong configuration.`);\n            } else {\n                //noinspection ES6MissingAwait\n                if (!outStat.isDirectory()) {\n                    throw new Error(`Output directory \"${appOutDir}\" is not a directory. Seems like a wrong configuration.`);\n                }\n            }\n            const resourcesDir = _this5.getResourcesDir(appOutDir);\n            yield _this5.checkFileInPackage(resourcesDir, _this5.appInfo.metadata.main || \"index.js\", \"Application entry file\", isAsar);\n            yield _this5.checkFileInPackage(resourcesDir, \"package.json\", \"Application\", isAsar);\n        })();\n    }\n    expandArtifactNamePattern(targetSpecificOptions, ext, arch, defaultPattern) {\n        let pattern = targetSpecificOptions == null ? null : targetSpecificOptions.artifactName;\n        if (pattern == null) {\n            pattern = this.platformSpecificBuildOptions.artifactName || this.config.artifactName || defaultPattern || \"${productName}-${version}.${ext}\";\n        }\n        return this.expandMacro(pattern, arch, {\n            ext: ext\n        });\n    }\n    expandMacro(pattern, arch) {\n        let extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (arch == null) {\n            pattern = pattern.replace(\"-${arch}\", \"\").replace(\" ${arch}\", \"\").replace(\"_${arch}\", \"\").replace(\"/${arch}\", \"\");\n        }\n        const appInfo = this.appInfo;\n        return pattern.replace(/\\$\\{([_a-zA-Z./*]+)\\}/g, (match, p1) => {\n            switch (p1) {\n                case \"name\":\n                    return appInfo.name;\n                case \"version\":\n                    return appInfo.version;\n                case \"productName\":\n                    return appInfo.productFilename;\n                case \"arch\":\n                    if (arch == null) {\n                        // see above, we remove macro if no arch\n                        return \"\";\n                    }\n                    return (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch];\n                case \"os\":\n                    return this.platform.buildConfigurationKey;\n                default:\n                    if (p1.startsWith(\"env.\")) {\n                        const envName = p1.substring(\"env.\".length);\n                        const envValue = process.env[envName];\n                        if (envValue == null) {\n                            throw new Error(`Env ${envName} is not defined`);\n                        }\n                        return envValue;\n                    }\n                    const value = extra[p1];\n                    if (value == null) {\n                        throw new Error(`Macro ${p1} is not defined`);\n                    } else {\n                        return value;\n                    }\n            }\n        });\n    }\n    generateName(ext, arch, deployment) {\n        let classifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n        let c = null;\n        let e = null;\n        if (arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64) {\n            if (ext === \"AppImage\") {\n                c = \"x86_64\";\n            } else if (ext === \"deb\") {\n                c = \"amd64\";\n            }\n        } else if (arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 && ext === \"deb\") {\n            c = \"i386\";\n        } else if (ext === \"pacman\") {\n            if (arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32) {\n                c = \"i686\";\n            }\n            e = \"pkg.tar.xz\";\n        } else {\n            c = (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch];\n        }\n        if (c == null) {\n            c = classifier;\n        } else if (classifier != null) {\n            c += `-${classifier}`;\n        }\n        if (e == null) {\n            e = ext;\n        }\n        return this.generateName2(e, c, deployment);\n    }\n    generateName2(ext, classifier, deployment) {\n        const dotExt = ext == null ? \"\" : `.${ext}`;\n        const separator = ext === \"deb\" ? \"_\" : \"-\";\n        return `${deployment ? this.appInfo.name : this.appInfo.productFilename}${separator}${this.appInfo.version}${classifier == null ? \"\" : `${separator}${classifier}`}${dotExt}`;\n    }\n    getDefaultIcon(ext) {\n        var _this6 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const resourceList = yield _this6.resourceList;\n            const name = `icon.${ext}`;\n            if (resourceList.indexOf(name) !== -1) {\n                return _path.join(_this6.buildResourcesDir, name);\n            } else {\n                (0, (_log || _load_log()).warn)(\"Application icon is not set, default Electron icon will be used\");\n                return null;\n            }\n        })();\n    }\n    getTempFile(suffix) {\n        return this.info.tempDirManager.getTempFile(suffix);\n    }\n    get fileAssociations() {\n        return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(this.config.fileAssociations).concat((0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(this.platformSpecificBuildOptions.fileAssociations));\n    }\n    getResource(custom) {\n        var _this7 = this;\n\n        for (var _len = arguments.length, names = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            names[_key - 1] = arguments[_key];\n        }\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            if (custom === undefined) {\n                const resourceList = yield _this7.resourceList;\n                for (const name of names) {\n                    if (resourceList.indexOf(name) !== -1) {\n                        return _path.join(_this7.buildResourcesDir, name);\n                    }\n                }\n            } else if (custom != null && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(custom)) {\n                const resourceList = yield _this7.resourceList;\n                if (resourceList.indexOf(custom) !== -1) {\n                    return _path.join(_this7.buildResourcesDir, custom);\n                }\n                let p = _path.resolve(_this7.buildResourcesDir, custom);\n                if ((yield (0, (_fs || _load_fs()).statOrNull)(p)) == null) {\n                    p = _path.resolve(_this7.projectDir, custom);\n                    if ((yield (0, (_fs || _load_fs()).statOrNull)(p)) == null) {\n                        throw new Error(`Cannot find specified resource \"${custom}\", nor relative to \"${_this7.buildResourcesDir}\", neither relative to project dir (\"${_this7.projectDir}\")`);\n                    }\n                }\n                return p;\n            }\n            return null;\n        })();\n    }\n    get forceCodeSigning() {\n        const forceCodeSigningPlatform = this.platformSpecificBuildOptions.forceCodeSigning;\n        return (forceCodeSigningPlatform == null ? this.config.forceCodeSigning : forceCodeSigningPlatform) || false;\n    }\n}\nexports.PlatformPackager = PlatformPackager; // remove leading dot\n\nfunction normalizeExt(ext) {\n    return ext.startsWith(\".\") ? ext.substring(1) : ext;\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/macPackager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _deepAssign;\n\nfunction _load_deepAssign() {\n    return _deepAssign = require(\"electron-builder-util/out/deepAssign\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _electronOsxSign;\n\nfunction _load_electronOsxSign() {\n    return _electronOsxSign = require(\"electron-osx-sign\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _appInfo;\n\nfunction _load_appInfo() {\n    return _appInfo = require(\"./appInfo\");\n}\n\nvar _codeSign;\n\nfunction _load_codeSign() {\n    return _codeSign = require(\"./codeSign\");\n}\n\nvar _platformPackager;\n\nfunction _load_platformPackager() {\n    return _platformPackager = require(\"./platformPackager\");\n}\n\nvar _dmg;\n\nfunction _load_dmg() {\n    return _dmg = require(\"./targets/dmg\");\n}\n\nvar _pkg;\n\nfunction _load_pkg() {\n    return _pkg = require(\"./targets/pkg\");\n}\n\nvar _targetFactory;\n\nfunction _load_targetFactory() {\n    return _targetFactory = require(\"./targets/targetFactory\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass MacPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {\n    constructor(info) {\n        super(info);\n        if (this.packagerOptions.cscLink == null || process.platform !== \"darwin\") {\n            this.codeSigningInfo = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(Object.create(null));\n        } else {\n            this.codeSigningInfo = (0, (_codeSign || _load_codeSign()).createKeychain)(info.tempDirManager, this.packagerOptions.cscLink, this.getCscPassword(), this.packagerOptions.cscInstallerLink, this.packagerOptions.cscInstallerKeyPassword);\n        }\n    }\n    get defaultTarget() {\n        return [\"zip\", \"dmg\"];\n    }\n    prepareAppInfo(appInfo) {\n        return new (_appInfo || _load_appInfo()).AppInfo(appInfo.metadata, this.info, this.platformSpecificBuildOptions.bundleVersion);\n    }\n    getIconPath() {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            let iconPath = _this.platformSpecificBuildOptions.icon || _this.config.icon;\n            if (iconPath != null && !iconPath.endsWith(\".icns\")) {\n                iconPath += \".icns\";\n            }\n            return iconPath == null ? yield _this.getDefaultIcon(\"icns\") : yield _this.getResource(iconPath);\n        })();\n    }\n    createTargets(targets, mapper, cleanupTasks) {\n        for (const name of targets) {\n            switch (name) {\n                case (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET:\n                    break;\n                case \"dmg\":\n                    mapper(\"dmg\", outDir => new (_dmg || _load_dmg()).DmgTarget(this, outDir));\n                    break;\n                case \"pkg\":\n                    mapper(\"pkg\", outDir => new (_pkg || _load_pkg()).PkgTarget(this, outDir));\n                    break;\n                default:\n                    mapper(name, outDir => name === \"mas\" || name === \"mas-dev\" ? new (_targetFactory || _load_targetFactory()).NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));\n                    break;\n            }\n        }\n    }\n    get platform() {\n        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;\n    }\n    pack(outDir, arch, targets, postAsyncTasks) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            let nonMasPromise = null;\n            const hasMas = targets.length !== 0 && targets.some(function (it) {\n                return it.name === \"mas\" || it.name === \"mas-dev\";\n            });\n            const prepackaged = _this2.info.prepackaged;\n            if (!hasMas || targets.length > 1) {\n                const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename}.app`) : prepackaged;\n                nonMasPromise = (prepackaged ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve() : _this2.doPack(outDir, _path.dirname(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {\n                    return _this2.sign(appPath, null, null);\n                }).then(function () {\n                    return _this2.packageInDistributableFormat(appPath, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, targets, postAsyncTasks);\n                });\n            }\n            for (const target of targets) {\n                const targetName = target.name;\n                if (!(targetName === \"mas\" || targetName === \"mas-dev\")) {\n                    continue;\n                }\n                const masBuildOptions = (0, (_deepAssign || _load_deepAssign()).deepAssign)({}, _this2.platformSpecificBuildOptions, _this2.config.mas);\n                if (targetName === \"mas-dev\") {\n                    (0, (_deepAssign || _load_deepAssign()).deepAssign)(masBuildOptions, _this2.config[targetName]);\n                    masBuildOptions.type = \"development\";\n                }\n                const targetOutDir = _path.join(outDir, targetName);\n                if (prepackaged == null) {\n                    yield _this2.doPack(outDir, targetOutDir, \"mas\", arch, masBuildOptions, [target]);\n                    yield _this2.sign(_path.join(targetOutDir, `${_this2.appInfo.productFilename}.app`), targetOutDir, masBuildOptions);\n                } else {\n                    yield _this2.sign(prepackaged, targetOutDir, masBuildOptions);\n                }\n            }\n            if (nonMasPromise != null) {\n                yield nonMasPromise;\n            }\n        })();\n    }\n    sign(appPath, outDir, masOptions) {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            if (process.platform !== \"darwin\") {\n                (0, (_log || _load_log()).warn)(\"macOS application code signing is supported only on macOS, skipping.\");\n                return;\n            }\n            if ((0, (_electronBuilderUtil || _load_electronBuilderUtil()).isPullRequest)()) {\n                (0, (_log || _load_log()).log)(\"Current build is a part of pull request, code signing will be skipped\");\n                return;\n            }\n            const keychainName = (yield _this3.codeSigningInfo).keychainName;\n            const isMas = masOptions != null;\n            const qualifier = _this3.platformSpecificBuildOptions.identity;\n            if (!isMas && qualifier === null) {\n                if (_this3.forceCodeSigning) {\n                    throw new Error(\"identity explicitly is set to null, but forceCodeSigning is set to true\");\n                }\n                (0, (_log || _load_log()).log)(\"identity explicitly is set to null, skipping macOS application code signing.\");\n                return;\n            }\n            const masQualifier = isMas ? masOptions.identity || qualifier : null;\n            const explicitType = masOptions == null ? _this3.platformSpecificBuildOptions.type : masOptions.type;\n            const type = explicitType || \"distribution\";\n            const isDevelopment = type === \"development\";\n            let name = yield (0, (_codeSign || _load_codeSign()).findIdentity)(isDevelopment ? \"Mac Developer\" : isMas ? \"3rd Party Mac Developer Application\" : \"Developer ID Application\", isMas ? masQualifier : qualifier, keychainName);\n            if (name == null) {\n                if (!isMas && !isDevelopment && explicitType !== \"distribution\") {\n                    name = yield (0, (_codeSign || _load_codeSign()).findIdentity)(\"Mac Developer\", qualifier, keychainName);\n                    if (name != null) {\n                        (0, (_log || _load_log()).warn)(\"Mac Developer is used to sign app — it is only for development and testing, not for production\");\n                    } else if (qualifier != null) {\n                        throw new Error(`Identity name \"${qualifier}\" is specified, but no valid identity with this name in the keychain`);\n                    }\n                }\n                if (name == null) {\n                    const message = process.env.CSC_IDENTITY_AUTO_DISCOVERY === \"false\" ? `App is not signed: env CSC_IDENTITY_AUTO_DISCOVERY is set to false` : `App is not signed: cannot find valid ${isMas ? '\"3rd Party Mac Developer Application\" identity' : `\"Developer ID Application\" identity or custom non-Apple code signing certificate`}, see https://github.com/electron-userland/electron-builder/wiki/Code-Signing`;\n                    if (isMas || _this3.forceCodeSigning) {\n                        throw new Error(message);\n                    } else {\n                        (0, (_log || _load_log()).warn)(message);\n                        return;\n                    }\n                }\n            }\n            const signOptions = {\n                skipIdentityValidation: true,\n                identity: name,\n                type: type,\n                platform: isMas ? \"mas\" : \"darwin\",\n                version: _this3.info.electronVersion,\n                app: appPath,\n                keychain: keychainName || undefined,\n                \"gatekeeper-assess\": (_codeSign || _load_codeSign()).appleCertificatePrefixes.find(function (it) {\n                    return name.startsWith(it);\n                }) != null\n            };\n            const resourceList = yield _this3.resourceList;\n            if (resourceList.indexOf(`entitlements.osx.plist`) !== -1) {\n                throw new Error(\"entitlements.osx.plist is deprecated name, please use entitlements.mac.plist\");\n            }\n            if (resourceList.indexOf(`entitlements.osx.inherit.plist`) !== -1) {\n                throw new Error(\"entitlements.osx.inherit.plist is deprecated name, please use entitlements.mac.inherit.plist\");\n            }\n            const customSignOptions = masOptions || _this3.platformSpecificBuildOptions;\n            if (customSignOptions.entitlements == null) {\n                const p = `entitlements.${isMas ? \"mas\" : \"mac\"}.plist`;\n                if (resourceList.indexOf(p) !== -1) {\n                    signOptions.entitlements = _path.join(_this3.buildResourcesDir, p);\n                }\n            } else {\n                signOptions.entitlements = customSignOptions.entitlements;\n            }\n            if (customSignOptions.entitlementsInherit == null) {\n                const p = `entitlements.${isMas ? \"mas\" : \"mac\"}.inherit.plist`;\n                if (resourceList.indexOf(p) !== -1) {\n                    signOptions[\"entitlements-inherit\"] = _path.join(_this3.buildResourcesDir, p);\n                }\n            } else {\n                signOptions[\"entitlements-inherit\"] = customSignOptions.entitlementsInherit;\n            }\n            yield (0, (_log || _load_log()).task)(`Signing app (identity: ${name})`, _this3.doSign(signOptions));\n            if (masOptions != null) {\n                const certType = \"3rd Party Mac Developer Installer\";\n                const masInstallerIdentity = yield (0, (_codeSign || _load_codeSign()).findIdentity)(certType, masOptions.identity, keychainName);\n                if (masInstallerIdentity == null) {\n                    throw new Error(`Cannot find valid \"${certType}\" identity to sign MAS installer, please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing`);\n                }\n                const pkg = _path.join(outDir, _this3.expandArtifactNamePattern(masOptions, \"pkg\"));\n                yield _this3.doFlat(appPath, pkg, masInstallerIdentity, keychainName);\n                _this3.dispatchArtifactCreated(pkg, null, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, `${_this3.appInfo.name}-${_this3.appInfo.version}.pkg`);\n            }\n        })();\n    }\n    //noinspection JSMethodCanBeStatic\n    doSign(opts) {\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            return (0, (_electronOsxSign || _load_electronOsxSign()).signAsync)(opts);\n        })();\n    }\n    //noinspection JSMethodCanBeStatic\n    doFlat(appPath, outFile, identity, keychain) {\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            // productbuild doesn't created directory for out file\n            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(outFile));\n            const args = (0, (_pkg || _load_pkg()).prepareProductBuildArgs)(identity, keychain);\n            args.push(\"--component\", appPath, \"/Applications\");\n            args.push(outFile);\n            return yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"productbuild\", args);\n        })();\n    }\n}\nexports.default = MacPackager; //# sourceMappingURL=macPackager.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/metadata.js":"//# sourceMappingURL=metadata.js.map\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/packagerApi.js":"//# sourceMappingURL=packagerApi.js.map\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/readInstalled.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.readInstalled = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet readInstalled = exports.readInstalled = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (folder) {\n        const opts = {\n            depth: Infinity,\n            dev: false\n        };\n        const findUnmetSeen = new Set();\n        const pathToDep = new Map();\n        const obj = yield _readInstalled(folder, null, null, 0, opts, pathToDep, findUnmetSeen);\n        unmarkExtraneous(obj, opts.dev, true);\n        return pathToDep;\n    });\n\n    return function readInstalled(_x) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet _readInstalled = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (folder, parent, name, depth, opts, realpathSeen, findUnmetSeen) {\n        const realDir = yield (0, (_fsExtraP || _load_fsExtraP()).realpath)(folder);\n        const processed = realpathSeen.get(realDir);\n        if (processed != null) {\n            return processed;\n        }\n        const obj = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.resolve(folder, \"package.json\"));\n        obj.realPath = realDir;\n        obj.path = obj.path || folder;\n        //noinspection ES6MissingAwait\n        if ((yield (0, (_fsExtraP || _load_fsExtraP()).lstat)(folder)).isSymbolicLink()) {\n            obj.link = realDir;\n        }\n        obj.realName = name || obj.name;\n        obj.dependencyNames = obj.dependencies == null ? null : new Set(Object.keys(obj.dependencies));\n        // Mark as extraneous at this point.\n        // This will be un-marked in unmarkExtraneous, where we mark as not-extraneous everything that is required in some way from the root object.\n        obj.extraneous = true;\n        obj.optional = true;\n        if (parent != null && obj.link == null) {\n            obj.parent = parent;\n        }\n        realpathSeen.set(realDir, obj);\n        if (depth > opts.depth) {\n            return obj;\n        }\n        const deps = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map((yield readScopedDir(_path.join(folder, \"node_modules\"))), (() => {\n            var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (pkg) {\n                try {\n                    return yield _readInstalled(_path.join(folder, \"node_modules\", pkg), obj, pkg, depth + 1, opts, realpathSeen, findUnmetSeen);\n                } catch (e) {\n                    // https://github.com/electron-userland/electron-builder/issues/1424\n                    if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n                        return null;\n                    }\n                    throw e;\n                }\n            });\n\n            return function (_x9) {\n                return _ref3.apply(this, arguments);\n            };\n        })(), { concurrency: 8 });\n        if (obj.dependencies != null) {\n            for (const dep of deps) {\n                if (dep != null) {\n                    obj.dependencies[dep.realName] = dep;\n                }\n            }\n            // any strings in the obj.dependencies are unmet deps. However, if it's optional, then that's fine, so just delete it.\n            if (obj.optionalDependencies != null) {\n                for (const dep of Object.keys(obj.optionalDependencies)) {\n                    if (typeof obj.dependencies[dep] === \"string\") {\n                        delete obj.dependencies[dep];\n                    }\n                }\n            }\n        }\n        return obj;\n    });\n\n    return function _readInstalled(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet readScopedDir = (() => {\n    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (dir) {\n        let files;\n        try {\n            files = (yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(dir)).filter(function (it) {\n                return !it.startsWith(\".\");\n            });\n        } catch (e) {\n            // error indicates that nothing is installed here\n            return [];\n        }\n        files.sort();\n        const scopes = files.filter(function (it) {\n            return it.startsWith(\"@\");\n        });\n        if (scopes.length === 0) {\n            return files;\n        }\n        const result = files.filter(function (it) {\n            return !it.startsWith(\"@\");\n        });\n        const scopeFileList = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(scopes, function (it) {\n            return (0, (_fsExtraP || _load_fsExtraP()).readdir)(_path.join(dir, it));\n        });\n        for (let i = 0; i < scopes.length; i++) {\n            for (const file of scopeFileList[i]) {\n                if (!file.startsWith(\".\")) {\n                    result.push(`${scopes[i]}/${file}`);\n                }\n            }\n        }\n        result.sort();\n        return result;\n    });\n\n    return function readScopedDir(_x10) {\n        return _ref4.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=readInstalled.js.map\n\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction unmark(deps, obj, dev, unsetOptional) {\n    for (const name of deps) {\n        const dep = findDep(obj, name);\n        if (dep != null) {\n            if (unsetOptional) {\n                dep.optional = false;\n            }\n            if (dep.extraneous) {\n                unmarkExtraneous(dep, dev, false);\n            }\n        }\n    }\n}\nfunction unmarkExtraneous(obj, dev, isRoot) {\n    // Mark all non-required deps as extraneous.\n    // start from the root object and mark as non-extraneous all modules\n    // that haven't been previously flagged as extraneous then propagate to all their dependencies\n    obj.extraneous = false;\n    if (obj.dependencyNames != null) {\n        unmark(obj.dependencyNames, obj, dev, true);\n    }\n    if (dev && obj.devDependencies != null && (isRoot || obj.link)) {\n        unmark(Object.keys(obj.devDependencies), obj, dev, true);\n    }\n    if (obj.peerDependencies != null) {\n        unmark(Object.keys(obj.peerDependencies), obj, dev, true);\n    }\n    if (obj.optionalDependencies != null) {\n        unmark(Object.keys(obj.optionalDependencies), obj, dev, false);\n    }\n}\n// find the one that will actually be loaded by require() so we can make sure it's valid\nfunction findDep(obj, name) {\n    let r = obj;\n    let found = null;\n    while (r != null && found == null) {\n        // if r is a valid choice, then use that.\n        // kinda weird if a pkg depends on itself, but after the first iteration of this loop, it indicates a dep cycle.\n        const dependency = r.dependencies == null ? null : r.dependencies[name];\n        if (typeof dependency === \"object\") {\n            found = dependency;\n        }\n        if (found == null && r.realName === name) {\n            found = r;\n        }\n        r = r.link ? null : r.parent;\n    }\n    return found;\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/repositoryInfo.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet getGitUrlFromGitConfig = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir) {\n        let data = null;\n        try {\n            data = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(projectDir, \".git\", \"config\"), \"utf8\");\n        } catch (e) {\n            if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n                return null;\n            }\n            throw e;\n        }\n        const conf = data.split(/\\r?\\n/);\n        const i = conf.indexOf('[remote \"origin\"]');\n        if (i !== -1) {\n            let u = conf[i + 1];\n            if (!u.match(/^\\s*url =/)) {\n                u = conf[i + 2];\n            }\n            if (u.match(/^\\s*url =/)) {\n                return u.replace(/^\\s*url = /, \"\");\n            }\n        }\n        return null;\n    });\n\n    return function getGitUrlFromGitConfig(_x) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet _getInfo = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, repo) {\n        if (repo != null) {\n            return (0, (_hostedGitInfo || _load_hostedGitInfo()).fromUrl)(typeof repo === \"string\" ? repo : repo.url);\n        }\n        let url = process.env.TRAVIS_REPO_SLUG;\n        if (url == null) {\n            const user = process.env.APPVEYOR_ACCOUNT_NAME || process.env.CIRCLE_PROJECT_USERNAME;\n            const project = process.env.APPVEYOR_PROJECT_NAME || process.env.CIRCLE_PROJECT_REPONAME;\n            if (user != null && project != null) {\n                return {\n                    user: user,\n                    project: project\n                };\n            }\n            url = yield getGitUrlFromGitConfig(projectDir);\n        }\n        return url == null ? null : (0, (_hostedGitInfo || _load_hostedGitInfo()).fromUrl)(url);\n    });\n\n    return function _getInfo(_x2, _x3) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=repositoryInfo.js.map\n\n\nexports.getRepositoryInfo = getRepositoryInfo;\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _hostedGitInfo;\n\nfunction _load_hostedGitInfo() {\n    return _hostedGitInfo = require(\"hosted-git-info\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction getRepositoryInfo(projectDir, metadata, devMetadata) {\n    return _getInfo(projectDir, (devMetadata == null ? null : devMetadata.repository) || (metadata == null ? null : metadata.repository));\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/windowsCodeSign.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getToolPath = exports.sign = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet sign = exports.sign = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (options) {\n        let hashes = options.options.signingHashAlgorithms;\n        // msi does not support dual-signing\n        if (options.path.endsWith(\".msi\")) {\n            hashes = [hashes != null && !(hashes.indexOf(\"sha1\") !== -1) ? \"sha256\" : \"sha1\"];\n        } else if (options.path.endsWith(\".appx\")) {\n            hashes = [\"sha256\"];\n        } else {\n            if (hashes == null) {\n                hashes = [\"sha1\", \"sha256\"];\n            } else {\n                hashes = Array.isArray(hashes) ? hashes.slice() : [hashes];\n            }\n        }\n        const isWin = process.platform === \"win32\";\n        let nest = false;\n        //noinspection JSUnusedAssignment\n        let outputPath = \"\";\n        for (const hash of hashes) {\n            outputPath = isWin ? options.path : getOutputPath(options.path, hash);\n            yield spawnSign(options, options.path, outputPath, hash, nest);\n            nest = true;\n            if (!isWin) {\n                yield (0, (_fsExtraP || _load_fsExtraP()).rename)(outputPath, options.path);\n            }\n        }\n    });\n\n    return function sign(_x) {\n        return _ref.apply(this, arguments);\n    };\n})();\n// on windows be aware of http://stackoverflow.com/a/32640183/1910191\n\n\nlet spawnSign = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (options, inputPath, outputPath, hash, nest) {\n        const isWin = process.platform === \"win32\";\n        const args = isWin ? [\"sign\"] : [\"-in\", inputPath, \"-out\", outputPath];\n        if (process.env.ELECTRON_BUILDER_OFFLINE !== \"true\") {\n            const timestampingServiceUrl = options.options.timeStampServer || \"http://timestamp.verisign.com/scripts/timstamp.dll\";\n            if (isWin) {\n                args.push(nest || hash === \"sha256\" ? \"/tr\" : \"/t\", nest || hash === \"sha256\" ? options.options.rfc3161TimeStampServer || \"http://timestamp.comodoca.com/rfc3161\" : timestampingServiceUrl);\n            } else {\n                args.push(\"-t\", timestampingServiceUrl);\n            }\n        }\n        const certificateFile = options.cert;\n        if (certificateFile == null) {\n            const subjectName = options.options.certificateSubjectName;\n            if (process.platform !== \"win32\") {\n                throw new Error(`${subjectName == null ? \"certificateSha1\" : \"certificateSubjectName\"} supported only on Windows`);\n            }\n            if (subjectName == null) {\n                args.push(\"/sha1\", options.options.certificateSha1);\n            } else {\n                args.push(\"/n\", subjectName);\n            }\n        } else {\n            const certExtension = _path.extname(certificateFile);\n            if (certExtension === \".p12\" || certExtension === \".pfx\") {\n                args.push(isWin ? \"/f\" : \"-pkcs12\", certificateFile);\n            } else {\n                throw new Error(`Please specify pkcs12 (.p12/.pfx) file, ${certificateFile} is not correct`);\n            }\n        }\n        if (!isWin || hash !== \"sha1\") {\n            args.push(isWin ? \"/fd\" : \"-h\", hash);\n            if (isWin && process.env.ELECTRON_BUILDER_OFFLINE !== \"true\") {\n                args.push(\"/td\", \"sha256\");\n            }\n        }\n        if (options.name) {\n            args.push(isWin ? \"/d\" : \"-n\", options.name);\n        }\n        if (options.site) {\n            args.push(isWin ? \"/du\" : \"-i\", options.site);\n        }\n        // msi does not support dual-signing\n        if (nest) {\n            args.push(isWin ? \"/as\" : \"-nest\");\n        }\n        if (options.password) {\n            args.push(isWin ? \"/p\" : \"-pass\", options.password);\n        }\n        if (isWin) {\n            // must be last argument\n            args.push(inputPath);\n        }\n        return yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)((yield getToolPath()), args);\n    });\n\n    return function spawnSign(_x2, _x3, _x4, _x5, _x6) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet getToolPath = exports.getToolPath = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n        if (process.env.USE_SYSTEM_SIGNCODE) {\n            return \"osslsigncode\";\n        }\n        const result = process.env.SIGNTOOL_PATH;\n        if (result) {\n            return result;\n        }\n        const vendorPath = yield getSignVendorPath();\n        if (process.platform === \"win32\") {\n            if ((0, (_os || _load_os()).release)().startsWith(\"6.\")) {\n                return _path.join(vendorPath, \"windows-6\", \"signtool.exe\");\n            } else {\n                return _path.join(vendorPath, \"windows-10\", process.arch, \"signtool.exe\");\n            }\n        } else if (process.platform === \"darwin\" && (_isCi || _load_isCi()).default) {\n            return _path.join(vendorPath, process.platform, \"ci\", \"osslsigncode\");\n        } else {\n            return _path.join(vendorPath, process.platform, \"osslsigncode\");\n        }\n    });\n\n    return function getToolPath() {\n        return _ref3.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=windowsCodeSign.js.map\n\n\nexports.getSignVendorPath = getSignVendorPath;\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _binDownload;\n\nfunction _load_binDownload() {\n    return _binDownload = require(\"electron-builder-util/out/binDownload\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n    return _isCi = _interopRequireDefault(require(\"is-ci\"));\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TOOLS_VERSION = \"1.7.0\";\nfunction getSignVendorPath() {\n    //noinspection SpellCheckingInspection\n    return (0, (_binDownload || _load_binDownload()).getBinFromBintray)(\"winCodeSign\", TOOLS_VERSION, \"a34a60e74d02b81d0303e498f03c70ce0133f908b671f62ec32896db5cd0a716\");\n}\n\nfunction getOutputPath(inputPath, hash) {\n    const extension = _path.extname(inputPath);\n    return _path.join(_path.dirname(inputPath), `${_path.basename(inputPath, extension)}-signed-${hash}${extension}`);\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/winPackager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.WinPackager = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet checkIcon = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {\n        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(file, \"r\");\n        const buffer = new Buffer(512);\n        try {\n            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, buffer, 0, buffer.length, 0);\n        } finally {\n            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);\n        }\n        if (!isIco(buffer)) {\n            throw new Error(`Windows icon is not valid ico file, please fix \"${file}\"`);\n        }\n        const sizes = parseIco(buffer);\n        for (const size of sizes) {\n            if (size.w >= 256 && size.h >= 256) {\n                return;\n            }\n        }\n        throw new Error(`Windows icon size must be at least 256x256, please fix \"${file}\"`);\n    });\n\n    return function checkIcon(_x) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _nodeForge;\n\nfunction _load_nodeForge() {\n    return _nodeForge = _interopRequireWildcard(require(\"node-forge\"));\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _codeSign;\n\nfunction _load_codeSign() {\n    return _codeSign = require(\"./codeSign\");\n}\n\nvar _platformPackager;\n\nfunction _load_platformPackager() {\n    return _platformPackager = require(\"./platformPackager\");\n}\n\nvar _nsis;\n\nfunction _load_nsis() {\n    return _nsis = require(\"./targets/nsis\");\n}\n\nvar _targetFactory;\n\nfunction _load_targetFactory() {\n    return _targetFactory = require(\"./targets/targetFactory\");\n}\n\nvar _WebInstallerTarget;\n\nfunction _load_WebInstallerTarget() {\n    return _WebInstallerTarget = require(\"./targets/WebInstallerTarget\");\n}\n\nvar _windowsCodeSign;\n\nfunction _load_windowsCodeSign() {\n    return _windowsCodeSign = require(\"./windowsCodeSign\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass WinPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {\n    constructor(info) {\n        var _this;\n\n        _this = super(info);\n        this.cscInfo = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy(() => {\n            const platformSpecificBuildOptions = this.platformSpecificBuildOptions;\n            const subjectName = platformSpecificBuildOptions.certificateSubjectName;\n            if (subjectName != null) {\n                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({ subjectName });\n            }\n            const certificateSha1 = platformSpecificBuildOptions.certificateSha1;\n            if (certificateSha1 != null) {\n                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({ certificateSha1 });\n            }\n            const certificateFile = platformSpecificBuildOptions.certificateFile;\n            if (certificateFile != null) {\n                const certificatePassword = this.getCscPassword();\n                return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve({\n                    file: certificateFile,\n                    password: certificatePassword == null ? null : certificatePassword.trim()\n                });\n            } else {\n                const cscLink = process.env.WIN_CSC_LINK || this.packagerOptions.cscLink;\n                if (cscLink != null) {\n                    return (0, (_codeSign || _load_codeSign()).downloadCertificate)(cscLink, this.info.tempDirManager).then(path => {\n                        return {\n                            file: path,\n                            password: this.getCscPassword()\n                        };\n                    });\n                } else {\n                    return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);\n                }\n            }\n        });\n        this.computedPublisherName = new (_electronBuilderUtil || _load_electronBuilderUtil()).Lazy((0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            let publisherName = _this.platformSpecificBuildOptions.publisherName;\n            if (publisherName === null) {\n                return null;\n            }\n            const cscInfo = yield _this.cscInfo.value;\n            if (cscInfo == null) {\n                return null;\n            }\n            if (publisherName == null && cscInfo.file != null) {\n                try {\n                    // https://github.com/digitalbazaar/forge/issues/338#issuecomment-164831585\n                    const p12Asn1 = (_nodeForge || _load_nodeForge()).asn1.fromDer((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(cscInfo.file, \"binary\")), false);\n                    const p12 = (_nodeForge || _load_nodeForge()).pkcs12.pkcs12FromAsn1(p12Asn1, false, cscInfo.password);\n                    const bagType = (_nodeForge || _load_nodeForge()).pki.oids.certBag;\n                    publisherName = p12.getBags({ bagType: bagType })[bagType][0].cert.subject.getField(\"CN\").value;\n                } catch (e) {\n                    throw new Error(`Cannot extract publisher name from code signing certificate, please file issue. As workaround, set win.publisherName: ${e.stack || e}`);\n                }\n            }\n            return publisherName == null ? null : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(publisherName);\n        }));\n    }\n    get defaultTarget() {\n        return [\"nsis\"];\n    }\n    doGetCscPassword() {\n        return this.platformSpecificBuildOptions.certificatePassword || process.env.WIN_CSC_KEY_PASSWORD || super.doGetCscPassword();\n    }\n    createTargets(targets, mapper, cleanupTasks) {\n        let helper;\n        const getHelper = () => {\n            if (helper == null) {\n                helper = new (_nsis || _load_nsis()).AppPackageHelper();\n            }\n            return helper;\n        };\n        for (const name of targets) {\n            if (name === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {\n                continue;\n            }\n            if (name === \"nsis\" || name === \"portable\") {\n                mapper(name, outDir => new (_nsis || _load_nsis()).NsisTarget(this, outDir, name, getHelper()));\n            } else if (name === \"nsis-web\") {\n                mapper(name, outDir => new (_WebInstallerTarget || _load_WebInstallerTarget()).WebInstallerTarget(this, outDir, name, getHelper()));\n            } else {\n                const targetClass = (() => {\n                    switch (name) {\n                        case \"squirrel\":\n                            try {\n                                return require(\"electron-builder-squirrel-windows\").default;\n                            } catch (e) {\n                                throw new Error(`Module electron-builder-squirrel-windows must be installed in addition to build Squirrel.Windows: ${e.stack || e}`);\n                            }\n                        case \"appx\":\n                            return require(\"./targets/appx\").default;\n                        default:\n                            return null;\n                    }\n                })();\n                mapper(name, outDir => targetClass === null ? (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this) : new targetClass(this, outDir, name));\n            }\n        }\n    }\n    get platform() {\n        return (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS;\n    }\n    getIconPath() {\n        if (this.iconPath == null) {\n            this.iconPath = this.getValidIconPath();\n        }\n        return this.iconPath;\n    }\n    getValidIconPath() {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            let iconPath = _this2.platformSpecificBuildOptions.icon || _this2.config.icon;\n            if (iconPath != null && !iconPath.endsWith(\".ico\")) {\n                iconPath += \".ico\";\n            }\n            iconPath = iconPath == null ? yield _this2.getDefaultIcon(\"ico\") : _path.resolve(_this2.projectDir, iconPath);\n            if (iconPath == null) {\n                return null;\n            }\n            yield checkIcon(iconPath);\n            return iconPath;\n        })();\n    }\n    sign(file, logMessagePrefix) {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const cscInfo = yield _this3.cscInfo.value;\n            if (cscInfo == null) {\n                if (_this3.forceCodeSigning) {\n                    throw new Error(`App is not signed and \"forceCodeSigning\" is set to true, please ensure that code signing configuration is correct, please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing`);\n                }\n                return;\n            }\n            const certFile = cscInfo.file;\n            if (logMessagePrefix == null) {\n                logMessagePrefix = `Signing ${_path.basename(file)}`;\n            }\n            if (certFile == null) {\n                if (cscInfo.subjectName == null) {\n                    (0, (_log || _load_log()).log)(`${logMessagePrefix} (certificate SHA1: \"${cscInfo.certificateSha1}\")`);\n                } else {\n                    (0, (_log || _load_log()).log)(`${logMessagePrefix} (certificate subject name: \"${cscInfo.subjectName}\")`);\n                }\n            } else {\n                (0, (_log || _load_log()).log)(`${logMessagePrefix} (certificate file: \"${certFile}\")`);\n            }\n            yield _this3.doSign({\n                path: file,\n                cert: certFile,\n                password: cscInfo.password,\n                name: _this3.appInfo.productName,\n                site: yield _this3.appInfo.computePackageUrl(),\n                options: Object.assign({}, _this3.platformSpecificBuildOptions, {\n                    certificateSubjectName: cscInfo.subjectName,\n                    certificateSha1: cscInfo.certificateSha1\n                })\n            });\n        })();\n    }\n    //noinspection JSMethodCanBeStatic\n    doSign(options) {\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            for (let i = 0; i < 3; i++) {\n                try {\n                    yield (0, (_windowsCodeSign || _load_windowsCodeSign()).sign)(options);\n                    break;\n                } catch (e) {\n                    // https://github.com/electron-userland/electron-builder/issues/1414\n                    const message = e.message;\n                    if (message != null && message.indexOf(\"Couldn't resolve host name\") !== -1) {\n                        (0, (_log || _load_log()).warn)(`Cannot sign, attempt ${i + 1}: ${message}`);\n                        continue;\n                    }\n                    throw e;\n                }\n            }\n        })();\n    }\n    signAndEditResources(file) {\n        var _this4 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const appInfo = _this4.appInfo;\n            const args = [file, \"--set-version-string\", \"CompanyName\", appInfo.companyName, \"--set-version-string\", \"FileDescription\", appInfo.productName, \"--set-version-string\", \"ProductName\", appInfo.productName, \"--set-version-string\", \"InternalName\", _path.basename(appInfo.productFilename, \".exe\"), \"--set-version-string\", \"LegalCopyright\", appInfo.copyright, \"--set-version-string\", \"OriginalFilename\", \"\", \"--set-file-version\", appInfo.buildVersion, \"--set-product-version\", appInfo.versionInWeirdWindowsForm];\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(_this4.platformSpecificBuildOptions.legalTrademarks, function (it) {\n                return args.push(\"--set-version-string\", \"LegalTrademarks\", it);\n            });\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)((yield _this4.getIconPath()), function (it) {\n                return args.push(\"--set-icon\", it);\n            });\n            const rceditExecutable = _path.join((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), \"rcedit.exe\");\n            const isWin = process.platform === \"win32\";\n            if (!isWin) {\n                args.unshift(rceditExecutable);\n            }\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(isWin ? rceditExecutable : \"wine\", args);\n            yield _this4.sign(file);\n        })();\n    }\n    postInitApp(appOutDir) {\n        var _this5 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const executable = _path.join(appOutDir, `${_this5.appInfo.productFilename}.exe`);\n            yield (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(appOutDir, `${_this5.electronDistExecutableName}.exe`), executable);\n            yield _this5.signAndEditResources(executable);\n        })();\n    }\n}\nexports.WinPackager = WinPackager;\n\nfunction parseIco(buffer) {\n    if (!isIco(buffer)) {\n        throw new Error(\"buffer is not ico\");\n    }\n    const n = buffer.readUInt16LE(4);\n    const result = new Array(n);\n    for (let i = 0; i < n; i++) {\n        result[i] = {\n            w: buffer.readUInt8(6 + i * 16) || 256,\n            h: buffer.readUInt8(7 + i * 16) || 256\n        };\n    }\n    return result;\n}\nfunction isIco(buffer) {\n    return buffer.readUInt16LE(0) === 0 && buffer.readUInt16LE(2) === 1;\n}\n//# sourceMappingURL=winPackager.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/yarn.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.rebuild = exports.installOrRebuild = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet installOrRebuild = exports.installOrRebuild = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (config, appDir, frameworkInfo, platform, arch) {\n        let forceInstall = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n        const args = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(config.npmArgs);\n        if (forceInstall || !(yield (0, (_fs || _load_fs()).exists)(_path.join(appDir, \"node_modules\")))) {\n            yield installDependencies(appDir, frameworkInfo, platform, arch, args, !config.npmSkipBuildFromSource);\n        } else {\n            yield rebuild(appDir, frameworkInfo, platform, arch, args, !config.npmSkipBuildFromSource);\n        }\n    });\n\n    return function installOrRebuild(_x, _x2, _x3, _x4, _x5) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet rebuild = exports.rebuild = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (appDir, frameworkInfo) {\n        let platform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.platform;\n        let arch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : process.arch;\n        let additionalArgs = arguments[4];\n        let buildFromSource = arguments[5];\n\n        const pathToDep = yield (0, (_readInstalled || _load_readInstalled()).readInstalled)(appDir);\n        const nativeDeps = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.filter(pathToDep.values(), function (it) {\n            return it.extraneous ? false : (0, (_fs || _load_fs()).exists)(_path.join(it.path, \"binding.gyp\"));\n        }, { concurrency: 8 });\n        if (nativeDeps.length === 0) {\n            (0, (_log || _load_log()).log)(`No native production dependencies`);\n            return;\n        }\n        (0, (_log || _load_log()).log)(`Rebuilding native production dependencies for ${platform}:${arch}`);\n        let execPath = process.env.npm_execpath || process.env.NPM_CLI_JS;\n        const isYarn = isYarnPath(execPath);\n        const execArgs = [];\n        if (execPath == null) {\n            execPath = getPackageToolPath();\n        } else {\n            execArgs.push(execPath);\n            execPath = process.env.npm_node_execpath || process.env.NODE_EXE || \"node\";\n        }\n        const env = getGypEnv(frameworkInfo, platform, arch, buildFromSource);\n        if (isYarn) {\n            execArgs.push(\"run\", \"install\", \"--\");\n            execArgs.push.apply(execArgs, _toConsumableArray(additionalArgs));\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.each(nativeDeps, function (dep) {\n                (0, (_log || _load_log()).log)(`Rebuilding native dependency ${dep.name}`);\n                return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(execPath, execArgs, {\n                    cwd: dep.path,\n                    env: env\n                }).catch(function (error) {\n                    if (dep.optional) {\n                        (0, (_log || _load_log()).warn)(`Cannot build optional native dep ${dep.name}`);\n                    } else {\n                        throw error;\n                    }\n                });\n            });\n        } else {\n            execArgs.push(\"rebuild\");\n            execArgs.push.apply(execArgs, _toConsumableArray(additionalArgs));\n            execArgs.push.apply(execArgs, _toConsumableArray(nativeDeps.map(function (it) {\n                return it.name;\n            })));\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(execPath, execArgs, {\n                cwd: appDir,\n                env: env\n            });\n        }\n    });\n\n    return function rebuild(_x9, _x10) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=yarn.js.map\n\n\nexports.getGypEnv = getGypEnv;\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _readInstalled;\n\nfunction _load_readInstalled() {\n    return _readInstalled = require(\"./readInstalled\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nfunction getGypEnv(frameworkInfo, platform, arch, buildFromSource) {\n    if (!frameworkInfo.useCustomDist) {\n        return Object.assign({}, process.env, {\n            npm_config_arch: arch,\n            npm_config_target_arch: arch,\n            npm_config_platform: platform,\n            npm_config_build_from_source: buildFromSource\n        });\n    }\n    const gypHome = _path.join((0, (_os || _load_os()).homedir)(), \".electron-gyp\");\n    return Object.assign({}, process.env, {\n        npm_config_disturl: \"https://atom.io/download/electron\",\n        npm_config_target: frameworkInfo.version,\n        npm_config_runtime: \"electron\",\n        npm_config_arch: arch,\n        npm_config_target_arch: arch,\n        npm_config_platform: platform,\n        npm_config_build_from_source: buildFromSource,\n        HOME: gypHome,\n        USERPROFILE: gypHome\n    });\n}\nfunction installDependencies(appDir, frameworkInfo) {\n    let platform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.platform;\n    let arch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : process.arch;\n    let additionalArgs = arguments[4];\n    let buildFromSource = arguments[5];\n\n    (0, (_log || _load_log()).log)(`Installing app dependencies for arch ${arch} to ${appDir}`);\n    let execPath = process.env.npm_execpath || process.env.NPM_CLI_JS;\n    const execArgs = [\"install\", \"--production\"];\n    const isYarn = isYarnPath(execPath);\n    if (!isYarn) {\n        if (process.env.NPM_NO_BIN_LINKS === \"true\") {\n            execArgs.push(\"--no-bin-links\");\n        }\n        execArgs.push(\"--cache-min\", \"999999999\");\n    }\n    if (execPath == null) {\n        execPath = getPackageToolPath();\n    } else {\n        execArgs.unshift(execPath);\n        execPath = process.env.npm_node_execpath || process.env.NODE_EXE || \"node\";\n    }\n    execArgs.push.apply(execArgs, _toConsumableArray(additionalArgs));\n    return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(execPath, execArgs, {\n        cwd: appDir,\n        env: getGypEnv(frameworkInfo, platform, arch, buildFromSource)\n    });\n}\nfunction getPackageToolPath() {\n    if (process.env.FORCE_YARN === \"true\") {\n        return process.platform === \"win32\" ? \"yarn.cmd\" : \"yarn\";\n    } else {\n        return process.platform === \"win32\" ? \"npm.cmd\" : \"npm\";\n    }\n}\nfunction isYarnPath(execPath) {\n    return process.env.FORCE_YARN === \"true\" || execPath != null && _path.basename(execPath).startsWith(\"yarn\");\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/cli/cliOptions.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createYargs = createYargs;\n\nvar _chalk;\n\nfunction _load_chalk() {\n    return _chalk = require(\"chalk\");\n}\n\nvar _yargs;\n\nfunction _load_yargs() {\n    return _yargs = _interopRequireDefault(require(\"yargs\"));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst publishGroup = \"Publishing:\";\nconst buildGroup = \"Building:\";\nconst deprecated = \"Deprecated:\";\nfunction createYargs() {\n    //noinspection ReservedWordAsName\n    return (_yargs || _load_yargs()).default.example(\"build -mwl\", \"build for macOS, Windows and Linux\").example(\"build --linux deb tar.xz\", \"build deb and tar.xz for Linux\").example(\"build --win --ia32\", \"build for Windows ia32\").example(\"build --em.foo=bar\", \"set package.json property `foo` to `bar`\").example(\"build --config.nsis.unicode=false\", \"configure unicode options for NSIS\").option(\"mac\", {\n        group: buildGroup,\n        alias: [\"m\", \"o\", \"macos\"],\n        describe: `Build for macOS, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)(\"https://goo.gl/HAnnq8\")}).`,\n        type: \"array\"\n    }).option(\"linux\", {\n        group: buildGroup,\n        alias: \"l\",\n        describe: `Build for Linux, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)(\"https://goo.gl/O80IL2\")})`,\n        type: \"array\"\n    }).option(\"win\", {\n        group: buildGroup,\n        alias: [\"w\", \"windows\"],\n        describe: `Build for Windows, accepts target list (see ${(0, (_chalk || _load_chalk()).underline)(\"https://goo.gl/dL4i8i\")})`,\n        type: \"array\"\n    }).option(\"x64\", {\n        group: buildGroup,\n        describe: \"Build for x64\",\n        type: \"boolean\"\n    }).option(\"ia32\", {\n        group: buildGroup,\n        describe: \"Build for ia32\",\n        type: \"boolean\"\n    }).option(\"armv7l\", {\n        group: buildGroup,\n        describe: \"Build for armv7l\",\n        type: \"boolean\"\n    }).option(\"dir\", {\n        group: buildGroup,\n        describe: \"Build unpacked dir. Useful to test.\",\n        type: \"boolean\"\n    }).option(\"publish\", {\n        group: publishGroup,\n        alias: \"p\",\n        describe: `Publish artifacts (to GitHub Releases), see ${(0, (_chalk || _load_chalk()).underline)(\"https://goo.gl/WMlr4n\")}`,\n        choices: [\"onTag\", \"onTagOrDraft\", \"always\", \"never\"]\n    }).option(\"draft\", {\n        group: publishGroup,\n        describe: \"Create a draft (unpublished) release\",\n        type: \"boolean\",\n        default: undefined\n    }).option(\"prerelease\", {\n        group: publishGroup,\n        describe: \"Identify the release as a prerelease\",\n        type: \"boolean\",\n        default: undefined\n    }).option(\"platform\", {\n        group: deprecated,\n        describe: \"The target platform (preferred to use --mac, --win or --linux)\",\n        choices: [\"mac\", \"win\", \"linux\", \"darwin\", \"win32\", \"all\"]\n    }).option(\"arch\", {\n        group: deprecated,\n        describe: \"The target arch (preferred to use --x64 or --ia32)\",\n        choices: [\"ia32\", \"x64\", \"all\"]\n    }).option(\"extraMetadata\", {\n        alias: [\"em\"],\n        group: buildGroup,\n        describe: \"Inject properties to package.json (asar only)\"\n    }).option(\"prepackaged\", {\n        alias: [\"pd\"],\n        group: buildGroup,\n        describe: \"The path to prepackaged app (to pack in a distributable format)\"\n    }).option(\"projectDir\", {\n        alias: [\"project\"],\n        group: buildGroup,\n        describe: \"The path to project directory. Defaults to current working directory.\"\n    }).option(\"config\", {\n        alias: [\"c\"],\n        group: buildGroup,\n        describe: \"The path to an electron-builder config. Defaults to `electron-builder.yml` (or `json`, or `json5`), see \" + (0, (_chalk || _load_chalk()).underline)(\"https://goo.gl/YFRJOM\")\n    }).strict().group([\"help\", \"version\"], \"Other:\").help().version().epilog(`See the Wiki (${(0, (_chalk || _load_chalk()).underline)(\"https://github.com/electron-userland/electron-builder/wiki\")}) for more documentation.`);\n}\n//# sourceMappingURL=cliOptions.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/cli/create-self-signed-cert.js":"\"use strict\";\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet main = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n        const args = (_yargs || _load_yargs()).default.option(\"publisher\", {\n            alias: [\"p\"]\n        }).argv;\n        const tmpDir = new (_tmp || _load_tmp()).TmpDir();\n        const targetDir = process.cwd();\n        const tempPrefix = _path.join((yield tmpDir.getTempFile(\"\")), (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(args.publisher));\n        const cer = `${tempPrefix}.cer`;\n        const pvk = `${tempPrefix}.pvk`;\n        (0, (_log || _load_log()).log)('When asked to enter a password (\"Create Private Key Password\"), please select \"None\".');\n        const vendorPath = _path.join((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), \"windows-10\", process.arch);\n        yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(_path.join(vendorPath, \"makecert.exe\"), [\"-r\", \"-h\", \"0\", \"-n\", `CN=${args.publisher}`, \"-eku\", \"1.3.6.1.5.5.7.3.3\", \"-pe\", \"-sv\", pvk, cer]);\n        const pfx = _path.join(targetDir, `${(0, (_sanitizeFilename || _load_sanitizeFilename()).default)(args.publisher)}.pfx`);\n        yield (0, (_fs || _load_fs()).unlinkIfExists)(pfx);\n        yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(_path.join(vendorPath, \"pvk2pfx.exe\"), [\"-pvk\", pvk, \"-spc\", cer, \"-pfx\", pfx]);\n        (0, (_log || _load_log()).log)(`${pfx} created. Please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing how do use it to sign.`);\n        const certLocation = \"Cert:\\\\LocalMachine\\\\TrustedPeople\";\n        (0, (_log || _load_log()).log)(`${pfx} will be imported into ${certLocation} Operation will be succeed only if runned from root. Otherwise import file manually.`);\n        yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(\"powershell.exe\", [\"Import-PfxCertificate\", \"-FilePath\", `\"${pfx}\"`, \"-CertStoreLocation\", \"\"]);\n        yield tmpDir.cleanup();\n    });\n\n    return function main() {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _tmp;\n\nfunction _load_tmp() {\n    return _tmp = require(\"electron-builder-util/out/tmp\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _sanitizeFilename;\n\nfunction _load_sanitizeFilename() {\n    return _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\n}\n\nvar _yargs;\n\nfunction _load_yargs() {\n    return _yargs = _interopRequireDefault(require(\"yargs\"));\n}\n\nvar _windowsCodeSign;\n\nfunction _load_windowsCodeSign() {\n    return _windowsCodeSign = require(\"../windowsCodeSign\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nmain().catch((_promise || _load_promise()).printErrorAndExit);\n//# sourceMappingURL=create-self-signed-cert.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-util/out/tmp.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TmpDir = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"./log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"./promise\");\n}\n\nvar _util;\n\nfunction _load_util() {\n    return _util = require(\"./util\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nprocess.setMaxListeners(30);\nlet tempDirPromise;\nlet tempDir;\nfunction getTempDir() {\n    if (tempDirPromise == null) {\n        let promise;\n        const systemTmpDir = process.env.TEST_DIR || (0, (_os || _load_os()).tmpdir)();\n        if ((_fsExtraP || _load_fsExtraP()).mkdtemp == null) {\n            const dir = _path.join(systemTmpDir, (0, (_util || _load_util()).getTempName)(\"electron-builder\"));\n            promise = (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(dir, { mode: 448 }).then(() => dir);\n        } else {\n            promise = (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${_path.join(systemTmpDir, \"electron-builder\")}-`);\n        }\n        tempDirPromise = promise.then(dir => {\n            tempDir = dir;\n            const cleanup = () => {\n                if (tempDir == null) {\n                    return;\n                }\n                tempDir = null;\n                try {\n                    (0, (_fsExtraP || _load_fsExtraP()).removeSync)(dir);\n                } catch (e) {\n                    if (e.code !== \"EPERM\") {\n                        (0, (_log || _load_log()).warn)(`Cannot delete temporary dir \"${dir}\": ${(e.stack || e).toString()}`);\n                    }\n                }\n            };\n            process.on(\"exit\", cleanup);\n            process.on(\"uncaughtException\", cleanup);\n            process.on(\"SIGINT\", cleanup);\n            return dir;\n        });\n    }\n    return tempDirPromise;\n}\nlet tmpFileCounter = 0;\nclass TmpDir {\n    constructor() {\n        this.tempFiles = [];\n    }\n    getTempFile(suffix) {\n        if (this.tempPrefixPromise == null) {\n            this.tempPrefixPromise = getTempDir().then(it => _path.join(it, (tmpFileCounter++).toString(16)));\n        }\n        return this.tempPrefixPromise.then(it => {\n            const result = `${it}-${(tmpFileCounter++).toString(16)}${suffix.length === 0 || suffix.startsWith(\".\") ? suffix : `-${suffix}`}`;\n            this.tempFiles.push(result);\n            return result;\n        });\n    }\n    cleanup() {\n        const tempFiles = this.tempFiles;\n        if (tempFiles.length === 0) {\n            return (_bluebirdLst || _load_bluebirdLst()).default.resolve();\n        }\n        this.tempFiles = [];\n        this.tempPrefixPromise = null;\n        return (0, (_promise || _load_promise()).all)(tempFiles.map(it => (0, (_fsExtraP || _load_fsExtraP()).remove)(it).catch(e => {\n            if (e.code !== \"EPERM\") {\n                (0, (_log || _load_log()).warn)(`Cannot delete temporary dir \"${it}\": ${(e.stack || e).toString()}`);\n            }\n        })));\n    }\n}\nexports.TmpDir = TmpDir; //# sourceMappingURL=tmp.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-util/out/promise.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.NestedError = exports.executeFinally = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nlet executeFinally = exports.executeFinally = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (promise, task) {\n        let result = null;\n        try {\n            result = yield promise;\n        } catch (originalError) {\n            try {\n                yield task(true);\n            } catch (taskError) {\n                throw new NestedError([originalError, taskError]);\n            }\n            throw originalError;\n        }\n        try {\n            yield task(false);\n        } catch (taskError) {\n            throw taskError;\n        }\n        return result;\n    });\n\n    return function executeFinally(_x, _x2) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nexports.printErrorAndExit = printErrorAndExit;\nexports.all = all;\nexports.throwError = throwError;\nexports.asyncAll = asyncAll;\n\nvar _chalk;\n\nfunction _load_chalk() {\n    return _chalk = require(\"chalk\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction printErrorAndExit(error) {\n    console.error((0, (_chalk || _load_chalk()).red)((error.stack || error).toString()));\n    process.exit(-1);\n}class NestedError extends Error {\n    constructor(errors) {\n        let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Compound error: \";\n\n        let m = message;\n        let i = 1;\n        for (const error of errors) {\n            const prefix = \"Error #\" + i++ + \" \";\n            m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error.stack;\n        }\n        super(m);\n    }\n}\nexports.NestedError = NestedError;\nfunction all(promises) {\n    const errors = [];\n    return (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises.map(it => it.catch(it => errors.push(it)))).then(() => throwError(errors));\n}\nfunction throwError(errors) {\n    if (errors.length === 1) {\n        throw errors[0];\n    } else if (errors.length > 1) {\n        throw new NestedError(errors, \"Cannot cleanup: \");\n    }\n}\nfunction asyncAll(tasks) {\n    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map(tasks, it => it());\n}\n//# sourceMappingURL=promise.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/cli/install-app-deps.js":"#! /usr/bin/env node\n\"use strict\";\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet main = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n        const args = (_yargs || _load_yargs()).default.option(\"platform\", {\n            choices: [\"linux\", \"darwin\", \"win32\"],\n            default: process.platform\n        }).option(\"arch\", {\n            choices: [\"ia32\", \"x64\", \"all\"],\n            default: process.arch\n        }).argv;\n        const projectDir = process.cwd();\n        const config = (yield (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(projectDir)) || {};\n        const muonVersion = config.muonVersion;\n        const results = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_electronBuilderUtil || _load_electronBuilderUtil()).computeDefaultAppDirectory)(projectDir, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(config.directories, function (it) {\n            return it.app;\n        })), muonVersion == null ? (0, (_readPackageJson || _load_readPackageJson()).getElectronVersion)(config, projectDir) : (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(muonVersion)]);\n        // if two package.json — force full install (user wants to install/update app deps in addition to dev)\n        yield (0, (_yarn || _load_yarn()).installOrRebuild)(config, results[0], { version: results[1], useCustomDist: muonVersion == null }, args.platform, args.arch, results[0] !== projectDir);\n    });\n\n    return function main() {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _yargs;\n\nfunction _load_yargs() {\n    return _yargs = _interopRequireDefault(require(\"yargs\"));\n}\n\nvar _readPackageJson;\n\nfunction _load_readPackageJson() {\n    return _readPackageJson = require(\"../util/readPackageJson\");\n}\n\nvar _yarn;\n\nfunction _load_yarn() {\n    return _yarn = require(\"../yarn\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmain().catch((_promise || _load_promise()).printErrorAndExit);\n//# sourceMappingURL=install-app-deps.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/util/readPackageJson.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.validateConfig = exports.getElectronVersion = exports.loadConfig = exports.doLoadConfig = exports.readPackageJson = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet readPackageJson = exports.readPackageJson = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {\n        const data = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(file);\n        yield authors(file, data);\n        normalizeData(data);\n        return data;\n    });\n\n    return function readPackageJson(_x) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet authors = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file, data) {\n        if (data.contributors != null) {\n            return;\n        }\n        let authorData;\n        try {\n            authorData = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.resolve(_path.dirname(file), \"AUTHORS\"), \"utf8\");\n        } catch (ignored) {\n            return;\n        }\n        data.contributors = authorData.split(/\\r?\\n/g).map(function (it) {\n            return it.replace(/^\\s*#.*$/, \"\").trim();\n        });\n    });\n\n    return function authors(_x2, _x3) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet doLoadConfig = exports.doLoadConfig = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (configFile, projectDir) {\n        const result = (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(configFile, \"utf8\")));\n        const relativePath = _path.relative(projectDir, configFile);\n        (0, (_log || _load_log()).log)(`Using ${relativePath.startsWith(\"..\") ? configFile : relativePath} configuration file`);\n        return result;\n    });\n\n    return function doLoadConfig(_x4, _x5) {\n        return _ref3.apply(this, arguments);\n    };\n})();\n\nlet loadConfig = exports.loadConfig = (() => {\n    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir) {\n        for (const configFile of [\"electron-builder.yml\", \"electron-builder.json\", \"electron-builder.json5\"]) {\n            try {\n                return yield doLoadConfig(_path.join(projectDir, configFile), projectDir);\n            } catch (e) {\n                if (e.code !== \"ENOENT\") {\n                    throw e;\n                }\n            }\n        }\n        try {\n            return getConfigFromPackageData((yield readPackageJson(_path.join(projectDir, \"package.json\"))));\n        } catch (e) {\n            if (e.code !== \"ENOENT\") {\n                throw e;\n            }\n            try {\n                const data = yield (0, (_asar || _load_asar()).readAsarJson)(_path.join(projectDir, \"app.asar\"), \"package.json\");\n                if (data != null) {\n                    return getConfigFromPackageData(data);\n                }\n            } catch (e) {\n                if (e.code !== \"ENOENT\") {\n                    throw e;\n                }\n            }\n            throw new Error(`Cannot find package.json in the ${projectDir}`);\n        }\n    });\n\n    return function loadConfig(_x6) {\n        return _ref4.apply(this, arguments);\n    };\n})();\n\nlet getElectronVersion = exports.getElectronVersion = (() => {\n    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (config, projectDir, projectMetadata) {\n        // build is required, but this check is performed later, so, we should check for null\n        if (config != null && config.electronVersion != null) {\n            return config.electronVersion;\n        }\n        // projectMetadata passed only for prepacked app asar and in this case no dev deps in the app.asar\n        if (projectMetadata == null) {\n            for (const name of [\"electron\", \"electron-prebuilt\", \"electron-prebuilt-compile\"]) {\n                try {\n                    return (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(projectDir, \"node_modules\", name, \"package.json\"))).version;\n                } catch (e) {\n                    if (e.code !== \"ENOENT\") {\n                        (0, (_log || _load_log()).warn)(`Cannot read electron version from ${name} package.json: ${e.message}`);\n                    }\n                }\n            }\n        }\n        const packageJsonPath = _path.join(projectDir, \"package.json\");\n        const electronPrebuiltDep = findFromElectronPrebuilt(projectMetadata || (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(packageJsonPath)));\n        if (electronPrebuiltDep == null) {\n            throw new Error(`Cannot find electron dependency to get electron version in the '${packageJsonPath}'`);\n        }\n        const firstChar = electronPrebuiltDep[0];\n        return firstChar === \"^\" || firstChar === \"~\" ? electronPrebuiltDep.substring(1) : electronPrebuiltDep;\n    });\n\n    return function getElectronVersion(_x7, _x8, _x9) {\n        return _ref5.apply(this, arguments);\n    };\n})();\n\nlet createConfigValidator = (() => {\n    var _ref6 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n        const ajv = new (_ajv || _load_ajv()).default({ allErrors: true });\n        ajv.addMetaSchema(require(\"ajv/lib/refs/json-schema-draft-04.json\"));\n        require(\"ajv-keywords\")(ajv, [\"typeof\"]);\n        const schema = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(__dirname, \"..\", \"..\", \"scheme.json\"));\n        return ajv.compile(schema);\n    });\n\n    return function createConfigValidator() {\n        return _ref6.apply(this, arguments);\n    };\n})();\n\nlet validateConfig = exports.validateConfig = (() => {\n    var _ref7 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (config) {\n        if (validatorPromise == null) {\n            validatorPromise = createConfigValidator();\n        }\n        const validator = yield validatorPromise;\n        if (!validator(config)) {\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(JSON.stringify(validator.errors, null, 2));\n            throw new Error(\"Config is invalid:\\n\" + JSON.stringify(normaliseErrorMessages(validator.errors), null, 2));\n        }\n    });\n\n    return function validateConfig(_x10) {\n        return _ref7.apply(this, arguments);\n    };\n})();\n\nvar _ajv;\n\nfunction _load_ajv() {\n    return _ajv = _interopRequireDefault(require(\"ajv\"));\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _jsYaml;\n\nfunction _load_jsYaml() {\n    return _jsYaml = require(\"js-yaml\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _asar;\n\nfunction _load_asar() {\n    return _asar = require(\"../asar\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst normalizeData = require(\"normalize-package-data\");\n\nfunction getConfigFromPackageData(metadata) {\n    if (metadata.directories != null) {\n        throw new Error(`\"directories\" in the root is deprecated, please specify in the \"build\"`);\n    }\n    return metadata.build;\n}\n\nfunction findFromElectronPrebuilt(packageData) {\n    for (const name of [\"electron\", \"electron-prebuilt\", \"electron-prebuilt-compile\"]) {\n        const devDependencies = packageData.devDependencies;\n        let dep = devDependencies == null ? null : devDependencies[name];\n        if (dep == null) {\n            const dependencies = packageData.dependencies;\n            dep = dependencies == null ? null : dependencies[name];\n        }\n        if (dep != null) {\n            return dep;\n        }\n    }\n    return null;\n}\nlet validatorPromise = null;\n\nfunction normaliseErrorMessages(errors) {\n    const result = Object.create(null);\n    for (const e of errors) {\n        if (e.keyword === \"type\" && e.params.type === \"null\") {\n            // ignore - no sense to report that type accepts null\n            continue;\n        }\n        const dataPath = e.dataPath.length === 0 ? [] : e.dataPath.substring(1).split(\".\");\n        if (e.keyword === \"additionalProperties\") {\n            dataPath.push(e.params.additionalProperty);\n        }\n        let o = result;\n        let lastName = null;\n        for (const p of dataPath) {\n            if (p === dataPath[dataPath.length - 1]) {\n                lastName = p;\n                break;\n            } else {\n                if (o[p] == null) {\n                    o[p] = Object.create(null);\n                } else if (typeof o[p] === \"string\") {\n                    o[p] = [o[p]];\n                }\n                o = o[p];\n            }\n        }\n        if (lastName == null) {\n            lastName = \"unknown\";\n        }\n        let message = e.message.toUpperCase()[0] + e.message.substring(1);\n        switch (e.keyword) {\n            case \"additionalProperties\":\n                message = \"Unknown option\";\n                break;\n            case \"required\":\n                message = \"Required option\";\n                break;\n            case \"anyOf\":\n                message = \"Invalid option object\";\n                break;\n        }\n        if (o[lastName] != null && !Array.isArray(o[lastName])) {\n            o[lastName] = [o[lastName]];\n        }\n        if (Array.isArray(o[lastName])) {\n            o[lastName].push(message);\n        } else {\n            o[lastName] = message;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=readPackageJson.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/cli/node-gyp-rebuild.js":"#! /usr/bin/env node\n\"use strict\";\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nlet main = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n        const projectDir = process.cwd();\n        const config = yield (0, (_readPackageJson || _load_readPackageJson()).loadConfig)(projectDir);\n        (0, (_log || _load_log()).log)(`Execute node-gyp rebuild for ${args.platform}:${args.arch}`);\n        // this script must be used only for electron\n        yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(process.platform === \"win32\" ? \"node-gyp.cmd\" : \"node-gyp\", [\"rebuild\"], {\n            env: (0, (_yarn || _load_yarn()).getGypEnv)({ version: yield (0, (_readPackageJson || _load_readPackageJson()).getElectronVersion)(config, projectDir), useCustomDist: true }, args.platform, args.arch, true)\n        });\n    });\n\n    return function main() {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _yargs;\n\nfunction _load_yargs() {\n    return _yargs = _interopRequireDefault(require(\"yargs\"));\n}\n\nvar _readPackageJson;\n\nfunction _load_readPackageJson() {\n    return _readPackageJson = require(\"../util/readPackageJson\");\n}\n\nvar _yarn;\n\nfunction _load_yarn() {\n    return _yarn = require(\"../yarn\");\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst args = (_yargs || _load_yargs()).default.option(\"platform\", {\n    choices: [\"linux\", \"darwin\", \"win32\"],\n    default: process.platform\n}).option(\"arch\", {\n    choices: [\"ia32\", \"x64\", \"armv7l\"],\n    default: process.arch\n}).argv;\n\nmain().catch((_promise || _load_promise()).printErrorAndExit);\n//# sourceMappingURL=node-gyp-rebuild.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/options/linuxOptions.js":"//# sourceMappingURL=linuxOptions.js.map\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/options/macOptions.js":"//# sourceMappingURL=macOptions.js.map\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/options/winOptions.js":"//# sourceMappingURL=winOptions.js.map\n\"use strict\";","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/packager/dirPackager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet unpack = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, out, platform, options) {\n        const dist = packager.config.electronDist;\n        if (dist == null) {\n            const zipPath = (yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([downloadElectron(options), (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(out)]))[0];\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)((_zipBin || _load_zipBin()).path7za, (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug7zArgs)(\"x\").concat(zipPath, `-o${out}`));\n        } else {\n            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(out);\n            yield (0, (_fs || _load_fs()).copyDir)(_path.resolve(packager.info.projectDir, dist, \"Electron.app\"), _path.join(out, \"Electron.app\"));\n        }\n        if (platform === \"linux\") {\n            // https://github.com/electron-userland/electron-builder/issues/786\n            // fix dir permissions — opposite to extract-zip, 7za creates dir with no-access for other users, but dir must be readable for non-root users\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fsExtraP || _load_fsExtraP()).chmod)(_path.join(out, \"locales\"), \"0755\"), (0, (_fsExtraP || _load_fsExtraP()).chmod)(_path.join(out, \"resources\"), \"0755\")]);\n        }\n    });\n\n    return function unpack(_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=dirPackager.js.map\n\n\nexports.unpackElectron = unpackElectron;\nexports.unpackMuon = unpackMuon;\n\nvar _zipBin;\n\nfunction _load_zipBin() {\n    return _zipBin = require(\"7zip-bin\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst downloadElectron = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require(\"electron-download-tf\"));\nfunction createDownloadOpts(opts, platform, arch, electronVersion) {\n    if (opts.download != null) {\n        (0, (_log || _load_log()).warn)(`\"build.download is deprecated — please use build.electronDownload instead`);\n    }\n    const downloadOpts = Object.assign({\n        cache: opts.cache,\n        strictSSL: opts[\"strict-ssl\"]\n    }, opts.electronDownload || opts.download);\n    subOptionWarning(downloadOpts, \"download\", \"platform\", platform);\n    subOptionWarning(downloadOpts, \"download\", \"arch\", arch);\n    subOptionWarning(downloadOpts, \"download\", \"version\", electronVersion);\n    return downloadOpts;\n}\nfunction subOptionWarning(properties, optionName, parameter, value) {\n    if (properties.hasOwnProperty(parameter)) {\n        (0, (_log || _load_log()).warn)(`${optionName}.${parameter} will be inferred from the main options`);\n    }\n    properties[parameter] = value;\n}\nfunction unpackElectron(packager, out, platform, arch, version) {\n    return unpack(packager, out, platform, createDownloadOpts(packager.config, platform, arch, version));\n}\nfunction unpackMuon(packager, out, platform, arch, version) {\n    return unpack(packager, out, platform, Object.assign({\n        mirror: \"https://github.com/brave/muon/releases/download/v\",\n        customFilename: `brave-v${version}-${platform}-${arch}.zip`,\n        verifyChecksum: false\n    }, createDownloadOpts(packager.config, platform, arch, version)));\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/packager/mac.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createApp = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet createApp = exports.createApp = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, appOutDir) {\n        const appInfo = packager.appInfo;\n        const appFilename = appInfo.productFilename;\n        const contentsPath = _path.join(appOutDir, packager.electronDistMacOsAppName, \"Contents\");\n        const frameworksPath = _path.join(contentsPath, \"Frameworks\");\n        const appPlistFilename = _path.join(contentsPath, \"Info.plist\");\n        const helperPlistFilename = _path.join(frameworksPath, `${packager.electronDistMacOsExecutableName} Helper.app`, \"Contents\", \"Info.plist\");\n        const helperEHPlistFilename = _path.join(frameworksPath, `${packager.electronDistMacOsExecutableName} Helper EH.app`, \"Contents\", \"Info.plist\");\n        const helperNPPlistFilename = _path.join(frameworksPath, `${packager.electronDistMacOsExecutableName} Helper NP.app`, \"Contents\", \"Info.plist\");\n        const buildMetadata = packager.config;\n        const fileContents = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map([appPlistFilename, helperPlistFilename, helperEHPlistFilename, helperNPPlistFilename, buildMetadata[\"extend-info\"]], function (it) {\n            return it == null ? it : (0, (_fsExtraP || _load_fsExtraP()).readFile)(it, \"utf8\");\n        });\n        const appPlist = (0, (_plist || _load_plist()).parse)(fileContents[0]);\n        const helperPlist = (0, (_plist || _load_plist()).parse)(fileContents[1]);\n        const helperEHPlist = (0, (_plist || _load_plist()).parse)(fileContents[2]);\n        const helperNPPlist = (0, (_plist || _load_plist()).parse)(fileContents[3]);\n        // If an extend-info file was supplied, copy its contents in first\n        if (fileContents[4] != null) {\n            Object.assign(appPlist, (0, (_plist || _load_plist()).parse)(fileContents[4]));\n        }\n        const macOptions = buildMetadata.mac;\n        if (macOptions != null && macOptions.extendInfo != null) {\n            Object.assign(appPlist, macOptions.extendInfo);\n        }\n        const appBundleIdentifier = filterCFBundleIdentifier(appInfo.id);\n        const oldHelperBundleId = buildMetadata[\"helper-bundle-id\"];\n        if (oldHelperBundleId != null) {\n            (0, (_log || _load_log()).warn)(\"build.helper-bundle-id is deprecated, please set as build.mac.helperBundleId\");\n        }\n        const helperBundleIdentifier = filterCFBundleIdentifier(packager.platformSpecificBuildOptions.helperBundleId || oldHelperBundleId || `${appBundleIdentifier}.helper`);\n        const icon = yield packager.getIconPath();\n        const oldIcon = appPlist.CFBundleIconFile;\n        if (icon != null) {\n            appPlist.CFBundleIconFile = `${appFilename}.icns`;\n        }\n        appPlist.CFBundleDisplayName = appInfo.productName;\n        appPlist.CFBundleIdentifier = appBundleIdentifier;\n        appPlist.CFBundleName = appInfo.productName;\n        // https://github.com/electron-userland/electron-builder/issues/1278\n        appPlist.CFBundleExecutable = !appFilename.endsWith(\" Helper\") ? appFilename : appFilename.substring(0, appFilename.length - \" Helper\".length);\n        helperPlist.CFBundleExecutable = `${appFilename} Helper`;\n        helperEHPlist.CFBundleExecutable = `${appFilename} Helper EH`;\n        helperNPPlist.CFBundleExecutable = `${appFilename} Helper NP`;\n        helperPlist.CFBundleDisplayName = `${appInfo.productName} Helper`;\n        helperEHPlist.CFBundleDisplayName = `${appInfo.productName} Helper EH`;\n        helperNPPlist.CFBundleDisplayName = `${appInfo.productName} Helper NP`;\n        helperPlist.CFBundleIdentifier = helperBundleIdentifier;\n        helperEHPlist.CFBundleIdentifier = `${helperBundleIdentifier}.EH`;\n        helperNPPlist.CFBundleIdentifier = `${helperBundleIdentifier}.NP`;\n        appPlist.CFBundleShortVersionString = appInfo.version;\n        appPlist.CFBundleVersion = appInfo.buildVersion;\n        const protocols = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(buildMetadata.protocols).concat((0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(packager.platformSpecificBuildOptions.protocols));\n        if (protocols.length > 0) {\n            appPlist.CFBundleURLTypes = protocols.map(function (protocol) {\n                const schemes = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(protocol.schemes);\n                if (schemes.length === 0) {\n                    throw new Error(`Protocol \"${protocol.name}\": must be at least one scheme specified`);\n                }\n                return {\n                    CFBundleURLName: protocol.name,\n                    CFBundleTypeRole: protocol.role || \"Editor\",\n                    CFBundleURLSchemes: schemes.slice()\n                };\n            });\n        }\n        const resourcesPath = _path.join(contentsPath, \"Resources\");\n        const fileAssociations = packager.fileAssociations;\n        if (fileAssociations.length > 0) {\n            appPlist.CFBundleDocumentTypes = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(fileAssociations, (() => {\n                var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (fileAssociation) {\n                    const extensions = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(fileAssociation.ext).map((_platformPackager || _load_platformPackager()).normalizeExt);\n                    const customIcon = yield packager.getResource((0, (_electronBuilderUtil || _load_electronBuilderUtil()).getPlatformIconFileName)(fileAssociation.icon, true), `${extensions[0]}.icns`);\n                    let iconFile = appPlist.CFBundleIconFile;\n                    if (customIcon != null) {\n                        iconFile = _path.basename(customIcon);\n                        yield (0, (_fs || _load_fs()).copyFile)(customIcon, _path.join(resourcesPath, iconFile));\n                    }\n                    const result = {\n                        CFBundleTypeExtensions: extensions,\n                        CFBundleTypeName: fileAssociation.name || extensions[0],\n                        CFBundleTypeRole: fileAssociation.role || \"Editor\",\n                        CFBundleTypeIconFile: iconFile\n                    };\n                    if (fileAssociation.isPackage) {\n                        result.LSTypeIsPackage = true;\n                    }\n                    return result;\n                });\n\n                return function (_x3) {\n                    return _ref2.apply(this, arguments);\n                };\n            })());\n        }\n        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(packager.platformSpecificBuildOptions.category || buildMetadata.category, function (it) {\n            return appPlist.LSApplicationCategoryType = it;\n        });\n        appPlist.NSHumanReadableCopyright = appInfo.copyright;\n        const promises = [(0, (_fsExtraP || _load_fsExtraP()).writeFile)(appPlistFilename, (0, (_plist || _load_plist()).build)(appPlist)), (0, (_fsExtraP || _load_fsExtraP()).writeFile)(helperPlistFilename, (0, (_plist || _load_plist()).build)(helperPlist)), (0, (_fsExtraP || _load_fsExtraP()).writeFile)(helperEHPlistFilename, (0, (_plist || _load_plist()).build)(helperEHPlist)), (0, (_fsExtraP || _load_fsExtraP()).writeFile)(helperNPPlistFilename, (0, (_plist || _load_plist()).build)(helperNPPlist)), doRename(_path.join(contentsPath, \"MacOS\"), packager.electronDistMacOsExecutableName, appPlist.CFBundleExecutable), (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, \"LICENSE\")), (0, (_fs || _load_fs()).unlinkIfExists)(_path.join(appOutDir, \"LICENSES.chromium.html\"))];\n        if (icon != null) {\n            promises.push((0, (_fsExtraP || _load_fsExtraP()).unlink)(_path.join(resourcesPath, oldIcon)));\n            promises.push((0, (_fsExtraP || _load_fsExtraP()).copy)(icon, _path.join(resourcesPath, appPlist.CFBundleIconFile)));\n        }\n        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);\n        yield moveHelpers(frameworksPath, appFilename, packager.electronDistMacOsExecutableName);\n        const appPath = _path.join(appOutDir, `${appFilename}.app`);\n        yield (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.dirname(contentsPath), appPath);\n        // https://github.com/electron-userland/electron-builder/issues/840\n        const now = Date.now() / 1000;\n        yield (0, (_fsExtraP || _load_fsExtraP()).utimes)(appPath, now, now);\n    });\n\n    return function createApp(_x, _x2) {\n        return _ref.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=mac.js.map\n\n\nexports.filterCFBundleIdentifier = filterCFBundleIdentifier;\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _plist;\n\nfunction _load_plist() {\n    return _plist = require(\"plist\");\n}\n\nvar _platformPackager;\n\nfunction _load_platformPackager() {\n    return _platformPackager = require(\"../platformPackager\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction doRename(basePath, oldName, newName) {\n    return (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(basePath, oldName), _path.join(basePath, newName));\n}\nfunction moveHelpers(frameworksPath, appName, prefix) {\n    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map([\" Helper\", \" Helper EH\", \" Helper NP\"], suffix => {\n        const executableBasePath = _path.join(frameworksPath, `${prefix}${suffix}.app`, \"Contents\", \"MacOS\");\n        return doRename(executableBasePath, `${prefix}${suffix}`, appName + suffix).then(() => doRename(frameworksPath, `${prefix}${suffix}.app`, `${appName}${suffix}.app`));\n    });\n}\nfunction filterCFBundleIdentifier(identifier) {\n    // Remove special characters and allow only alphanumeric (A-Z,a-z,0-9), hyphen (-), and period (.)\n    // Apple documentation: https://developer.apple.com/library/mac/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-102070\n    return identifier.replace(/ /g, \"-\").replace(/[^a-zA-Z0-9.-]/g, \"\");\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/publish/PublishManager.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getPublishConfigs = exports.getPublishConfigsForUpdateInfo = exports.PublishManager = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet getPublishConfigsForUpdateInfo = exports.getPublishConfigsForUpdateInfo = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, publishConfigs, arch) {\n        if (publishConfigs === null) {\n            return null;\n        }\n        if (publishConfigs.length === 0) {\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(\"No publishConfigs, detect using repository info\");\n            // https://github.com/electron-userland/electron-builder/issues/925#issuecomment-261732378\n            // default publish config is github, file should be generated regardless of publish state (user can test installer locally or manage the release process manually)\n            const repositoryInfo = yield packager.info.repositoryInfo;\n            if (repositoryInfo != null && repositoryInfo.type === \"github\") {\n                const resolvedPublishConfig = yield getResolvedPublishConfig(packager, { provider: repositoryInfo.type }, arch, false);\n                if (resolvedPublishConfig != null) {\n                    return [resolvedPublishConfig];\n                }\n            }\n        }\n        return publishConfigs;\n    });\n\n    return function getPublishConfigsForUpdateInfo(_x2, _x3, _x4) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet writeUpdateInfo = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event, _publishConfigs) {\n        const packager = event.packager;\n        const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, _publishConfigs, event.arch);\n        if (publishConfigs == null || publishConfigs.length === 0) {\n            return;\n        }\n        const target = event.target;\n        let outDir = target.outDir;\n        if (target.name.startsWith(\"nsis-\")) {\n            outDir = _path.join(outDir, target.name);\n            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(outDir);\n        }\n        for (const publishConfig of publishConfigs) {\n            const isGitHub = publishConfig.provider === \"github\";\n            if (!(publishConfig.provider === \"generic\" || publishConfig.provider === \"s3\" || isGitHub)) {\n                continue;\n            }\n            const version = packager.appInfo.version;\n            const channel = publishConfig.channel || \"latest\";\n            if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {\n                const updateInfoFile = isGitHub ? _path.join(outDir, \"github\", `${channel}-mac.json`) : _path.join(outDir, `${channel}-mac.json`);\n                yield (0, (_fsExtraP || _load_fsExtraP()).outputJson)(updateInfoFile, {\n                    version: version,\n                    releaseDate: new Date().toISOString(),\n                    url: computeDownloadUrl(publishConfig, packager.generateName2(\"zip\", \"mac\", isGitHub), packager)\n                }, { spaces: 2 });\n                packager.info.dispatchArtifactCreated({\n                    file: updateInfoFile,\n                    arch: null,\n                    packager: packager,\n                    target: null,\n                    publishConfig: publishConfig\n                });\n            } else {\n                yield writeWindowsUpdateInfo(event, version, outDir, channel, publishConfigs);\n                break;\n            }\n        }\n    });\n\n    return function writeUpdateInfo(_x5, _x6) {\n        return _ref3.apply(this, arguments);\n    };\n})();\n\nlet writeWindowsUpdateInfo = (() => {\n    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event, version, outDir, channel, publishConfigs) {\n        const packager = event.packager;\n        const sha2 = yield sha256(event.file);\n        const updateInfoFile = _path.join(outDir, `${channel}.yml`);\n        yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(updateInfoFile, (0, (_jsYaml || _load_jsYaml()).safeDump)({\n            version: version,\n            releaseDate: new Date().toISOString(),\n            githubArtifactName: event.safeArtifactName,\n            path: _path.basename(event.file),\n            sha2: sha2\n        }));\n        const githubPublishConfig = publishConfigs.find(function (it) {\n            return it.provider === \"github\";\n        });\n        if (githubPublishConfig != null) {\n            // to preserve compatibility with old electron-updater (< 0.10.0), we upload file with path specific for GitHub\n            packager.info.dispatchArtifactCreated({\n                data: new Buffer((0, (_jsYaml || _load_jsYaml()).safeDump)({\n                    version: version,\n                    path: event.safeArtifactName,\n                    sha2: sha2\n                })),\n                safeArtifactName: `${channel}.yml`,\n                packager: packager,\n                target: null,\n                publishConfig: githubPublishConfig,\n                arch: null\n            });\n        }\n        const genericPublishConfig = publishConfigs.find(function (it) {\n            return it.provider === \"generic\" || it.provider === \"s3\";\n        });\n        if (genericPublishConfig != null) {\n            packager.info.dispatchArtifactCreated({\n                file: updateInfoFile,\n                arch: null,\n                packager: packager,\n                target: null,\n                publishConfig: genericPublishConfig\n            });\n        }\n    });\n\n    return function writeWindowsUpdateInfo(_x7, _x8, _x9, _x10, _x11) {\n        return _ref4.apply(this, arguments);\n    };\n})();\n\nlet getPublishConfigs = exports.getPublishConfigs = (() => {\n    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, targetSpecificOptions, arch) {\n        let publishers;\n        // check build.nsis (target)\n        if (targetSpecificOptions != null) {\n            publishers = targetSpecificOptions.publish;\n            // if explicitly set to null - do not publish\n            if (publishers === null) {\n                return null;\n            }\n        }\n        // check build.win (platform)\n        if (publishers == null) {\n            publishers = packager.platformSpecificBuildOptions.publish;\n            if (publishers === null) {\n                return null;\n            }\n        }\n        if (publishers == null) {\n            publishers = packager.config.publish;\n            if (publishers === null) {\n                return null;\n            }\n        }\n        if (publishers == null) {\n            let serviceName = null;\n            if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.GH_TOKEN)) {\n                serviceName = \"github\";\n            } else if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.BT_TOKEN)) {\n                serviceName = \"bintray\";\n            }\n            if (serviceName != null) {\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`Detect ${serviceName} as publish provider`);\n                return [yield getResolvedPublishConfig(packager, { provider: serviceName }, arch)];\n            }\n        }\n        if (publishers == null) {\n            return [];\n        }\n        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`Explicit publish provider: ${(0, (_electronBuilderUtil || _load_electronBuilderUtil()).safeStringifyJson)(publishers)}`);\n        return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map((0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(publishers), function (it) {\n            return getResolvedPublishConfig(packager, typeof it === \"string\" ? { provider: it } : it, arch);\n        });\n    });\n\n    return function getPublishConfigs(_x12, _x13, _x14) {\n        return _ref5.apply(this, arguments);\n    };\n})();\n\nlet getResolvedPublishConfig = (() => {\n    var _ref6 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, options, arch) {\n        let getInfo = (() => {\n            var _ref7 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n                const info = yield packager.info.repositoryInfo;\n                if (info != null) {\n                    return info;\n                }\n                const message = `Cannot detect repository by .git/config. Please specify \"repository\" in the package.json (https://docs.npmjs.com/files/package.json#repository).\\nPlease see https://github.com/electron-userland/electron-builder/wiki/Publishing-Artifacts`;\n                if (errorIfCannot) {\n                    throw new Error(message);\n                } else {\n                    (0, (_log || _load_log()).warn)(message);\n                    return null;\n                }\n            });\n\n            return function getInfo() {\n                return _ref7.apply(this, arguments);\n            };\n        })();\n\n        let errorIfCannot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n        options = Object.assign(Object.create(null), options);\n        expandPublishConfig(options, packager, arch);\n        let channelFromAppVersion = null;\n        if (options.channel == null && packager.config.detectUpdateChannel !== false) {\n            const prereleaseInfo = (0, (_semver || _load_semver()).prerelease)(packager.appInfo.version);\n            if (prereleaseInfo != null && prereleaseInfo.length > 0) {\n                channelFromAppVersion = prereleaseInfo[0];\n            }\n        }\n        const provider = options.provider;\n        if (provider === \"generic\") {\n            const o = options;\n            if (o.url == null) {\n                throw new Error(`Please specify \"url\" for \"generic\" update server`);\n            }\n            if (channelFromAppVersion != null) {\n                o.channel = channelFromAppVersion;\n            }\n            return options;\n        }\n        const providerClass = requireProviderClass(options.provider);\n        if (providerClass != null && providerClass.checkAndResolveOptions != null) {\n            yield providerClass.checkAndResolveOptions(options, channelFromAppVersion);\n            return options;\n        }\n        const isGithub = provider === \"github\";\n        if (!isGithub && provider !== \"bintray\") {\n            return options;\n        }\n        let owner = options.owner;\n        let project = isGithub ? options.repo : options.package;\n        if (isGithub && owner == null && project != null) {\n            const index = project.indexOf(\"/\");\n            if (index > 0) {\n                const repo = project;\n                project = repo.substring(0, index);\n                owner = repo.substring(index + 1);\n            }\n        }\n\n        if (!owner || !project) {\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`No owner or project for ${provider}, call getInfo: owner: ${owner}, project: ${project}`);\n            const info = yield getInfo();\n            if (info == null) {\n                return null;\n            }\n            if (!owner) {\n                owner = info.user;\n            }\n            if (!project) {\n                project = info.project;\n            }\n        }\n        if (isGithub) {\n            if (options.token != null && !options.private) {\n                (0, (_log || _load_log()).warn)('\"token\" specified in the github publish options. It should be used only for [setFeedURL](module:electron-updater/out/AppUpdater.AppUpdater+setFeedURL).');\n            }\n            return Object.assign({ owner, repo: project }, options);\n        } else {\n            return Object.assign({ owner, package: project }, options);\n        }\n    });\n\n    return function getResolvedPublishConfig(_x15, _x16, _x17) {\n        return _ref6.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=PublishManager.js.map\n\n\nexports.createPublisher = createPublisher;\nexports.computeDownloadUrl = computeDownloadUrl;\n\nvar _crypto;\n\nfunction _load_crypto() {\n    return _crypto = require(\"crypto\");\n}\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _publishOptions;\n\nfunction _load_publishOptions() {\n    return _publishOptions = require(\"electron-builder-http/out/publishOptions\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _BintrayPublisher;\n\nfunction _load_BintrayPublisher() {\n    return _BintrayPublisher = require(\"electron-publish/out/BintrayPublisher\");\n}\n\nvar _gitHubPublisher;\n\nfunction _load_gitHubPublisher() {\n    return _gitHubPublisher = require(\"electron-publish/out/gitHubPublisher\");\n}\n\nvar _multiProgress;\n\nfunction _load_multiProgress() {\n    return _multiProgress = require(\"electron-publish/out/multiProgress\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n    return _isCi = _interopRequireDefault(require(\"is-ci\"));\n}\n\nvar _jsYaml;\n\nfunction _load_jsYaml() {\n    return _jsYaml = require(\"js-yaml\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _semver;\n\nfunction _load_semver() {\n    return _semver = require(\"semver\");\n}\n\nvar _url;\n\nfunction _load_url() {\n    return _url = _interopRequireWildcard(require(\"url\"));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass PublishManager {\n    constructor(packager, publishOptions, cancellationToken) {\n        this.publishOptions = publishOptions;\n        this.cancellationToken = cancellationToken;\n        this.nameToPublisher = new Map();\n        this.publishTasks = [];\n        this.errors = [];\n        this.isPublish = false;\n        this.progress = process.stdout.isTTY ? new (_multiProgress || _load_multiProgress()).MultiProgress() : null;\n        if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isPullRequest)()) {\n            if (publishOptions.publish === undefined) {\n                if (process.env.npm_lifecycle_event === \"release\") {\n                    publishOptions.publish = \"always\";\n                } else {\n                    const tag = getCiTag();\n                    if (tag != null) {\n                        (0, (_log || _load_log()).log)(`Tag ${tag} is defined, so artifacts will be published`);\n                        publishOptions.publish = \"onTag\";\n                    } else if ((_isCi || _load_isCi()).default) {\n                        (0, (_log || _load_log()).log)(\"CI detected, so artifacts will be published if draft release exists\");\n                        publishOptions.publish = \"onTagOrDraft\";\n                    }\n                }\n            }\n            if (publishOptions.publish != null && publishOptions.publish !== \"never\") {\n                this.isPublish = publishOptions.publish !== \"onTag\" || getCiTag() != null;\n            }\n        } else if (publishOptions.publish !== \"never\") {\n            (0, (_log || _load_log()).log)(\"Current build is a part of pull request, publishing will be skipped\");\n        }\n        packager.addAfterPackHandler((() => {\n            var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event) {\n                const packager = event.packager;\n                if (event.electronPlatformName === \"darwin\") {\n                    if (!event.targets.some(function (it) {\n                        return it.name === \"zip\";\n                    })) {\n                        return;\n                    }\n                } else if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {\n                    if (!event.targets.some(function (it) {\n                        return isSuitableWindowsTarget(it);\n                    })) {\n                        return;\n                    }\n                } else {\n                    return;\n                }\n                const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, (yield getPublishConfigs(packager, null, event.arch)), event.arch);\n                if (publishConfigs == null || publishConfigs.length === 0) {\n                    return;\n                }\n                let publishConfig = publishConfigs[0];\n                if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS) {\n                    const publisherName = yield packager.computedPublisherName.value;\n                    if (publisherName != null) {\n                        publishConfig = Object.assign({ publisherName: publisherName }, publishConfig);\n                    }\n                }\n                yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(packager.getResourcesDir(event.appOutDir), \"app-update.yml\"), (0, (_jsYaml || _load_jsYaml()).safeDump)(publishConfig));\n            });\n\n            return function (_x) {\n                return _ref.apply(this, arguments);\n            };\n        })());\n        packager.artifactCreated(event => this.addTask(this.artifactCreated(event)));\n    }\n    artifactCreated(event) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = event.packager;\n            const target = event.target;\n            const publishConfigs = event.publishConfig == null ? yield getPublishConfigs(packager, target == null ? null : target.options, event.arch) : [event.publishConfig];\n            const eventFile = event.file;\n            if (publishConfigs == null) {\n                if (_this.isPublish) {\n                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`${eventFile} is not published: no publish configs`);\n                }\n                return;\n            }\n            if (_this.isPublish) {\n                for (const publishConfig of publishConfigs) {\n                    if (_this.cancellationToken.cancelled) {\n                        break;\n                    }\n                    const publisher = _this.getOrCreatePublisher(publishConfig, packager.info);\n                    if (publisher != null) {\n                        if (eventFile == null) {\n                            _this.addTask(publisher.uploadData(event.data, event.safeArtifactName));\n                        } else {\n                            _this.addTask(publisher.upload(eventFile, event.safeArtifactName));\n                        }\n                    }\n                }\n            }\n            if (target != null && eventFile != null && !_this.cancellationToken.cancelled) {\n                if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC && target.name === \"zip\" || packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS && isSuitableWindowsTarget(target) && eventFile.endsWith(\".exe\")) {\n                    _this.addTask(writeUpdateInfo(event, publishConfigs));\n                }\n            }\n        })();\n    }\n    addTask(promise) {\n        if (this.cancellationToken.cancelled) {\n            return;\n        }\n        this.publishTasks.push(promise.catch(it => this.errors.push(it)));\n    }\n    getOrCreatePublisher(publishConfig, buildInfo) {\n        let publisher = this.nameToPublisher.get(publishConfig.provider);\n        if (publisher == null) {\n            publisher = createPublisher(this, buildInfo.metadata.version, publishConfig, this.publishOptions);\n            this.nameToPublisher.set(publishConfig.provider, publisher);\n            (0, (_log || _load_log()).log)(`Publishing to ${publisher}`);\n        }\n        return publisher;\n    }\n    cancelTasks() {\n        for (const task of this.publishTasks) {\n            if (\"cancel\" in task) {\n                task.cancel();\n            }\n        }\n        this.publishTasks.length = 0;\n        this.nameToPublisher.clear();\n    }\n    awaitTasks() {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            if (_this2.errors.length > 0) {\n                _this2.cancelTasks();\n                (0, (_promise || _load_promise()).throwError)(_this2.errors);\n                return;\n            }\n            const publishTasks = _this2.publishTasks;\n            let list = publishTasks.slice();\n            publishTasks.length = 0;\n            while (list.length > 0) {\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(list);\n                if (publishTasks.length === 0) {\n                    break;\n                } else {\n                    list = publishTasks.slice();\n                    publishTasks.length = 0;\n                }\n            }\n        })();\n    }\n}\nexports.PublishManager = PublishManager;\nfunction createPublisher(context, version, publishConfig, options) {\n    const provider = publishConfig.provider;\n    switch (provider) {\n        case \"github\":\n            return new (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher(context, publishConfig, version, options);\n        case \"bintray\":\n            return new (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher(context, publishConfig, version, options);\n        case \"generic\":\n            return null;\n        default:\n            const clazz = requireProviderClass(provider);\n            return clazz == null ? null : new clazz(context, publishConfig);\n    }\n}\nfunction requireProviderClass(provider) {\n    switch (provider) {\n        case \"github\":\n            return (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher;\n        case \"bintray\":\n            return (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher;\n        case \"generic\":\n            return null;\n        default:\n            return require(`electron-publisher-${provider}`).default;\n    }\n}\nfunction computeDownloadUrl(publishConfig, fileName, packager) {\n    if (publishConfig.provider === \"generic\") {\n        const baseUrlString = publishConfig.url;\n        if (fileName == null) {\n            return baseUrlString;\n        }\n        const baseUrl = (_url || _load_url()).parse(baseUrlString);\n        return (_url || _load_url()).format(Object.assign({}, baseUrl, { pathname: _path.posix.resolve(baseUrl.pathname || \"/\", encodeURI(fileName)) }));\n    }\n    let baseUrl;\n    if (publishConfig.provider === \"s3\") {\n        baseUrl = (0, (_publishOptions || _load_publishOptions()).s3Url)(publishConfig);\n    } else {\n        const gh = publishConfig;\n        baseUrl = `${(0, (_publishOptions || _load_publishOptions()).githubUrl)(gh)}/${gh.owner}/${gh.repo}/releases/download/${gh.vPrefixedTagName === false ? \"\" : \"v\"}${packager.appInfo.version}`;\n    }\n    if (fileName == null) {\n        return baseUrl;\n    }\n    return `${baseUrl}/${encodeURI(fileName)}`;\n}\n\nfunction sha256(file) {\n    return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {\n        const hash = (0, (_crypto || _load_crypto()).createHash)(\"sha256\");\n        hash.on(\"error\", reject).setEncoding(\"hex\");\n        (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(file).on(\"error\", reject).on(\"end\", () => {\n            hash.end();\n            resolve(hash.read());\n        }).pipe(hash, { end: false });\n    });\n}\nfunction isSuitableWindowsTarget(target) {\n    return target.name === \"nsis\" || target.name.startsWith(\"nsis-\");\n}\nfunction getCiTag() {\n    const tag = process.env.TRAVIS_TAG || process.env.APPVEYOR_REPO_TAG_NAME || process.env.CIRCLE_TAG || process.env.CI_BUILD_TAG;\n    return tag != null && tag.length > 0 ? tag : null;\n}\nfunction expandPublishConfig(options, packager, arch) {\n    for (const name of Object.keys(options)) {\n        const value = options[name];\n        if (typeof value === \"string\") {\n            const expanded = packager.expandMacro(value, arch);\n            if (expanded !== value) {\n                options[name] = expanded;\n            }\n        }\n    }\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/appImage.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _binDownload;\n\nfunction _load_binDownload() {\n    return _binDownload = require(\"electron-builder-util/out/binDownload\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _uuid;\n\nfunction _load_uuid() {\n    return _uuid = require(\"uuid-1345\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst appImageVersion = process.platform === \"darwin\" ? \"AppImage-09-07-16-mac\" : \"AppImage-09-07-16-linux\";\n//noinspection SpellCheckingInspection\nconst appImageSha256 = process.platform === \"darwin\" ? \"5d4a954876654403698a01ef5bd7f218f18826261332e7d31d93ab4432fa0312\" : \"ac324e90b502f4e995f6a169451dbfc911bb55c0077e897d746838e720ae0221\";\n//noinspection SpellCheckingInspection\nconst appImagePathPromise = (0, (_binDownload || _load_binDownload()).getBin)(\"AppImage\", appImageVersion, `https://dl.bintray.com/electron-userland/bin/${appImageVersion}.7z`, appImageSha256);\nclass AppImageTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(ignored, packager, helper, outDir) {\n        super(\"appImage\");\n        this.packager = packager;\n        this.helper = helper;\n        this.outDir = outDir;\n        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);\n        // we add X-AppImage-BuildId to ensure that new desktop file will be installed\n        this.desktopEntry = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify((_uuid || _load_uuid()).v1)({ mac: false }).then(uuid => helper.computeDesktopEntry(this.options, \"AppRun\", null, {\n            \"X-AppImage-Version\": `${packager.appInfo.buildVersion}`,\n            \"X-AppImage-BuildId\": uuid\n        }));\n    }\n    build(appOutDir, arch) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            (0, (_log || _load_log()).log)(`Building AppImage for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]}`);\n            const packager = _this.packager;\n            // avoid spaces in the file name\n            const resultFile = _path.join(_this.outDir, packager.generateName(\"AppImage\", arch, true));\n            yield (0, (_fs || _load_fs()).unlinkIfExists)(resultFile);\n            const appImagePath = yield appImagePathPromise;\n            const desktopFile = yield _this.desktopEntry;\n            const args = [\"-joliet\", \"on\", \"-volid\", \"AppImage\", \"-dev\", resultFile, \"-padding\", \"0\", \"-map\", appOutDir, \"/usr/bin\", \"-map\", _path.join(__dirname, \"..\", \"..\", \"templates\", \"linux\", \"AppRun.sh\"), \"/AppRun\",\n            // we get executable name in the AppRun by desktop file name, so, must be named as executable\n            \"-map\", desktopFile, `/${_this.packager.executableName}.desktop`];\n            for (const _ref of yield _this.helper.icons) {\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                const from = _ref2[0];\n                const to = _ref2[1];\n\n                args.push(\"-map\", from, `/usr/share/icons/default/${to}`);\n            }\n            // must be after this.helper.icons call\n            if (_this.helper.maxIconPath == null) {\n                throw new Error(\"Icon is not provided\");\n            }\n            args.push(\"-map\", _this.helper.maxIconPath, \"/.DirIcon\");\n            if (arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64) {\n                const libDir = yield (0, (_binDownload || _load_binDownload()).getBin)(\"AppImage-packages\", \"10.03.17\", \"https://bintray.com/electron-userland/bin/download_file?file_path=AppImage-packages-10.03.17-x64.7z\", \"172f9977fe9b24d35091d26ecbfebe2a14d96516a9c903e109e12b2a929042fe\");\n                args.push(\"-map\", libDir, \"/usr/lib\");\n            }\n            args.push(\"-chown_r\", \"0\", \"/\", \"--\");\n            args.push(\"-zisofs\", `level=${process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL || (packager.config.compression === \"store\" ? \"0\" : \"9\")}:block_size=128k:by_magic=off`);\n            args.push(\"set_filter_r\", \"--zisofs\", \"/\");\n            if (_this.packager.packagerOptions.effectiveOptionComputed != null && (yield _this.packager.packagerOptions.effectiveOptionComputed([args, desktopFile]))) {\n                return;\n            }\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(process.arch !== \"x64\" || process.env.USE_SYSTEM_XORRISO === \"true\" || process.env.USE_SYSTEM_XORRISO === \"\" ? \"xorriso\" : _path.join(appImagePath, \"xorriso\"), args, {\n                maxBuffer: 2 * 1024 * 1024\n            });\n            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {\n                const rd = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(_path.join(appImagePath, arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 ? \"32\" : \"64\", \"runtime\"));\n                rd.on(\"error\", reject);\n                const wr = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(resultFile, { flags: \"r+\" });\n                wr.on(\"error\", reject);\n                wr.on(\"close\", resolve);\n                rd.pipe(wr);\n            });\n            const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(resultFile, \"r+\");\n            try {\n                const magicData = new Buffer([0x41, 0x49, 0x01]);\n                yield (0, (_fsExtraP || _load_fsExtraP()).write)(fd, magicData, 0, magicData.length, 8);\n            } finally {\n                yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);\n            }\n            yield (0, (_fsExtraP || _load_fsExtraP()).chmod)(resultFile, \"0755\");\n            packager.dispatchArtifactCreated(resultFile, _this, arch);\n        })();\n    }\n}\nexports.default = AppImageTarget; //# sourceMappingURL=appImage.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-util/out/binDownload.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\n// we cache in the global location - in the home dir, not in the node_modules/.cache (https://www.npmjs.com/package/find-cache-dir) because\n// * don't need to find node_modules\n// * don't pollute user project dir (important in case of 1-package.json project structure)\n// * simplify/speed-up tests (don't download fpm for each test project)\nlet doGetBin = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (name, dirName, url, sha2) {\n        const cachePath = _path.join((0, (_util || _load_util()).getCacheDirectory)(), name);\n        const dirPath = _path.join(cachePath, dirName);\n        const dirStat = yield (0, (_fs || _load_fs()).statOrNull)(dirPath);\n        //noinspection ES6MissingAwait\n        if (dirStat != null && dirStat.isDirectory()) {\n            (0, (_util || _load_util()).debug)(`Found existing ${name} ${dirPath}`);\n            return dirPath;\n        }\n        // 7z cannot be extracted from the input stream, temp file is required\n        const tempUnpackDir = _path.join(cachePath, (0, (_util || _load_util()).getTempName)());\n        const archiveName = `${tempUnpackDir}.7z`;\n        (0, (_util || _load_util()).debug)(`Download ${name} from ${url} to ${archiveName}`);\n        // 7z doesn't create out dir, so, we don't create dir in parallel to download - dir creation will create parent dirs for archive file also\n        yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(tempUnpackDir);\n        yield (_nodeHttpExecutor || _load_nodeHttpExecutor()).httpExecutor.download(url, archiveName, {\n            skipDirCreation: true,\n            sha2: sha2,\n            cancellationToken: new (_CancellationToken || _load_CancellationToken()).CancellationToken()\n        });\n        yield (0, (_util || _load_util()).spawn)((_zipBin || _load_zipBin()).path7za, (0, (_util || _load_util()).debug7zArgs)(\"x\").concat(archiveName, `-o${tempUnpackDir}`), {\n            cwd: cachePath\n        });\n        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fsExtraP || _load_fsExtraP()).rename)(tempUnpackDir, dirPath).catch(function (e) {\n            console.warn(`Cannot move downloaded ${name} into final location (another process downloaded faster?): ${e}`);\n        }), (0, (_fsExtraP || _load_fsExtraP()).unlink)(archiveName)]);\n        (0, (_util || _load_util()).debug)(`${name}} downloaded to ${dirPath}`);\n        return dirPath;\n    });\n\n    return function doGetBin(_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=binDownload.js.map\n\n\nexports.getBinFromBintray = getBinFromBintray;\nexports.getBin = getBin;\n\nvar _zipBin;\n\nfunction _load_zipBin() {\n    return _zipBin = require(\"7zip-bin\");\n}\n\nvar _CancellationToken;\n\nfunction _load_CancellationToken() {\n    return _CancellationToken = require(\"electron-builder-http/out/CancellationToken\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"./fs\");\n}\n\nvar _nodeHttpExecutor;\n\nfunction _load_nodeHttpExecutor() {\n    return _nodeHttpExecutor = require(\"./nodeHttpExecutor\");\n}\n\nvar _util;\n\nfunction _load_util() {\n    return _util = require(\"./util\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst versionToPromise = new Map();\nfunction getBinFromBintray(name, version, sha2) {\n    const dirName = `${name}-${version}`;\n    return getBin(name, dirName, `https://dl.bintray.com/electron-userland/bin/${dirName}.7z`, sha2);\n}\nfunction getBin(name, dirName, url, sha2) {\n    let promise = versionToPromise.get(dirName);\n    // if rejected, we will try to download again\n    if (promise != null && !promise.isRejected()) {\n        return promise;\n    }\n    promise = doGetBin(name, dirName, url, sha2);\n    versionToPromise.set(dirName, promise);\n    return promise;\n}","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-util/out/util.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Lazy = exports.tmpDirCounter = exports.computeDefaultAppDirectory = exports.debug7z = exports.debug = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet computeDefaultAppDirectory = exports.computeDefaultAppDirectory = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, userAppDir) {\n        if (userAppDir != null) {\n            const absolutePath = _path.resolve(projectDir, userAppDir);\n            const stat = yield (0, (_fs || _load_fs()).statOrNull)(absolutePath);\n            if (stat == null) {\n                throw new Error(`Application directory ${userAppDir} doesn't exists`);\n            } else if (!stat.isDirectory()) {\n                throw new Error(`Application directory ${userAppDir} is not a directory`);\n            } else if (projectDir === absolutePath) {\n                (0, (_log || _load_log()).warn)(`Specified application directory \"${userAppDir}\" equals to project dir — superfluous or wrong configuration`);\n            }\n            return absolutePath;\n        }\n        for (const dir of DEFAULT_APP_DIR_NAMES) {\n            const absolutePath = _path.join(projectDir, dir);\n            const packageJson = _path.join(absolutePath, \"package.json\");\n            const stat = yield (0, (_fs || _load_fs()).statOrNull)(packageJson);\n            if (stat != null && stat.isFile()) {\n                return absolutePath;\n            }\n        }\n        return projectDir;\n    });\n\n    return function computeDefaultAppDirectory(_x, _x2) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nexports.removePassword = removePassword;\nexports.execWine = execWine;\nexports.prepareArgs = prepareArgs;\nexports.exec = exec;\nexports.doSpawn = doSpawn;\nexports.spawn = spawn;\nexports.handleProcess = handleProcess;\nexports.use = use;\nexports.debug7zArgs = debug7zArgs;\nexports.getTempName = getTempName;\nexports.isEmptyOrSpaces = isEmptyOrSpaces;\nexports.asArray = asArray;\nexports.getCacheDirectory = getCacheDirectory;\nexports.smarten = smarten;\nexports.addValue = addValue;\nexports.replaceDefault = replaceDefault;\nexports.getPlatformIconFileName = getPlatformIconFileName;\nexports.isPullRequest = isPullRequest;\nexports.safeStringifyJson = safeStringifyJson;\n\nvar _chalk;\n\nfunction _load_chalk() {\n    return _chalk = require(\"chalk\");\n}\n\nvar _child_process;\n\nfunction _load_child_process() {\n    return _child_process = require(\"child_process\");\n}\n\nvar _crypto;\n\nfunction _load_crypto() {\n    return _crypto = require(\"crypto\");\n}\n\nvar _debug2;\n\nfunction _load_debug() {\n    return _debug2 = _interopRequireDefault(require(\"debug\"));\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nrequire(\"source-map-support/register\");\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"./fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"./log\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nconst debug = exports.debug = (0, (_debug2 || _load_debug()).default)(\"electron-builder\");\nconst debug7z = exports.debug7z = (0, (_debug2 || _load_debug()).default)(\"electron-builder:7z\");\nconst DEFAULT_APP_DIR_NAMES = [\"app\", \"www\"];\nfunction removePassword(input) {\n    return input.replace(/(-P |pass:| \\/p|-pass )([^ ]+)/g, function (match, p1, p2) {\n        return `${p1}${(0, (_crypto || _load_crypto()).createHash)(\"sha256\").update(p2).digest(\"hex\")} (sha256 hash)`;\n    });\n}\nfunction execWine(file, args, options) {\n    return exec(process.platform === \"win32\" ? file : \"wine\", prepareArgs(args, file), options);\n}\nfunction prepareArgs(args, exePath) {\n    if (process.platform !== \"win32\") {\n        args.unshift(exePath);\n    }\n    return args;\n}\nfunction exec(file, args, options) {\n    if (debug.enabled) {\n        debug(`Executing ${file} ${args == null ? \"\" : removePassword(args.join(\" \"))}`);\n    }\n    return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {\n        (0, (_child_process || _load_child_process()).execFile)(file, args, options, function (error, stdout, stderr) {\n            if (error == null) {\n                if (debug.enabled) {\n                    if (stderr.length !== 0) {\n                        (0, (_log || _load_log()).log)(stderr);\n                    }\n                    if (stdout.length !== 0) {\n                        (0, (_log || _load_log()).log)(stdout);\n                    }\n                }\n                resolve(stdout);\n            } else {\n                let message = (0, (_chalk || _load_chalk()).red)(removePassword(`Exit code: ${error.code}. ${error.message}`));\n                if (stdout.length !== 0) {\n                    message += `\\n${(0, (_chalk || _load_chalk()).yellow)(stdout)}`;\n                }\n                if (stderr.length !== 0) {\n                    message += `\\n${(0, (_chalk || _load_chalk()).red)(stderr)}`;\n                }\n                reject(new Error(message));\n            }\n        });\n    });\n}\nfunction doSpawn(command, args, options, pipeInput) {\n    if (options == null) {\n        options = {};\n    }\n    if (options.stdio == null) {\n        options.stdio = [pipeInput ? \"pipe\" : \"ignore\", debug.enabled ? \"inherit\" : \"pipe\", \"pipe\"];\n    }\n    if (debug.enabled) {\n        const argsString = args.join(\" \");\n        debug(`Spawning ${command} ${command === \"docker\" ? argsString : removePassword(argsString)}`);\n    }\n    return (0, (_child_process || _load_child_process()).spawn)(command, args, options);\n}\nfunction spawn(command, args, options) {\n    return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {\n        handleProcess(\"close\", doSpawn(command, args || [], options), command, resolve, reject);\n    });\n}\nfunction handleProcess(event, childProcess, command, resolve, reject) {\n    childProcess.on(\"error\", reject);\n    let out = \"\";\n    if (!debug.enabled && childProcess.stdout != null) {\n        childProcess.stdout.on(\"data\", data => {\n            out += data;\n        });\n    }\n    let errorOut = \"\";\n    if (childProcess.stderr != null) {\n        childProcess.stderr.on(\"data\", data => {\n            errorOut += data;\n        });\n    }\n    childProcess.once(event, code => {\n        if (code === 0 && debug.enabled) {\n            debug(`${command} (${childProcess.pid}) exited with code ${code}`);\n        }\n        if (code !== 0) {\n            function formatOut(text, title) {\n                return text.length === 0 ? \"\" : `\\n${title}:\\n${text}`;\n            }\n            reject(new Error(`${command} exited with code ${code}${formatOut(out, \"Output\")}${formatOut(errorOut, \"Error output\")}`));\n        } else if (resolve != null) {\n            resolve();\n        }\n    });\n}\nfunction use(value, task) {\n    return value == null ? null : task(value);\n}\nfunction debug7zArgs(command) {\n    const args = [command, \"-bd\"];\n    if (debug7z.enabled) {\n        args.push(\"-bb3\");\n    } else if (!debug.enabled) {\n        args.push(\"-bb0\");\n    }\n    return args;\n}\nlet tmpDirCounter = exports.tmpDirCounter = 0;\n// add date to avoid use stale temp dir\nconst tempDirPrefix = `${process.pid.toString(16)}-${Date.now().toString(16)}`;\nfunction getTempName(prefix) {\n    return `${prefix == null ? \"\" : `${prefix}-`}${tempDirPrefix}-${(exports.tmpDirCounter = tmpDirCounter += 1, tmpDirCounter - 1).toString(16)}`;\n}\nfunction isEmptyOrSpaces(s) {\n    return s == null || s.trim().length === 0;\n}\nfunction asArray(v) {\n    if (v == null) {\n        return [];\n    } else if (Array.isArray(v)) {\n        return v;\n    } else {\n        return [v];\n    }\n}\nfunction getCacheDirectory() {\n    if (process.platform === \"darwin\") {\n        return _path.join((0, (_os || _load_os()).homedir)(), \"Library\", \"Caches\", \"electron-builder\");\n    }\n    const localappdata = process.env.LOCALAPPDATA;\n    if (process.platform === \"win32\" && localappdata != null) {\n        // https://github.com/electron-userland/electron-builder/issues/1164\n        if (localappdata.toLowerCase().indexOf(\"\\\\windows\\\\system32\\\\\") !== -1 || (process.env.USERNAME || \"\").toLowerCase() === \"system\") {\n            return _path.join((0, (_os || _load_os()).tmpdir)(), \"electron-builder-cache\");\n        }\n        return _path.join(localappdata, \"electron-builder\", \"cache\");\n    }\n    return _path.join((0, (_os || _load_os()).homedir)(), \".cache\", \"electron-builder\");\n}\n// fpm bug - rpm build --description is not escaped, well... decided to replace quite to smart quote\n// http://leancrew.com/all-this/2010/11/smart-quotes-in-javascript/\nfunction smarten(s) {\n    // opening singles\n    s = s.replace(/(^|[-\\u2014\\s(\\[\"])'/g, \"$1\\u2018\");\n    // closing singles & apostrophes\n    s = s.replace(/'/g, \"\\u2019\");\n    // opening doubles\n    s = s.replace(/(^|[-\\u2014/\\[(\\u2018\\s])\"/g, \"$1\\u201c\");\n    // closing doubles\n    s = s.replace(/\"/g, \"\\u201d\");\n    return s;\n}\nclass Lazy {\n    constructor(creator) {\n        this.creator = creator;\n    }\n    get value() {\n        if (this.creator == null) {\n            return this._value;\n        }\n        this._value = this.creator();\n        this.creator = null;\n        return this._value;\n    }\n}\nexports.Lazy = Lazy;\nfunction addValue(map, key, value) {\n    const list = map.get(key);\n    if (list == null) {\n        map.set(key, [value]);\n    } else if (!(list.indexOf(value) !== -1)) {\n        list.push(value);\n    }\n}\nfunction replaceDefault(inList, defaultList) {\n    if (inList == null) {\n        return defaultList;\n    }\n    const index = inList.indexOf(\"default\");\n    if (index >= 0) {\n        let list = inList.slice(0, index);\n        list.push.apply(list, _toConsumableArray(defaultList));\n        if (index != inList.length - 1) {\n            list.push.apply(list, _toConsumableArray(inList.slice(index + 1)));\n        }\n        inList = list;\n    }\n    return inList;\n}\nfunction getPlatformIconFileName(value, isMac) {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    if (!(value.indexOf(\".\") !== -1)) {\n        return `${value}.${isMac ? \"icns\" : \"ico\"}`;\n    }\n    return value.replace(isMac ? \".ico\" : \".icns\", isMac ? \".icns\" : \".ico\");\n}\nfunction isPullRequest() {\n    // TRAVIS_PULL_REQUEST is set to the pull request number if the current job is a pull request build, or false if it’s not.\n    function isSet(value) {\n        // value can be or null, or empty string\n        return value && value !== \"false\";\n    }\n    return isSet(process.env.TRAVIS_PULL_REQUEST) || isSet(process.env.CI_PULL_REQUEST) || isSet(process.env.CI_PULL_REQUESTS);\n}\nfunction safeStringifyJson(data) {\n    return JSON.stringify(data, (name, value) => {\n        if (name.endsWith(\"Password\") || name.endsWith(\"Token\") || name.indexOf(\"password\") !== -1 || name.indexOf(\"token\") !== -1) {\n            return \"<stripped sensitive data>\";\n        }\n        return value;\n    }, 2);\n}\n//# sourceMappingURL=util.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-util/out/fs.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.FileCopier = exports.walk = exports.exists = exports.statOrNull = exports.CONCURRENCY = exports.MAX_FILE_REQUESTS = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet statOrNull = exports.statOrNull = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {\n        try {\n            return yield (0, (_fsExtraP || _load_fsExtraP()).stat)(file);\n        } catch (e) {\n            if (e.code === \"ENOENT\") {\n                return null;\n            } else {\n                throw e;\n            }\n        }\n    });\n\n    return function statOrNull(_x) {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nlet exists = exports.exists = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {\n        try {\n            yield (0, (_fsExtraP || _load_fsExtraP()).access)(file);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    });\n\n    return function exists(_x2) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet walk = exports.walk = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (initialDirPath, filter, consumer) {\n        const result = [];\n        const queue = [initialDirPath];\n        let addDirToResult = false;\n        while (queue.length > 0) {\n            const dirPath = queue.pop();\n            if (addDirToResult) {\n                result.push(dirPath);\n            } else {\n                addDirToResult = true;\n            }\n            const childNames = yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(dirPath);\n            childNames.sort();\n            const dirs = [];\n            // our handler is async, but we should add sorted files, so, we add file to result not in the mapper, but after map\n            const sortedFilePaths = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(childNames, function (name) {\n                const filePath = dirPath + _path.sep + name;\n                return (0, (_fsExtraP || _load_fsExtraP()).lstat)(filePath).then(function (stat) {\n                    if (filter != null && !filter(filePath, stat)) {\n                        return null;\n                    }\n                    const consumerResult = consumer == null ? null : consumer(filePath, stat, dirPath);\n                    if (consumerResult == null || !(\"then\" in consumerResult)) {\n                        if (stat.isDirectory()) {\n                            dirs.push(name);\n                            return null;\n                        } else {\n                            return filePath;\n                        }\n                    } else {\n                        return consumerResult.then(function (it) {\n                            // asarUtil can return modified stat (symlink handling)\n                            if ((it != null && \"isDirectory\" in it ? it : stat).isDirectory()) {\n                                dirs.push(name);\n                                return null;\n                            } else {\n                                return filePath;\n                            }\n                        });\n                    }\n                });\n            }, CONCURRENCY);\n            for (const child of sortedFilePaths) {\n                if (child != null) {\n                    result.push(child);\n                }\n            }\n            dirs.sort();\n            for (const child of dirs) {\n                queue.push(dirPath + _path.sep + child);\n            }\n        }\n        return result;\n    });\n\n    return function walk(_x3, _x4, _x5) {\n        return _ref3.apply(this, arguments);\n    };\n})();\n\nexports.unlinkIfExists = unlinkIfExists;\nexports.copyFile = copyFile;\nexports.copyDir = copyDir;\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _isCi;\n\nfunction _load_isCi() {\n    return _isCi = _interopRequireDefault(require(\"is-ci\"));\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _statMode;\n\nfunction _load_statMode() {\n    return _statMode = _interopRequireDefault(require(\"stat-mode\"));\n}\n\nvar _util;\n\nfunction _load_util() {\n    return _util = require(\"./util\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst MAX_FILE_REQUESTS = exports.MAX_FILE_REQUESTS = 8;\nconst CONCURRENCY = exports.CONCURRENCY = { concurrency: MAX_FILE_REQUESTS };\nfunction unlinkIfExists(file) {\n    return (0, (_fsExtraP || _load_fsExtraP()).unlink)(file).catch(() => {});\n}\n\nconst _isUseHardLink = process.platform != \"win32\" && process.env.USE_HARD_LINKS !== \"false\" && ((_isCi || _load_isCi()).default || process.env.USE_HARD_LINKS === \"true\");\n/**\n * Hard links is used if supported and allowed.\n * File permission is fixed — allow execute for all if owner can, allow read for all if owner can.\n */\nfunction copyFile(src, dest, stats) {\n    let isUseHardLink = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _isUseHardLink;\n\n    if (stats != null) {\n        const originalModeNumber = stats.mode;\n        const mode = new (_statMode || _load_statMode()).default(stats);\n        if (mode.owner.execute) {\n            mode.group.execute = true;\n            mode.others.execute = true;\n        }\n        mode.group.read = true;\n        mode.others.read = true;\n        if (originalModeNumber !== stats.mode) {\n            if ((_util || _load_util()).debug.enabled) {\n                const oldMode = new (_statMode || _load_statMode()).default(Object.assign({}, stats, { mode: originalModeNumber }));\n                (0, (_util || _load_util()).debug)(`${dest} permissions fixed from ${oldMode.toOctal()} (${oldMode.toString()}) to ${mode.toOctal()} (${mode.toString()})`);\n            }\n            // https://helgeklein.com/blog/2009/05/hard-links-and-permissions-acls/\n            // Permissions on all hard links to the same data on disk are always identical. The same applies to attributes.\n            // That means if you change the permissions/owner/attributes on one hard link, you will immediately see the changes on all other hard links.\n            if (isUseHardLink) {\n                isUseHardLink = false;\n                (0, (_util || _load_util()).debug)(`${dest} will be copied, but not linked, because file permissions need to be fixed`);\n            }\n        }\n    }\n    if (isUseHardLink) {\n        return (0, (_fsExtraP || _load_fsExtraP()).link)(src, dest);\n    }\n    return new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {\n        const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(src);\n        const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(dest, stats == null ? undefined : { mode: stats.mode });\n        readStream.on(\"error\", reject);\n        writeStream.on(\"error\", reject);\n        writeStream.on(\"open\", function () {\n            readStream.pipe(writeStream);\n        });\n        writeStream.once(\"close\", resolve);\n    });\n}\nclass FileCopier {\n    constructor(isUseHardLinkFunction, transformer) {\n        this.isUseHardLinkFunction = isUseHardLinkFunction;\n        this.transformer = transformer;\n        this.isUseHardLink = _isUseHardLink;\n    }\n    copy(src, dest, stat) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            try {\n                if (_this.transformer != null && stat != null && stat.isFile()) {\n                    let data = _this.transformer(src);\n                    if (data != null) {\n                        if (typeof data.then === \"function\") {\n                            data = yield data;\n                        }\n                        if (data != null) {\n                            yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(dest, data);\n                            return;\n                        }\n                    }\n                }\n                yield copyFile(src, dest, stat, !_this.isUseHardLink || _this.isUseHardLinkFunction == null ? _this.isUseHardLink : _this.isUseHardLinkFunction(dest));\n            } catch (e) {\n                // files are copied concurrently, so, we must not check here currentIsUseHardLink — our code can be executed after that other handler will set currentIsUseHardLink to false\n                if (e.code === \"EXDEV\") {\n                    // ...but here we want to avoid excess debug log message\n                    if (_this.isUseHardLink) {\n                        (0, (_util || _load_util()).debug)(`Cannot copy using hard link: ${e}`);\n                        _this.isUseHardLink = false;\n                    }\n                    yield copyFile(src, dest, stat, false);\n                } else {\n                    throw e;\n                }\n            }\n        })();\n    }\n}\nexports.FileCopier = FileCopier; /**\n                                  * Empty directories is never created.\n                                  * Hard links is used if supported and allowed.\n                                  */\n\nfunction copyDir(src, destination, filter, transformer, isUseHardLink) {\n    if ((_util || _load_util()).debug.enabled) {\n        (0, (_util || _load_util()).debug)(`Copying ${src} to ${destination}${_isUseHardLink ? \" using hard links\" : \"\"}`);\n    }\n    const createdSourceDirs = new Set();\n    const fileCopier = new FileCopier(isUseHardLink, transformer);\n    const links = [];\n    return walk(src, filter, (() => {\n        var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file, stat, parent) {\n            if (!stat.isFile() && !stat.isSymbolicLink()) {\n                return;\n            }\n            if (!createdSourceDirs.has(parent)) {\n                yield (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(parent.replace(src, destination));\n                createdSourceDirs.add(parent);\n            }\n            const destFile = file.replace(src, destination);\n            if (stat.isFile()) {\n                yield fileCopier.copy(file, destFile, stat);\n            } else {\n                links.push({ \"file\": destFile, \"link\": yield (0, (_fsExtraP || _load_fsExtraP()).readlink)(file) });\n            }\n        });\n\n        return function (_x7, _x8, _x9) {\n            return _ref4.apply(this, arguments);\n        };\n    })()).then(() => (_bluebirdLst2 || _load_bluebirdLst2()).default.map(links, it => (0, (_fsExtraP || _load_fsExtraP()).symlink)(it.link, it.file), CONCURRENCY));\n}\n//# sourceMappingURL=fs.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/appx.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _sanitizeFilename;\n\nfunction _load_sanitizeFilename() {\n    return _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\n}\n\nvar _windowsCodeSign;\n\nfunction _load_windowsCodeSign() {\n    return _windowsCodeSign = require(\"../windowsCodeSign\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nclass AppXTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(packager, outDir) {\n        super(\"appx\");\n        this.packager = packager;\n        this.outDir = outDir;\n        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config.appx);\n        const osVersion = (0, (_os || _load_os()).release)();\n        if (process.platform !== \"win32\" || parseInt(osVersion.substring(0, osVersion.indexOf(\".\")), 10) < 10) {\n            throw new Error(\"AppX is supported only on Windows 10\");\n        }\n    }\n    // no flatten - use asar or npm 3 or yarn\n    build(appOutDir, arch) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this.packager;\n            if ((yield packager.cscInfo) == null) {\n                throw new Error(\"AppX package must be signed, but certificate is not set, please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing\");\n            }\n            let publisher = _this.options.publisher;\n            if (publisher == null) {\n                const computed = yield packager.computedPublisherName.value;\n                if (computed != null) {\n                    publisher = `CN=${computed[0]}`;\n                }\n                if (publisher == null) {\n                    throw new Error(\"Please specify appx.publisher\");\n                }\n            }\n            const appInfo = packager.appInfo;\n            const preAppx = _path.join(_this.outDir, `pre-appx-${(0, (_electronBuilderCore || _load_electronBuilderCore()).getArchSuffix)(arch)}`);\n            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(preAppx);\n            const vendorPath = yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)();\n            const templatePath = _path.join(__dirname, \"..\", \"..\", \"templates\", \"appx\");\n            const safeName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(appInfo.name);\n            const resourceList = yield packager.resourceList;\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(_bluebirdLst2 || _load_bluebirdLst2()).default.map([\"44x44\", \"50x50\", \"150x150\", \"310x150\"], function (size) {\n                const target = _path.join(preAppx, \"assets\", `${safeName}.${size}.png`);\n                if (resourceList.indexOf(`${size}.png`) !== -1) {\n                    return (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(packager.buildResourcesDir, `${size}.png`), target);\n                }\n                return (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.join(vendorPath, \"appxAssets\", `SampleAppx.${size}.png`), target);\n            }), (0, (_fs || _load_fs()).copyDir)(appOutDir, _path.join(preAppx, \"app\")), _this.writeManifest(templatePath, preAppx, safeName, arch, publisher)]);\n            const destination = _path.join(_this.outDir, packager.generateName(\"appx\", arch, false));\n            const args = [\"pack\", \"/o\", \"/d\", preAppx, \"/p\", destination];\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(_this.options.makeappxArgs, function (it) {\n                return args.push.apply(args, _toConsumableArray(it));\n            });\n            // wine supports only ia32 binary in any case makeappx crashed on wine\n            // await execWine(path.join(await getSignVendorPath(), \"windows-10\", process.platform === \"win32\" ? process.arch : \"ia32\", \"makeappx.exe\"), args)\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(_path.join(vendorPath, \"windows-10\", arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 ? \"ia32\" : \"x64\", \"makeappx.exe\"), args);\n            yield packager.sign(destination);\n            packager.dispatchArtifactCreated(destination, _this, arch, packager.generateName(\"appx\", arch, true));\n        })();\n    }\n    writeManifest(templatePath, preAppx, safeName, arch, publisher) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const appInfo = _this2.packager.appInfo;\n            const manifest = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(templatePath, \"appxmanifest.xml\"), \"utf8\")).replace(/\\$\\{([a-zA-Z]+)\\}/g, function (match, p1) {\n                switch (p1) {\n                    case \"publisher\":\n                        return publisher;\n                    case \"publisherDisplayName\":\n                        return _this2.options.publisherDisplayName || appInfo.companyName;\n                    case \"version\":\n                        return appInfo.versionInWeirdWindowsForm;\n                    case \"name\":\n                        return appInfo.name;\n                    case \"identityName\":\n                        return _this2.options.identityName || appInfo.name;\n                    case \"executable\":\n                        return `app\\\\${appInfo.productFilename}.exe`;\n                    case \"displayName\":\n                        return _this2.options.displayName || appInfo.productName;\n                    case \"description\":\n                        return appInfo.description || appInfo.productName;\n                    case \"backgroundColor\":\n                        return _this2.options.backgroundColor || \"#464646\";\n                    case \"safeName\":\n                        return safeName;\n                    case \"arch\":\n                        return arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 ? \"x86\" : \"x64\";\n                    default:\n                        throw new Error(`Macro ${p1} is not defined`);\n                }\n            });\n            yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(preAppx, \"appxmanifest.xml\"), manifest);\n        })();\n    }\n}\nexports.default = AppXTarget; //# sourceMappingURL=appx.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/ArchiveTarget.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ArchiveTarget = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _archive;\n\nfunction _load_archive() {\n    return _archive = require(\"./archive\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nclass ArchiveTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(name, outDir, packager) {\n        super(name);\n        this.outDir = outDir;\n        this.packager = packager;\n        this.options = this.packager.config[this.name];\n    }\n    build(appOutDir, arch) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this.packager;\n            const isMac = packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC;\n            const outDir = _this.outDir;\n            const format = _this.name;\n            (0, (_log || _load_log()).log)(`Building ${isMac ? \"macOS \" : \"\"}${format}`);\n            // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204\n            const outFile = function () {\n                switch (packager.platform) {\n                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC:\n                        return _path.join(outDir, packager.expandArtifactNamePattern(_this.options, format, arch, \"${productName}-${version}-${os}.${ext}\"));\n                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS:\n                        return _path.join(outDir, packager.generateName(format, arch, false, \"win\"));\n                    case (_electronBuilderCore || _load_electronBuilderCore()).Platform.LINUX:\n                        return _path.join(outDir, packager.generateName(format, arch, true));\n                    default:\n                        throw new Error(`Unknown platform: ${packager.platform}`);\n                }\n            }();\n            if (format.startsWith(\"tar.\")) {\n                yield (0, (_archive || _load_archive()).tar)(packager.config.compression, format, outFile, appOutDir, isMac);\n            } else {\n                yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, outFile, appOutDir);\n            }\n            packager.dispatchArtifactCreated(outFile, _this, (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64, isMac ? packager.generateName2(format, \"mac\", true) : packager.generateName(format, arch, true, packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS ? \"win\" : null));\n        })();\n    }\n}\nexports.ArchiveTarget = ArchiveTarget; //# sourceMappingURL=ArchiveTarget.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/dmg.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.attachAndExecute = exports.DmgTarget = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet detach = (() => {\n    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (name) {\n        try {\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"hdiutil\", [\"detach\", name]);\n        } catch (e) {\n            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {\n                setTimeout(function () {\n                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"hdiutil\", [\"detach\", \"-force\", name]).then(resolve).catch(reject);\n                }, 1000);\n            });\n        }\n    });\n\n    return function detach(_x) {\n        return _ref2.apply(this, arguments);\n    };\n})();\n\nlet attachAndExecute = exports.attachAndExecute = (() => {\n    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (dmgPath, readWrite, task) {\n        //noinspection SpellCheckingInspection\n        const args = [\"attach\", \"-noverify\", \"-noautoopen\"];\n        if (readWrite) {\n            args.push(\"-readwrite\");\n        }\n        // otherwise hangs\n        // addVerboseIfNeed(args)\n        args.push(dmgPath);\n        const attachResult = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"hdiutil\", args, { maxBuffer: 2 * 1024 * 1024 });\n        const deviceResult = attachResult == null ? null : /^(\\/dev\\/\\w+)/.exec(attachResult);\n        const device = deviceResult == null || deviceResult.length !== 2 ? null : deviceResult[1];\n        if (device == null) {\n            throw new Error(`Cannot mount: ${attachResult}`);\n        }\n        return yield (0, (_promise || _load_promise()).executeFinally)(task(), function () {\n            return detach(device);\n        });\n    });\n\n    return function attachAndExecute(_x2, _x3, _x4) {\n        return _ref3.apply(this, arguments);\n    };\n})();\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _deepAssign;\n\nfunction _load_deepAssign() {\n    return _deepAssign = require(\"electron-builder-util/out/deepAssign\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _sanitizeFilename;\n\nfunction _load_sanitizeFilename() {\n    return _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass DmgTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(packager, outDir) {\n        super(\"dmg\");\n        this.packager = packager;\n        this.outDir = outDir;\n        this.options = this.packager.config.dmg;\n        this.helperDir = _path.join(__dirname, \"..\", \"..\", \"templates\", \"dmg\");\n    }\n    build(appPath, arch) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this.packager;\n            const appInfo = packager.appInfo;\n            (0, (_log || _load_log()).log)(\"Building DMG\");\n            const specification = yield _this.computeDmgOptions();\n            const tempDir = yield packager.getTempFile(\"dmg\");\n            const tempDmg = _path.join(tempDir, \"temp.dmg\");\n            const backgroundDir = _path.join(tempDir, \".background\");\n            const backgroundFilename = specification.background == null ? null : _path.basename(specification.background);\n            if (backgroundFilename != null) {\n                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_path.resolve(packager.info.projectDir, specification.background), _path.join(backgroundDir, backgroundFilename));\n            }\n            let preallocatedSize = 32 * 1024;\n            if (specification.icon != null) {\n                const stat = yield (0, (_fs || _load_fs()).statOrNull)(specification.icon);\n                if (stat != null) {\n                    preallocatedSize += stat.size;\n                }\n            }\n            // allocate space for .DS_Store\n            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(_path.join(backgroundDir, \"DSStorePlaceHolder\"), new Buffer(preallocatedSize));\n            const volumeName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(_this.computeVolumeName(specification.title));\n            //noinspection SpellCheckingInspection\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(\"hdiutil\", addVerboseIfNeed([\"create\", \"-srcfolder\", backgroundDir, \"-srcfolder\", appPath, \"-volname\", volumeName, \"-anyowners\", \"-nospotlight\", \"-fs\", \"HFS+\", \"-fsargs\", \"-c c=64,a=16,e=16\", \"-format\", \"UDRW\"]).concat(tempDmg));\n            const volumePath = _path.join(\"/Volumes\", volumeName);\n            if (yield (0, (_fs || _load_fs()).exists)(volumePath)) {\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(\"Unmounting previous disk image\");\n                yield detach(volumePath);\n            }\n            const isContinue = yield attachAndExecute(tempDmg, true, (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n                const promises = [specification.background == null ? (0, (_fsExtraP || _load_fsExtraP()).remove)(`${volumePath}/.background`) : (0, (_fsExtraP || _load_fsExtraP()).unlink)(`${volumePath}/.background/DSStorePlaceHolder`)];\n                let contents = specification.contents;\n                if (contents == null) {\n                    contents = [{\n                        \"x\": 130, \"y\": 220\n                    }, {\n                        \"x\": 410, \"y\": 220, \"type\": \"link\", \"path\": \"/Applications\"\n                    }];\n                }\n                const window = specification.window;\n                const env = Object.assign({}, process.env, {\n                    volumePath: volumePath,\n                    appFileName: `${packager.appInfo.productFilename}.app`,\n                    iconSize: specification.iconSize || 80,\n                    iconTextSize: specification.iconTextSize || 12,\n                    windowX: window.x,\n                    windowY: window.y,\n                    VERSIONER_PERL_PREFER_32_BIT: \"true\"\n                });\n                if (specification.icon == null) {\n                    delete env.volumeIcon;\n                } else {\n                    const volumeIcon = `${volumePath}/.VolumeIcon.icns`;\n                    promises.push((0, (_fsExtraP || _load_fsExtraP()).copy)((yield packager.getResource(specification.icon)), volumeIcon));\n                    env.volumeIcon = volumeIcon;\n                }\n                if (specification.backgroundColor != null || specification.background == null) {\n                    env.backgroundColor = specification.backgroundColor || \"#ffffff\";\n                    env.windowWidth = window.width || 540;\n                    env.windowHeight = window.height || 380;\n                } else {\n                    delete env.backgroundColor;\n                    if (window.width == null) {\n                        delete env.windowWidth;\n                    } else {\n                        env.windowWidth = window.width;\n                    }\n                    if (window.height == null) {\n                        delete env.windowHeight;\n                    } else {\n                        env.windowHeight = window.height;\n                    }\n                    env.backgroundFilename = backgroundFilename;\n                }\n                let entries = \"\";\n                for (const c of contents) {\n                    if (c.path != null && c.path.endsWith(\".app\") && c.type !== \"link\") {\n                        (0, (_log || _load_log()).warn)(`Do not specify path for application: \"${c.path}\". Actual path to app will be used instead.`);\n                    }\n                    let entryPath = c.path || `${packager.appInfo.productFilename}.app`;\n                    if (entryPath.startsWith(\"/\")) {\n                        entryPath = entryPath.substring(1);\n                    }\n                    const entryName = c.name || _path.basename(entryPath);\n                    entries += `&makeEntries(\"${entryName}\", Iloc_xy => [ ${c.x}, ${c.y} ]),\\n`;\n                    if (c.type === \"link\") {\n                        promises.push((0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"ln\", [\"-s\", `/${entryPath}`, `${volumePath}/${entryName}`]));\n                    }\n                }\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(entries);\n                const dmgPropertiesFile = yield packager.getTempFile(\"dmgProperties.pl\");\n                promises.push((0, (_fsExtraP || _load_fsExtraP()).outputFile)(dmgPropertiesFile, (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(_this.helperDir, \"dmgProperties.pl\"), \"utf-8\")).replace(\"$ENTRIES\", entries)));\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);\n                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"/usr/bin/perl\", [dmgPropertiesFile], {\n                    cwd: _path.join(__dirname, \"..\", \"..\", \"vendor\"),\n                    env: env\n                });\n                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"sync\");\n                return packager.packagerOptions.effectiveOptionComputed == null || !(yield packager.packagerOptions.effectiveOptionComputed({ volumePath, specification, packager }));\n            }));\n            if (!isContinue) {\n                return;\n            }\n            const artifactPath = _path.join(_this.outDir, packager.expandArtifactNamePattern(packager.config.dmg, \"dmg\"));\n            // dmg file must not exist otherwise hdiutil failed (https://github.com/electron-userland/electron-builder/issues/1308#issuecomment-282847594), so, -ov must be specified\n            //noinspection SpellCheckingInspection\n            const args = [\"convert\", tempDmg, \"-ov\", \"-format\", specification.format, \"-o\", artifactPath];\n            if (specification.format === \"UDZO\") {\n                args.push(\"-imagekey\", `zlib-level=${process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL || \"9\"}`);\n            }\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(\"hdiutil\", addVerboseIfNeed(args));\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"hdiutil\", addVerboseIfNeed([\"internet-enable\", \"-no\"]).concat(artifactPath));\n            _this.packager.dispatchArtifactCreated(artifactPath, _this, arch, `${appInfo.name}-${appInfo.version}.dmg`);\n        })();\n    }\n    computeVolumeName(custom) {\n        const appInfo = this.packager.appInfo;\n        if (custom == null) {\n            return `${appInfo.productFilename} ${appInfo.version}`;\n        }\n        return custom.replace(/\\$\\{version}/g, appInfo.version).replace(/\\$\\{name}/g, appInfo.name).replace(/\\$\\{productName}/g, appInfo.productName);\n    }\n    // public to test\n    computeDmgOptions() {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const specification = (0, (_deepAssign || _load_deepAssign()).deepAssign)({\n                window: {\n                    x: 400,\n                    y: 100\n                }\n            }, _this2.options);\n            // appdmg\n            const oldPosition = specification.window.position;\n            if (oldPosition != null) {\n                specification.window.x = oldPosition.x;\n                specification.window.y = oldPosition.y;\n            }\n            const oldSize = specification.window.size;\n            if (oldSize != null) {\n                specification.window.width = oldSize.width;\n                specification.window.height = oldSize.height;\n            }\n            if (specification[\"icon-size\"] != null) {\n                if (specification.iconSize == null) {\n                    specification.iconSize = specification[\"icon-size\"];\n                }\n                (0, (_log || _load_log()).warn)(\"dmg.icon-size is deprecated, please use dmg.iconSize instead\");\n            }\n            const packager = _this2.packager;\n            if (!(\"icon\" in specification)) {\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)((yield packager.getIconPath()), function (it) {\n                    specification.icon = it;\n                });\n            }\n            if (specification.icon != null && (0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(specification.icon)) {\n                throw new Error(\"dmg.icon cannot be specified as empty string\");\n            }\n            if (specification[\"background-color\"] != null) {\n                if (specification.backgroundColor == null) {\n                    specification.backgroundColor = specification[\"background-color\"];\n                }\n                (0, (_log || _load_log()).warn)(\"dmg.background-color is deprecated, please use dmg.backgroundColor instead\");\n            }\n            if (specification.backgroundColor != null) {\n                if (specification.background != null) {\n                    throw new Error(\"Both dmg.backgroundColor and dmg.background are specified — please set the only one\");\n                }\n                specification.backgroundColor = require(\"parse-color\")(specification.backgroundColor).hex;\n            }\n            if (specification.backgroundColor == null && !(\"background\" in specification)) {\n                const resourceList = yield packager.resourceList;\n                if (resourceList.indexOf(\"background.tiff\") !== -1) {\n                    specification.background = _path.join(packager.buildResourcesDir, \"background.tiff\");\n                } else if (resourceList.indexOf(\"background.png\") !== -1) {\n                    specification.background = _path.join(packager.buildResourcesDir, \"background.png\");\n                } else {\n                    specification.background = _path.join(_this2.helperDir, \"background.tiff\");\n                }\n            }\n            if (specification.format == null) {\n                if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {\n                    specification.format = \"UDZO\";\n                } else if (packager.config.compression === \"store\") {\n                    specification.format = \"UDRO\";\n                } else {\n                    specification.format = packager.config.compression === \"maximum\" ? \"UDBZ\" : \"UDZO\";\n                }\n            }\n            return specification;\n        })();\n    }\n}\nexports.DmgTarget = DmgTarget;\n\nfunction addVerboseIfNeed(args) {\n    if (process.env.DEBUG_DMG === \"true\") {\n        args.push(\"-verbose\");\n    }\n    return args;\n}\n//# sourceMappingURL=dmg.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/fpm.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nlet writeConfigFile = (() => {\n    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tmpDir, templatePath, options) {\n        //noinspection JSUnusedLocalSymbols\n        function replacer(match, p1) {\n            if (p1 in options) {\n                return options[p1];\n            } else {\n                throw new Error(`Macro ${p1} is not defined`);\n            }\n        }\n        const config = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(templatePath, \"utf8\")).replace(/\\$\\{([a-zA-Z]+)\\}/g, replacer).replace(/<%=([a-zA-Z]+)%>/g, function (match, p1) {\n            (0, (_log || _load_log()).warn)(\"<%= varName %> is deprecated, please use ${varName} instead\");\n            return replacer(match, p1.trim());\n        });\n        const outputPath = yield tmpDir.getTempFile(_path.basename(templatePath, \".tpl\"));\n        yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(outputPath, config);\n        return outputPath;\n    });\n\n    return function writeConfigFile(_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n    };\n})();\n//# sourceMappingURL=fpm.js.map\n\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _binDownload;\n\nfunction _load_binDownload() {\n    return _binDownload = require(\"electron-builder-util/out/binDownload\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _errorMessages;\n\nfunction _load_errorMessages() {\n    return _errorMessages = _interopRequireWildcard(require(\"../errorMessages\"));\n}\n\nvar _LinuxTargetHelper;\n\nfunction _load_LinuxTargetHelper() {\n    return _LinuxTargetHelper = require(\"./LinuxTargetHelper\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nconst fpmPath = process.platform === \"win32\" || process.env.USE_SYSTEM_FPM === \"true\" ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(\"fpm\") : downloadFpm();\n// can be called in parallel, all calls for the same version will get the same promise - will be downloaded only once\nfunction downloadFpm() {\n    const version = process.platform === \"darwin\" ? \"fpm-1.8.1-20150715-2.2.2\" : \"fpm-1.8.1-2.3.1\";\n    const osAndArch = process.platform === \"darwin\" ? \"mac\" : `linux-x86${process.arch === \"ia32\" ? \"\" : \"_64\"}`;\n    //noinspection SpellCheckingInspection\n    const sha2 = process.platform === \"darwin\" ? \"97352e184a1f54e5ed0d12f38ac383edebbe421db5a3fb59898e8c9a1c407ed7\" : process.arch === \"ia32\" ? \"8380331f7d9762a36d7c7181501c3fc9342745b8499b962f6ea37c7dc3778f99\" : \"6538fcd2486c2831949562abfd0017b67eff502addad5b444baec4899b0babc6\";\n    return (0, (_binDownload || _load_binDownload()).getBin)(\"fpm\", version, `https://dl.bintray.com/electron-userland/bin/${version}-${osAndArch}.7z`, sha2).then(it => _path.join(it, \"fpm\"));\n}\nclass FpmTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(name, packager, helper, outDir) {\n        super(name, false);\n        this.packager = packager;\n        this.helper = helper;\n        this.outDir = outDir;\n        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);\n        this.scriptFiles = this.createScripts();\n    }\n    createScripts() {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const defaultTemplatesDir = _path.join(__dirname, \"..\", \"..\", \"templates\", \"linux\");\n            const packager = _this.packager;\n            const templateOptions = Object.assign({\n                // old API compatibility\n                executable: packager.executableName,\n                productFilename: packager.appInfo.productFilename\n            }, packager.platformSpecificBuildOptions);\n            function getResource(value, defaultFile) {\n                if (value == null) {\n                    return _path.join(defaultTemplatesDir, defaultFile);\n                }\n                return _path.resolve(packager.projectDir, value);\n            }\n            //noinspection ES6MissingAwait\n            return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([writeConfigFile(packager.info.tempDirManager, getResource(_this.options.afterInstall, \"after-install.tpl\"), templateOptions), writeConfigFile(packager.info.tempDirManager, getResource(_this.options.afterRemove, \"after-remove.tpl\"), templateOptions)]);\n        })();\n    }\n    build(appOutDir, arch) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const target = _this2.name;\n            (0, (_log || _load_log()).log)(`Building ${target}`);\n            const destination = _path.join(_this2.outDir, _this2.packager.generateName(target, arch, true /* on Linux we use safe name — without space */));\n            yield (0, (_fs || _load_fs()).unlinkIfExists)(destination);\n            if (_this2.packager.info.prepackaged != null) {\n                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_this2.outDir);\n            }\n            const scripts = yield _this2.scriptFiles;\n            const packager = _this2.packager;\n            const appInfo = packager.appInfo;\n            const projectUrl = yield appInfo.computePackageUrl();\n            if (projectUrl == null) {\n                throw new Error(\"Please specify project homepage, see https://github.com/electron-userland/electron-builder/wiki/Options#AppMetadata-homepage\");\n            }\n            const options = _this2.options;\n            let author = options.maintainer;\n            if (author == null) {\n                const a = appInfo.metadata.author;\n                if (a.email == null) {\n                    throw new Error((_errorMessages || _load_errorMessages()).authorEmailIsMissed);\n                }\n                author = `${a.name} <${a.email}>`;\n            }\n            const synopsis = options.synopsis;\n            const args = [\"-s\", \"dir\", \"-t\", target, \"--architecture\", target === \"pacman\" && arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.ia32 ? \"i686\" : (0, (_electronBuilderCore || _load_electronBuilderCore()).toLinuxArchString)(arch), \"--name\", appInfo.name, \"--force\", \"--after-install\", scripts[0], \"--after-remove\", scripts[1], \"--description\", (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(target === \"rpm\" ? _this2.helper.getDescription(options) : `${synopsis || \"\"}\\n ${_this2.helper.getDescription(options)}`), \"--maintainer\", author, \"--vendor\", options.vendor || author, \"--version\", appInfo.version, \"--package\", destination, \"--url\", projectUrl];\n            const packageCategory = options.packageCategory;\n            if (packageCategory != null && packageCategory !== null) {\n                args.push(\"--category\", packageCategory);\n            }\n            if (target === \"deb\") {\n                args.push(\"--deb-compression\", options.compression || (packager.config.compression === \"store\" ? \"gz\" : \"xz\"));\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.priority, function (it) {\n                    return args.push(\"--deb-priority\", it);\n                });\n            } else if (target === \"rpm\") {\n                args.push(\"--rpm-os\", \"linux\");\n                if (synopsis != null) {\n                    args.push(\"--rpm-summary\", (0, (_electronBuilderUtil || _load_electronBuilderUtil()).smarten)(synopsis));\n                }\n            }\n            // noinspection JSDeprecatedSymbols\n            let depends = options.depends || _this2.packager.platformSpecificBuildOptions.depends;\n            if (depends == null) {\n                if (target === \"deb\") {\n                    depends = [\"gconf2\", \"gconf-service\", \"libnotify4\", \"libappindicator1\", \"libxtst6\", \"libnss3\", \"libxss1\"];\n                } else if (target === \"pacman\") {\n                    // noinspection SpellCheckingInspection\n                    depends = [\"c-ares\", \"ffmpeg\", \"gtk3\", \"http-parser\", \"libevent\", \"libvpx\", \"libxslt\", \"libxss\", \"minizip\", \"nss\", \"re2\", \"snappy\", \"libnotify\", \"libappindicator-gtk2\", \"libappindicator-gtk3\", \"libappindicator-sharp\"];\n                } else if (target === \"rpm\") {\n                    depends = [\"libnotify\", \"libappindicator\"];\n                } else {\n                    depends = [];\n                }\n            } else if (!Array.isArray(depends)) {\n                if (typeof depends === \"string\") {\n                    depends = [depends];\n                } else {\n                    throw new Error(`depends must be Array or String, but specified as: ${depends}`);\n                }\n            }\n            for (const dep of depends) {\n                args.push(\"--depends\", dep);\n            }\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(packager.appInfo.metadata.license, function (it) {\n                return args.push(\"--license\", it);\n            });\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(appInfo.buildNumber, function (it) {\n                return args.push(\"--iteration\", it);\n            });\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.fpm, function (it) {\n                return args.push.apply(args, _toConsumableArray(it));\n            });\n            args.push(`${appOutDir}/=${(_LinuxTargetHelper || _load_LinuxTargetHelper()).installPrefix}/${appInfo.productFilename}`);\n            for (const mapping of yield _this2.helper.icons) {\n                args.push(mapping.join(\"=/usr/share/icons/hicolor/\"));\n            }\n            const desktopFilePath = yield _this2.helper.computeDesktopEntry(_this2.options);\n            args.push(`${desktopFilePath}=/usr/share/applications/${_this2.packager.executableName}.desktop`);\n            if (_this2.packager.packagerOptions.effectiveOptionComputed != null && (yield _this2.packager.packagerOptions.effectiveOptionComputed([args, desktopFilePath]))) {\n                return;\n            }\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)((yield fpmPath), args);\n            _this2.packager.dispatchArtifactCreated(destination, _this2, arch);\n        })();\n    }\n}\nexports.default = FpmTarget;","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/LinuxTargetHelper.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LinuxTargetHelper = exports.installPrefix = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst installPrefix = exports.installPrefix = \"/opt\";\nclass LinuxTargetHelper {\n    constructor(packager) {\n        this.packager = packager;\n        this.maxIconPath = null;\n        this.icons = this.computeDesktopIcons();\n    }\n    // must be name without spaces and other special characters, but not product name used\n    computeDesktopIcons() {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this.packager;\n            let customIconSetDir = packager.platformSpecificBuildOptions.icon;\n            if (customIconSetDir != null) {\n                let iconDir = _path.resolve(packager.buildResourcesDir, customIconSetDir);\n                const stat = yield (0, (_fs || _load_fs()).statOrNull)(iconDir);\n                if (stat == null || !stat.isDirectory()) {\n                    iconDir = _path.resolve(packager.projectDir, customIconSetDir);\n                }\n                try {\n                    return yield _this.iconsFromDir(iconDir);\n                } catch (e) {\n                    if (e.code === \"ENOENT\") {\n                        throw new Error(`Icon set directory ${iconDir} doesn't exist`);\n                    } else if (e.code === \"ENOTDIR\") {\n                        throw new Error(`linux.icon must be set to an icon set directory, but ${iconDir} is not a directory. Please see https://github.com/electron-userland/electron-builder/wiki/Options#LinuxBuildOptions-icon`);\n                    } else {\n                        throw e;\n                    }\n                }\n            }\n            const resourceList = yield packager.resourceList;\n            if (resourceList.indexOf(\"icons\") !== -1) {\n                return yield _this.iconsFromDir(_path.join(packager.buildResourcesDir, \"icons\"));\n            } else {\n                const iconDir = yield packager.getTempFile(\"linux.iconset\");\n                (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(iconDir);\n                return yield _this.createFromIcns(iconDir);\n            }\n        })();\n    }\n    iconsFromDir(iconDir) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const mappings = [];\n            let maxSize = 0;\n            for (const file of yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(iconDir)) {\n                if (file.endsWith(\".png\") || file.endsWith(\".PNG\")) {\n                    // If parseInt encounters a character that is not a numeral in the specified radix,\n                    // it returns the integer value parsed up to that point\n                    try {\n                        let sizeString = file.match(/\\d+/);\n                        const size = sizeString == null ? 0 : parseInt(sizeString[0], 10);\n                        if (size > 0) {\n                            const iconPath = `${iconDir}/${file}`;\n                            mappings.push([iconPath, `${size}x${size}/apps/${_this2.packager.executableName}.png`]);\n                            if (size > maxSize) {\n                                maxSize = size;\n                                _this2.maxIconPath = iconPath;\n                            }\n                        }\n                    } catch (e) {\n                        console.error(e);\n                    }\n                }\n            }\n            if (mappings.length === 0) {\n                throw new Error(`Icon set directory ${iconDir} doesn't contain icons`);\n            }\n            return mappings;\n        })();\n    }\n    getIcns() {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const build = _this3.packager.config;\n            let iconPath = (build.mac || {}).icon || build.icon;\n            if (iconPath != null && !iconPath.endsWith(\".icns\")) {\n                iconPath += \".icns\";\n            }\n            return iconPath == null ? yield _this3.packager.getDefaultIcon(\"icns\") : _path.resolve(_this3.packager.projectDir, iconPath);\n        })();\n    }\n    getDescription(options) {\n        return options.description || this.packager.appInfo.description;\n    }\n    computeDesktopEntry(targetSpecificOptions, exec, destination, extra) {\n        var _this4 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const appInfo = _this4.packager.appInfo;\n            const productFilename = appInfo.productFilename;\n            const desktopMeta = Object.assign({\n                Name: appInfo.productName,\n                Comment: _this4.getDescription(targetSpecificOptions),\n                Exec: exec == null ? `\"${installPrefix}/${productFilename}/${_this4.packager.executableName}\"` : exec,\n                Terminal: \"false\",\n                Type: \"Application\",\n                Icon: _this4.packager.executableName\n            }, extra, targetSpecificOptions.desktop);\n            const category = targetSpecificOptions.category;\n            if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(category)) {\n                if (category) desktopMeta.Categories = category + (category.endsWith(\";\") ? \"\" : \";\");\n            }\n            let data = `[Desktop Entry]`;\n            for (const name of Object.keys(desktopMeta)) {\n                const value = desktopMeta[name];\n                data += `\\n${name}=${value}`;\n            }\n            data += \"\\n\";\n            const tempFile = destination || (yield _this4.packager.getTempFile(`${productFilename}.desktop`));\n            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(tempFile, data);\n            return tempFile;\n        })();\n    }\n    createFromIcns(tempDir) {\n        var _this5 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const iconPath = yield _this5.getIcns();\n            if (iconPath == null) {\n                return yield _this5.iconsFromDir(_path.join(__dirname, \"..\", \"..\", \"templates\", \"linux\", \"electron-icons\"));\n            }\n            if (process.platform === \"darwin\") {\n                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"iconutil\", [\"--convert\", \"iconset\", \"--output\", tempDir, iconPath]);\n                const iconFiles = yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(tempDir);\n                const imagePath = iconFiles.indexOf(\"icon_512x512.png\") !== -1 ? _path.join(tempDir, \"icon_512x512.png\") : _path.join(tempDir, \"icon_256x256.png\");\n                _this5.maxIconPath = imagePath;\n                function resize(size) {\n                    const filename = `icon_${size}x${size}.png`;\n                    if (iconFiles.indexOf(filename) !== -1) {\n                        return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();\n                    }\n                    const sizeArg = `${size}x${size}`;\n                    return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"gm\", [\"convert\", \"-size\", sizeArg, imagePath, \"-resize\", sizeArg, _path.join(tempDir, filename)]);\n                }\n                const promises = [resize(24), resize(96)];\n                promises.push(resize(16));\n                promises.push(resize(48));\n                promises.push(resize(64));\n                promises.push(resize(128));\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);\n                return _this5.createMappings(tempDir);\n            } else {\n                const output = yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"icns2png\", [\"-x\", \"-o\", tempDir, iconPath]);\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(output);\n                //noinspection UnnecessaryLocalVariableJS\n                const has256 = output.indexOf(\"ic08\") !== -1;\n                const imagePath = _path.join(tempDir, has256 ? \"icon_256x256x32.png\" : \"icon_128x128x32.png\");\n                _this5.maxIconPath = imagePath;\n                function resize(size) {\n                    const sizeArg = `${size}x${size}`;\n                    return (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"gm\", [\"convert\", \"-size\", sizeArg, imagePath, \"-resize\", sizeArg, _path.join(tempDir, `icon_${size}x${size}x32.png`)]);\n                }\n                const promises = [resize(24), resize(96)];\n                if (!(output.indexOf(\"is32\") !== -1)) {\n                    promises.push(resize(16));\n                }\n                if (!(output.indexOf(\"ih32\") !== -1)) {\n                    promises.push(resize(48));\n                }\n                if (!(output.toString().indexOf(\"icp6\") !== -1)) {\n                    promises.push(resize(64));\n                }\n                if (has256 && !(output.indexOf(\"it32\") !== -1)) {\n                    promises.push(resize(128));\n                }\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);\n                return _this5.createMappings(tempDir);\n            }\n        })();\n    }\n    createMappings(tempDir) {\n        const name = this.packager.executableName;\n        function createMapping(size) {\n            return [process.platform === \"darwin\" ? `${tempDir}/icon_${size}x${size}.png` : `${tempDir}/icon_${size}x${size}x32.png`, `${size}x${size}/apps/${name}.png`];\n        }\n        return [createMapping(\"16\"), createMapping(\"24\"), createMapping(\"32\"), createMapping(\"48\"), createMapping(\"64\"), createMapping(\"96\"), createMapping(\"128\"), createMapping(\"256\"), createMapping(\"512\")];\n    }\n}\nexports.LinuxTargetHelper = LinuxTargetHelper; //# sourceMappingURL=LinuxTargetHelper.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/nsis.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.NsisTarget = exports.AppPackageHelper = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _binDownload;\n\nfunction _load_binDownload() {\n    return _binDownload = require(\"electron-builder-util/out/binDownload\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _promise;\n\nfunction _load_promise() {\n    return _promise = require(\"electron-builder-util/out/promise\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _jsYaml;\n\nfunction _load_jsYaml() {\n    return _jsYaml = require(\"js-yaml\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _sanitizeFilename;\n\nfunction _load_sanitizeFilename() {\n    return _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\n}\n\nvar _uuid;\n\nfunction _load_uuid() {\n    return _uuid = require(\"uuid-1345\");\n}\n\nvar _platformPackager;\n\nfunction _load_platformPackager() {\n    return _platformPackager = require(\"../platformPackager\");\n}\n\nvar _windowsCodeSign;\n\nfunction _load_windowsCodeSign() {\n    return _windowsCodeSign = require(\"../windowsCodeSign\");\n}\n\nvar _archive;\n\nfunction _load_archive() {\n    return _archive = require(\"./archive\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// noinspection SpellCheckingInspection\nconst ELECTRON_BUILDER_NS_UUID = \"50e065bc-3134-11e6-9bab-38c9862bdaf3\";\n// noinspection SpellCheckingInspection\nconst nsisPathPromise = (0, (_binDownload || _load_binDownload()).getBinFromBintray)(\"nsis\", \"3.0.1.10\", \"302a8adebf0b553f74cddd494154a586719ff9d4767e94d8a76547a9bb06200c\");\n// noinspection SpellCheckingInspection\nconst nsisResourcePathPromise = (0, (_binDownload || _load_binDownload()).getBinFromBintray)(\"nsis-resources\", \"3.0.0\", \"cde0e77b249e29d74250bf006aa355d3e02b32226e1c6431fb48facae41d8a7e\");\nconst USE_NSIS_BUILT_IN_COMPRESSOR = false;\nclass AppPackageHelper {\n    constructor() {\n        this.archToFileInfo = new Map();\n        this.infoToIsDelete = new Map();\n        /** @private */\n        this.refCount = 0;\n    }\n    packArch(arch, target) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            let infoPromise = _this.archToFileInfo.get(arch);\n            if (infoPromise == null) {\n                infoPromise = (0, (_log || _load_log()).subTask)(`Packaging NSIS installer for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]}`, target.buildAppPackage(target.archs.get(arch), arch)).then(function (it) {\n                    return { file: it };\n                });\n                _this.archToFileInfo.set(arch, infoPromise);\n            }\n            const info = yield infoPromise;\n            if (target.isWebInstaller) {\n                _this.infoToIsDelete.set(info, false);\n            } else if (!_this.infoToIsDelete.has(info)) {\n                _this.infoToIsDelete.set(info, true);\n            }\n            return info.file;\n        })();\n    }\n    finishBuild() {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            if (--_this2.refCount > 0) {\n                return;\n            }\n            const filesToDelete = [];\n            for (let _ref of _this2.infoToIsDelete.entries()) {\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                let info = _ref2[0];\n                let isDelete = _ref2[1];\n\n                if (isDelete) {\n                    filesToDelete.push(info.file);\n                }\n            }\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(filesToDelete, function (it) {\n                return (0, (_fsExtraP || _load_fsExtraP()).unlink)(it);\n            });\n        })();\n    }\n}\nexports.AppPackageHelper = AppPackageHelper;\nclass NsisTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(packager, outDir, targetName, packageHelper) {\n        super(targetName);\n        this.packager = packager;\n        this.outDir = outDir;\n        this.packageHelper = packageHelper;\n        /** @private */\n        this.archs = new Map();\n        this.nsisTemplatesDir = _path.join(__dirname, \"..\", \"..\", \"templates\", \"nsis\");\n        this.packageHelper.refCount++;\n        let options = this.packager.config.nsis || Object.create(null);\n        if (targetName !== \"nsis\") {\n            options = Object.assign(options, this.packager.config[targetName === \"nsis-web\" ? \"nsisWeb\" : targetName]);\n        }\n        this.options = options;\n        const deps = packager.info.metadata.dependencies;\n        if (deps != null && deps[\"electron-squirrel-startup\"] != null) {\n            (0, (_log || _load_log()).warn)('\"electron-squirrel-startup\" dependency is not required for NSIS');\n        }\n    }\n    build(appOutDir, arch) {\n        var _this3 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            _this3.archs.set(arch, appOutDir);\n        })();\n    }\n    /** @private */\n    buildAppPackage(appOutDir, arch) {\n        var _this4 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fs || _load_fs()).copyFile)(_path.join((yield nsisPathPromise), \"elevate.exe\"), _path.join(appOutDir, \"resources\", \"elevate.exe\"), null, false), (0, (_fs || _load_fs()).copyFile)(_path.join((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), \"windows-10\", (_electronBuilderCore || _load_electronBuilderCore()).Arch[arch], \"signtool.exe\"), _path.join(appOutDir, \"resources\", \"signtool.exe\"), null, false)]);\n            const packager = _this4.packager;\n            const format = _this4.options.useZip ? \"zip\" : \"7z\";\n            const archiveFile = _path.join(_this4.outDir, `${packager.appInfo.name}-${packager.appInfo.version}-${(_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]}.nsis.${format}`);\n            return yield (0, (_archive || _load_archive()).archive)(packager.config.compression, format, archiveFile, appOutDir, true);\n        })();\n    }\n    // noinspection JSUnusedGlobalSymbols\n    finishBuild() {\n        var _this5 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            (0, (_log || _load_log()).log)(\"Building NSIS installer\");\n            try {\n                yield _this5.buildInstaller();\n            } finally {\n                yield _this5.packageHelper.finishBuild();\n            }\n        })();\n    }\n    get installerFilenamePattern() {\n        return \"${productName} \" + (this.isPortable ? \"\" : \"Setup \") + \"${version}.${ext}\";\n    }\n    get isPortable() {\n        return this.name === \"portable\";\n    }\n    buildInstaller() {\n        var _this6 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const isPortable = _this6.isPortable;\n            const packager = _this6.packager;\n            const appInfo = packager.appInfo;\n            const version = appInfo.version;\n            const options = _this6.options;\n            const installerFilename = packager.expandArtifactNamePattern(options, \"exe\", null, _this6.installerFilenamePattern);\n            const iconPath = (isPortable ? null : yield packager.getResource(options.installerIcon, \"installerIcon.ico\")) || (yield packager.getIconPath());\n            const oneClick = options.oneClick !== false;\n            const installerPath = _path.join(_this6.outDir, installerFilename);\n            const guid = options.guid || (yield (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify((_uuid || _load_uuid()).v5)({ namespace: ELECTRON_BUILDER_NS_UUID, name: appInfo.id }));\n            const defines = {\n                APP_ID: appInfo.id,\n                APP_GUID: guid,\n                PRODUCT_NAME: appInfo.productName,\n                PRODUCT_FILENAME: appInfo.productFilename,\n                APP_FILENAME: (!oneClick || options.perMachine === true) && /^[-_+0-9a-zA-Z ]+$/.test(appInfo.productFilename) ? appInfo.productFilename : appInfo.name,\n                APP_DESCRIPTION: appInfo.description,\n                VERSION: version,\n                COMPANY_NAME: appInfo.companyName,\n                PROJECT_DIR: packager.projectDir,\n                BUILD_RESOURCES_DIR: packager.buildResourcesDir\n            };\n            // electron uses product file name as app data, define it as well to remove on uninstall\n            if (defines.APP_FILENAME != appInfo.productFilename) {\n                defines.APP_PRODUCT_FILENAME = appInfo.productFilename;\n            }\n            const commands = {\n                OutFile: `\"${installerPath}\"`,\n                VIProductVersion: appInfo.versionInWeirdWindowsForm,\n                VIAddVersionKey: _this6.computeVersionKey(),\n                Unicode: _this6.isUnicodeEnabled\n            };\n            if (iconPath != null) {\n                if (isPortable) {\n                    commands.Icon = iconPath;\n                } else {\n                    defines.MUI_ICON = iconPath;\n                    defines.MUI_UNICON = iconPath;\n                }\n            }\n            if (_this6.archs.size === 1 && USE_NSIS_BUILT_IN_COMPRESSOR) {\n                defines.APP_BUILD_DIR = _this6.archs.get(_this6.archs.keys().next().value);\n            } else {\n                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(_this6.archs.keys(), (() => {\n                    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (arch) {\n                        const file = yield _this6.packageHelper.packArch(arch, _this6);\n                        defines[arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64 ? \"APP_64\" : \"APP_32\"] = file;\n                        defines[(arch === (_electronBuilderCore || _load_electronBuilderCore()).Arch.x64 ? \"APP_64\" : \"APP_32\") + \"_NAME\"] = _path.basename(file);\n                        if (_this6.isWebInstaller) {\n                            packager.dispatchArtifactCreated(file, _this6, arch);\n                        }\n                    });\n\n                    return function (_x) {\n                        return _ref3.apply(this, arguments);\n                    };\n                })());\n            }\n            _this6.configureDefinesForAllTypeOfInstaller(defines);\n            if (isPortable) {\n                defines.REQUEST_EXECUTION_LEVEL = options.requestExecutionLevel || \"user\";\n            } else {\n                yield _this6.configureDefines(oneClick, defines);\n            }\n            if (packager.config.compression === \"store\") {\n                commands.SetCompress = \"off\";\n            } else {\n                commands.SetCompressor = \"lzma\";\n                if (!_this6.isWebInstaller) {\n                    defines.COMPRESS = \"auto\";\n                }\n            }\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(defines);\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(commands);\n            if (packager.packagerOptions.effectiveOptionComputed != null && (yield packager.packagerOptions.effectiveOptionComputed([defines, commands]))) {\n                return;\n            }\n            const script = isPortable ? yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(_this6.nsisTemplatesDir, \"portable.nsi\"), \"utf8\") : yield _this6.computeScriptAndSignUninstaller(defines, commands, installerPath);\n            yield _this6.executeMakensis(defines, commands, (yield _this6.computeFinalScript(script, true)));\n            yield packager.sign(installerPath);\n            packager.dispatchArtifactCreated(installerPath, _this6, _this6.archs.size === 1 ? _this6.archs.keys().next().value : null, _this6.generateGitHubInstallerName());\n        })();\n    }\n    generateGitHubInstallerName() {\n        const appInfo = this.packager.appInfo;\n        const classifier = appInfo.name.toLowerCase() === appInfo.name ? \"setup-\" : \"Setup-\";\n        return `${appInfo.name}-${this.isPortable ? \"\" : classifier}${appInfo.version}.exe`;\n    }\n    get isUnicodeEnabled() {\n        return this.options.unicode == null ? true : this.options.unicode;\n    }\n    get isWebInstaller() {\n        return false;\n    }\n    computeScriptAndSignUninstaller(defines, commands, installerPath) {\n        var _this7 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this7.packager;\n            const customScriptPath = yield packager.getResource(_this7.options.script, \"installer.nsi\");\n            const script = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(customScriptPath || _path.join(_this7.nsisTemplatesDir, \"installer.nsi\"), \"utf8\");\n            if (customScriptPath != null) {\n                (0, (_log || _load_log()).log)(\"Custom NSIS script is used - uninstaller is not signed by electron-builder\");\n                return script;\n            }\n            const uninstallerPath = yield packager.getTempFile(\"uninstaller.exe\");\n            const isWin = process.platform === \"win32\";\n            defines.BUILD_UNINSTALLER = null;\n            defines.UNINSTALLER_OUT_FILE = isWin ? uninstallerPath : _path.win32.join(\"Z:\", uninstallerPath);\n            yield _this7.executeMakensis(defines, commands, (yield _this7.computeFinalScript(script, false)));\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(isWin ? installerPath : \"wine\", isWin ? [] : [installerPath]);\n            yield packager.sign(uninstallerPath, \"  Signing NSIS uninstaller\");\n            delete defines.BUILD_UNINSTALLER;\n            // platform-specific path, not wine\n            defines.UNINSTALLER_OUT_FILE = uninstallerPath;\n            return script;\n        })();\n    }\n    computeVersionKey() {\n        // Error: invalid VIProductVersion format, should be X.X.X.X\n        // so, we must strip beta\n        const localeId = this.options.language || \"1033\";\n        const appInfo = this.packager.appInfo;\n        const versionKey = [`/LANG=${localeId} ProductName \"${appInfo.productName}\"`, `/LANG=${localeId} ProductVersion \"${appInfo.version}\"`, `/LANG=${localeId} CompanyName \"${appInfo.companyName}\"`, `/LANG=${localeId} LegalCopyright \"${appInfo.copyright}\"`, `/LANG=${localeId} FileDescription \"${appInfo.description}\"`, `/LANG=${localeId} FileVersion \"${appInfo.buildVersion}\"`];\n        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(this.packager.platformSpecificBuildOptions.legalTrademarks, it => versionKey.push(`/LANG=${localeId} LegalTrademarks \"${it}\"`));\n        return versionKey;\n    }\n    configureDefines(oneClick, defines) {\n        var _this8 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this8.packager;\n            const options = _this8.options;\n            if (oneClick) {\n                defines.ONE_CLICK = null;\n                if (options.runAfterFinish !== false) {\n                    defines.RUN_AFTER_FINISH = null;\n                }\n                const installerHeaderIcon = yield packager.getResource(options.installerHeaderIcon, \"installerHeaderIcon.ico\");\n                if (installerHeaderIcon != null) {\n                    defines.HEADER_ICO = installerHeaderIcon;\n                }\n            } else {\n                const installerHeader = yield packager.getResource(options.installerHeader, \"installerHeader.bmp\");\n                if (installerHeader != null) {\n                    defines.MUI_HEADERIMAGE = null;\n                    defines.MUI_HEADERIMAGE_RIGHT = null;\n                    defines.MUI_HEADERIMAGE_BITMAP = installerHeader;\n                }\n                const bitmap = (yield packager.getResource(options.installerSidebar, \"installerSidebar.bmp\")) || \"${NSISDIR}\\\\Contrib\\\\Graphics\\\\Wizard\\\\nsis3-metro.bmp\";\n                defines.MUI_WELCOMEFINISHPAGE_BITMAP = bitmap;\n                defines.MUI_UNWELCOMEFINISHPAGE_BITMAP = (yield packager.getResource(options.uninstallerSidebar, \"uninstallerSidebar.bmp\")) || bitmap;\n                if (options.allowElevation !== false) {\n                    defines.MULTIUSER_INSTALLMODE_ALLOW_ELEVATION = null;\n                }\n            }\n            if (options.perMachine === true) {\n                defines.INSTALL_MODE_PER_ALL_USERS = null;\n            }\n            if (!oneClick || options.perMachine === true) {\n                defines.INSTALL_MODE_PER_ALL_USERS_REQUIRED = null;\n            }\n            if (options.allowToChangeInstallationDirectory) {\n                if (oneClick) {\n                    throw new Error(\"allowToChangeInstallationDirectory makes sense only for boring installer (please set oneClick to false)\");\n                }\n                defines.allowToChangeInstallationDirectory = null;\n            }\n            if (options.menuCategory != null && options.menuCategory !== false) {\n                const menu = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(options.menuCategory === true ? packager.appInfo.companyName : options.menuCategory);\n                if (!(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(menu)) {\n                    defines.MENU_FILENAME = menu;\n                }\n            }\n            if (options.multiLanguageInstaller == null ? _this8.isUnicodeEnabled : options.multiLanguageInstaller) {\n                defines.MULTI_LANGUAGE_INSTALLER = null;\n            }\n            if (options.deleteAppDataOnUninstall) {\n                defines.DELETE_APP_DATA_ON_UNINSTALL = null;\n            }\n        })();\n    }\n    configureDefinesForAllTypeOfInstaller(defines) {\n        const options = this.options;\n        if (!this.isWebInstaller && defines.APP_BUILD_DIR == null) {\n            if (options.useZip) {\n                defines.ZIP_COMPRESSION = null;\n            }\n            defines.COMPRESSION_METHOD = options.useZip ? \"zip\" : \"7z\";\n        }\n    }\n    executeMakensis(defines, commands, script) {\n        var _this9 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const args = _this9.options.warningsAsErrors === false ? [] : [\"-WX\"];\n            for (const name of Object.keys(defines)) {\n                const value = defines[name];\n                if (value == null) {\n                    args.push(`-D${name}`);\n                } else {\n                    args.push(`-D${name}=${value}`);\n                }\n            }\n            for (const name of Object.keys(commands)) {\n                const value = commands[name];\n                if (Array.isArray(value)) {\n                    for (const c of value) {\n                        args.push(`-X${name} ${c}`);\n                    }\n                } else {\n                    args.push(`-X${name} ${value}`);\n                }\n            }\n            args.push(\"-\");\n            if ((_electronBuilderUtil || _load_electronBuilderUtil()).debug.enabled) {\n                process.stdout.write(\"\\n\\nNSIS script:\\n\\n\" + script + \"\\n\\n---\\nEnd of NSIS script.\\n\\n\");\n            }\n            const nsisPath = yield nsisPathPromise;\n            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {\n                const command = _path.join(nsisPath, process.platform === \"darwin\" ? \"mac\" : process.platform === \"win32\" ? \"Bin\" : \"linux\", process.platform === \"win32\" ? \"makensis.exe\" : \"makensis\");\n                const childProcess = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).doSpawn)(command, args, {\n                    // we use NSIS_CONFIG_CONST_DATA_PATH=no to build makensis on Linux, but in any case it doesn't use stubs as MacOS/Windows version, so, we explicitly set NSISDIR\n                    // set LC_CTYPE to avoid crash https://github.com/electron-userland/electron-builder/issues/503 Even \"en_DE.UTF-8\" leads to error.\n                    env: Object.assign({}, process.env, { NSISDIR: nsisPath, LC_CTYPE: \"en_US.UTF-8\" }),\n                    cwd: _this9.nsisTemplatesDir\n                }, true);\n                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).handleProcess)(\"close\", childProcess, command, resolve, function (error) {\n                    reject(error + \"\\nNSIS script:\\n\" + script);\n                });\n                childProcess.stdin.end(script);\n            });\n        })();\n    }\n    writeCustomLangFile(data) {\n        var _this10 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const file = yield _this10.packager.getTempFile(\"messages.nsh\");\n            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(file, data);\n            return file;\n        })();\n    }\n    computeFinalScript(originalScript, isInstaller) {\n        var _this11 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this11.packager;\n            let scriptHeader = `!addincludedir \"${_path.join(__dirname, \"..\", \"..\", \"templates\", \"nsis\", \"include\")}\"\\n`;\n            const addCustomMessageFileInclude = (() => {\n                var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (input) {\n                    return '!include \"' + (yield _this11.writeCustomLangFile(computeCustomMessageTranslations((0, (_jsYaml || _load_jsYaml()).safeLoad)((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(_this11.nsisTemplatesDir, input), \"utf-8\")))).join(\"\\n\"))) + '\"\\n';\n                });\n\n                return function addCustomMessageFileInclude(_x2) {\n                    return _ref4.apply(this, arguments);\n                };\n            })();\n            const tasks = [(0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n                const pluginArch = _this11.isUnicodeEnabled ? \"x86-unicode\" : \"x86-ansi\";\n                let result = `!addplugindir /${pluginArch} \"${_path.join((yield nsisResourcePathPromise), \"plugins\", pluginArch)}\"\\n`;\n                result += `!addplugindir /${pluginArch} \"${_path.join(packager.buildResourcesDir, pluginArch)}\"\\n`;\n                return result;\n            }), (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n                // http://stackoverflow.com/questions/997456/nsis-license-file-based-on-language-selection\n                const licensePage = yield _this11.computeLicensePage();\n                return licensePage == null ? \"\" : createMacro(\"licensePage\", licensePage);\n            }), function () {\n                return addCustomMessageFileInclude(\"messages.yml\");\n            }];\n            if (!_this11.isPortable) {\n                if (_this11.options.oneClick === false) {\n                    tasks.push(function () {\n                        return addCustomMessageFileInclude(\"boringMessages.yml\");\n                    });\n                }\n                tasks.push((0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n                    let result = \"\";\n                    const customInclude = yield packager.getResource(_this11.options.include, \"installer.nsh\");\n                    if (customInclude != null) {\n                        result += `!addincludedir \"${packager.buildResourcesDir}\"\\n`;\n                        result += `!include \"${customInclude}\"\\n\\n`;\n                    }\n                    return result;\n                }));\n            }\n            for (const s of yield (0, (_promise || _load_promise()).asyncAll)(tasks)) {\n                scriptHeader += s;\n            }\n            if (_this11.isPortable) {\n                return scriptHeader + originalScript;\n            }\n            const fileAssociations = packager.fileAssociations;\n            if (fileAssociations.length !== 0) {\n                if (_this11.options.perMachine !== true) {\n                    // https://github.com/electron-userland/electron-builder/issues/772\n                    throw new Error(`Please set perMachine to true — file associations works on Windows only if installed for all users`);\n                }\n                scriptHeader += \"!include FileAssociation.nsh\\n\";\n                if (isInstaller) {\n                    let registerFileAssociationsScript = \"\";\n                    for (const item of fileAssociations) {\n                        const extensions = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(item.ext).map((_platformPackager || _load_platformPackager()).normalizeExt);\n                        for (const ext of extensions) {\n                            const customIcon = yield packager.getResource((0, (_electronBuilderUtil || _load_electronBuilderUtil()).getPlatformIconFileName)(item.icon, false), `${extensions[0]}.ico`);\n                            let installedIconPath = \"$appExe,0\";\n                            if (customIcon != null) {\n                                installedIconPath = `$INSTDIR\\\\resources\\\\${_path.basename(customIcon)}`;\n                                //noinspection SpellCheckingInspection\n                                registerFileAssociationsScript += `  File \"/oname=${installedIconPath}\" \"${customIcon}\"\\n`;\n                            }\n                            const icon = `\"${installedIconPath}\"`;\n                            const commandText = `\"Open with ${packager.appInfo.productName}\"`;\n                            const command = '\"$appExe $\\\\\"%1$\\\\\"\"';\n                            registerFileAssociationsScript += `  !insertmacro APP_ASSOCIATE \"${ext}\" \"${item.name || ext}\" \"${item.description || \"\"}\" ${icon} ${commandText} ${command}\\n`;\n                        }\n                    }\n                    scriptHeader += `!macro registerFileAssociations\\n${registerFileAssociationsScript}!macroend\\n`;\n                } else {\n                    let unregisterFileAssociationsScript = \"\";\n                    for (const item of fileAssociations) {\n                        for (const ext of (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(item.ext)) {\n                            unregisterFileAssociationsScript += `  !insertmacro APP_UNASSOCIATE \"${(0, (_platformPackager || _load_platformPackager()).normalizeExt)(ext)}\" \"${item.name || ext}\"\\n`;\n                        }\n                    }\n                    scriptHeader += `!macro unregisterFileAssociations\\n${unregisterFileAssociationsScript}!macroend\\n`;\n                }\n            }\n            return scriptHeader + originalScript;\n        })();\n    }\n    computeLicensePage() {\n        var _this12 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this12.packager;\n            const license = yield packager.getResource(_this12.options.license, \"license.rtf\", \"license.txt\", \"eula.rtf\", \"eula.txt\", \"LICENSE.rtf\", \"LICENSE.txt\", \"EULA.rtf\", \"EULA.txt\", \"LICENSE.RTF\", \"LICENSE.TXT\", \"EULA.RTF\", \"EULA.TXT\");\n            if (license != null) {\n                return [`!insertmacro MUI_PAGE_LICENSE \"${license}\"`];\n            }\n            const licenseFiles = (yield packager.resourceList).filter(function (it) {\n                const name = it.toLowerCase();\n                return (name.startsWith(\"license_\") || name.startsWith(\"eula_\")) && (name.endsWith(\".rtf\") || name.endsWith(\".txt\"));\n            });\n            if (licenseFiles.length === 0) {\n                return null;\n            }\n            const licensePage = [];\n            const unspecifiedLangs = new Set(bundledLanguages);\n            let defaultFile = null;\n            const sortedFiles = licenseFiles.sort(function (a, b) {\n                const aW = a.indexOf(\"_en\") !== -1 ? 0 : 100;\n                const bW = b.indexOf(\"_en\") !== -1 ? 0 : 100;\n                return aW === bW ? a.localeCompare(b) : aW - bW;\n            });\n            for (const file of sortedFiles) {\n                let lang = file.match(/_([^.]+)\\./)[1];\n                let langWithRegion;\n                if (lang.indexOf(\"_\") !== -1) {\n                    langWithRegion = lang;\n                } else {\n                    lang = lang.toLowerCase();\n                    langWithRegion = toLangWithRegion(lang);\n                }\n                unspecifiedLangs.delete(langWithRegion);\n                const fullFile = _path.join(packager.buildResourcesDir, file);\n                if (defaultFile == null) {\n                    defaultFile = fullFile;\n                }\n                licensePage.push(`LicenseLangString MUILicense ${lcid[langWithRegion] || lang} \"${fullFile}\"`);\n            }\n            for (const l of unspecifiedLangs) {\n                licensePage.push(`LicenseLangString MUILicense ${lcid[l]} \"${defaultFile}\"`);\n            }\n            licensePage.push('!insertmacro MUI_PAGE_LICENSE \"$(MUILicense)\"');\n            return licensePage;\n        })();\n    }\n}\nexports.NsisTarget = NsisTarget;\nfunction computeCustomMessageTranslations(messages) {\n    const result = [];\n    for (const messageId of Object.keys(messages)) {\n        const langToTranslations = messages[messageId];\n        const unspecifiedLangs = new Set(bundledLanguages);\n        for (const lang of Object.keys(langToTranslations)) {\n            const langWithRegion = toLangWithRegion(lang);\n            result.push(`LangString ${messageId} ${lcid[langWithRegion]} \"${langToTranslations[lang].replace(/\\n/g, \"$\\\\r$\\\\n\")}\"`);\n            unspecifiedLangs.delete(langWithRegion);\n        }\n        const defaultTranslation = langToTranslations[\"en\"].replace(/\\n/g, \"$\\\\r$\\\\n\");\n        for (const langWithRegion of unspecifiedLangs) {\n            result.push(`LangString ${messageId} ${lcid[langWithRegion]} \"${defaultTranslation}\"`);\n        }\n    }\n    return result;\n}\nfunction toLangWithRegion(lang) {\n    let langWithRegion = langToLangWithRegion.get(lang);\n    if (langWithRegion == null) {\n        langWithRegion = `${lang}_${lang.toUpperCase()}`;\n    }\n    return langWithRegion;\n}\nfunction createMacro(name, lines) {\n    return `\\n!macro ${name}\\n  ${lines.join(\"\\n  \")}\\n!macroend\\n`;\n}\nconst lcid = {\n    \"af_ZA\": 1078,\n    \"am_ET\": 1118,\n    \"ar_AE\": 14337,\n    \"ar_BH\": 15361,\n    \"ar_DZ\": 5121,\n    \"ar_EG\": 3073,\n    \"ar_IQ\": 2049,\n    \"ar_JO\": 11265,\n    \"ar_KW\": 13313,\n    \"ar_LB\": 12289,\n    \"ar_LY\": 4097,\n    \"ar_MA\": 6145,\n    \"ar_OM\": 8193,\n    \"ar_QA\": 16385,\n    \"ar_SA\": 1025,\n    \"ar_SY\": 10241,\n    \"ar_TN\": 7169,\n    \"ar_YE\": 9217,\n    \"arn_CL\": 1146,\n    \"as_IN\": 1101,\n    \"az_AZ\": 2092,\n    \"ba_RU\": 1133,\n    \"be_BY\": 1059,\n    \"bg_BG\": 1026,\n    \"bn_IN\": 1093,\n    \"bo_BT\": 2129,\n    \"bo_CN\": 1105,\n    \"br_FR\": 1150,\n    \"bs_BA\": 8218,\n    \"ca_ES\": 1027,\n    \"co_FR\": 1155,\n    \"cs_CZ\": 1029,\n    \"cy_GB\": 1106,\n    \"da_DK\": 1030,\n    \"de_AT\": 3079,\n    \"de_CH\": 2055,\n    \"de_DE\": 1031,\n    \"de_LI\": 5127,\n    \"de_LU\": 4103,\n    \"div_MV\": 1125,\n    \"dsb_DE\": 2094,\n    \"el_GR\": 1032,\n    \"en_AU\": 3081,\n    \"en_BZ\": 10249,\n    \"en_CA\": 4105,\n    \"en_CB\": 9225,\n    \"en_GB\": 2057,\n    \"en_IE\": 6153,\n    \"en_IN\": 18441,\n    \"en_JA\": 8201,\n    \"en_MY\": 17417,\n    \"en_NZ\": 5129,\n    \"en_PH\": 13321,\n    \"en_TT\": 11273,\n    \"en_US\": 1033,\n    \"en_ZA\": 7177,\n    \"en_ZW\": 12297,\n    \"es_AR\": 11274,\n    \"es_BO\": 16394,\n    \"es_CL\": 13322,\n    \"es_CO\": 9226,\n    \"es_CR\": 5130,\n    \"es_DO\": 7178,\n    \"es_EC\": 12298,\n    \"es_ES\": 3082,\n    \"es_GT\": 4106,\n    \"es_HN\": 18442,\n    \"es_MX\": 2058,\n    \"es_NI\": 19466,\n    \"es_PA\": 6154,\n    \"es_PE\": 10250,\n    \"es_PR\": 20490,\n    \"es_PY\": 15370,\n    \"es_SV\": 17418,\n    \"es_UR\": 14346,\n    \"es_US\": 21514,\n    \"es_VE\": 8202,\n    \"et_EE\": 1061,\n    \"eu_ES\": 1069,\n    \"fa_IR\": 1065,\n    \"fi_FI\": 1035,\n    \"fil_PH\": 1124,\n    \"fo_FO\": 1080,\n    \"fr_BE\": 2060,\n    \"fr_CA\": 3084,\n    \"fr_CH\": 4108,\n    \"fr_FR\": 1036,\n    \"fr_LU\": 5132,\n    \"fr_MC\": 6156,\n    \"fy_NL\": 1122,\n    \"ga_IE\": 2108,\n    \"gbz_AF\": 1164,\n    \"gl_ES\": 1110,\n    \"gsw_FR\": 1156,\n    \"gu_IN\": 1095,\n    \"ha_NG\": 1128,\n    \"he_IL\": 1037,\n    \"hi_IN\": 1081,\n    \"hr_BA\": 4122,\n    \"hr_HR\": 1050,\n    \"hu_HU\": 1038,\n    \"hy_AM\": 1067,\n    \"id_ID\": 1057,\n    \"ii_CN\": 1144,\n    \"is_IS\": 1039,\n    \"it_CH\": 2064,\n    \"it_IT\": 1040,\n    \"iu_CA\": 2141,\n    \"ja_JP\": 1041,\n    \"ka_GE\": 1079,\n    \"kh_KH\": 1107,\n    \"kk_KZ\": 1087,\n    \"kl_GL\": 1135,\n    \"kn_IN\": 1099,\n    \"ko_KR\": 1042,\n    \"kok_IN\": 1111,\n    \"ky_KG\": 1088,\n    \"lb_LU\": 1134,\n    \"lo_LA\": 1108,\n    \"lt_LT\": 1063,\n    \"lv_LV\": 1062,\n    \"mi_NZ\": 1153,\n    \"mk_MK\": 1071,\n    \"ml_IN\": 1100,\n    \"mn_CN\": 2128,\n    \"mn_MN\": 1104,\n    \"moh_CA\": 1148,\n    \"mr_IN\": 1102,\n    \"ms_BN\": 2110,\n    \"ms_MY\": 1086,\n    \"mt_MT\": 1082,\n    \"my_MM\": 1109,\n    \"nb_NO\": 1044,\n    \"ne_NP\": 1121,\n    \"nl_BE\": 2067,\n    \"nl_NL\": 1043,\n    \"nn_NO\": 2068,\n    \"ns_ZA\": 1132,\n    \"oc_FR\": 1154,\n    \"or_IN\": 1096,\n    \"pa_IN\": 1094,\n    \"pl_PL\": 1045,\n    \"ps_AF\": 1123,\n    \"pt_BR\": 1046,\n    \"pt_PT\": 2070,\n    \"qut_GT\": 1158,\n    \"quz_BO\": 1131,\n    \"quz_EC\": 2155,\n    \"quz_PE\": 3179,\n    \"rm_CH\": 1047,\n    \"ro_RO\": 1048,\n    \"ru_RU\": 1049,\n    \"rw_RW\": 1159,\n    \"sa_IN\": 1103,\n    \"sah_RU\": 1157,\n    \"se_FI\": 3131,\n    \"se_NO\": 1083,\n    \"se_SE\": 2107,\n    \"si_LK\": 1115,\n    \"sk_SK\": 1051,\n    \"sl_SI\": 1060,\n    \"sma_NO\": 6203,\n    \"sma_SE\": 7227,\n    \"smj_NO\": 4155,\n    \"smj_SE\": 5179,\n    \"smn_FI\": 9275,\n    \"sms_FI\": 8251,\n    \"sq_AL\": 1052,\n    \"sr_BA\": 7194,\n    \"sr_SP\": 3098,\n    \"sv_FI\": 2077,\n    \"sv_SE\": 1053,\n    \"sw_KE\": 1089,\n    \"syr_SY\": 1114,\n    \"ta_IN\": 1097,\n    \"te_IN\": 1098,\n    \"tg_TJ\": 1064,\n    \"th_TH\": 1054,\n    \"tk_TM\": 1090,\n    \"tmz_DZ\": 2143,\n    \"tn_ZA\": 1074,\n    \"tr_TR\": 1055,\n    \"tt_RU\": 1092,\n    \"ug_CN\": 1152,\n    \"uk_UA\": 1058,\n    \"ur_IN\": 2080,\n    \"ur_PK\": 1056,\n    \"uz_UZ\": 2115,\n    \"vi_VN\": 1066,\n    \"wen_DE\": 1070,\n    \"wo_SN\": 1160,\n    \"xh_ZA\": 1076,\n    \"yo_NG\": 1130,\n    \"zh_CHS\": 4,\n    \"zh_CHT\": 31748,\n    \"zh_CN\": 2052,\n    \"zh_HK\": 3076,\n    \"zh_MO\": 5124,\n    \"zh_SG\": 4100,\n    \"zh_TW\": 1028,\n    \"zu_ZA\": 1077\n};\n// \"el_GR\" \"lv_LV\" \"ko_KR\" \"tr_TR\"\nconst bundledLanguages = [\"en_US\", \"de_DE\", \"fr_FR\", \"es_ES\", \"zh_CN\", \"zh_TW\", \"ja_JP\", \"it_IT\", \"nl_NL\", \"ru_RU\", \"pl_PL\", \"uk_UA\", \"cs_CZ\", \"sv_SE\", \"nb_NO\", \"da_DK\", \"pt_PT\"];\nconst langToLangWithRegion = new Map();\nfor (const id of bundledLanguages) {\n    langToLangWithRegion.set(id.substring(0, id.indexOf(\"_\")), id);\n}\n//# sourceMappingURL=nsis.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/pkg.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PkgTarget = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _bluebirdLst2;\n\nfunction _load_bluebirdLst2() {\n    return _bluebirdLst2 = _interopRequireDefault(require(\"bluebird-lst\"));\n}\n\nexports.prepareProductBuildArgs = prepareProductBuildArgs;\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _fs;\n\nfunction _load_fs() {\n    return _fs = require(\"electron-builder-util/out/fs\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nvar _codeSign;\n\nfunction _load_codeSign() {\n    return _codeSign = require(\"../codeSign\");\n}\n\nvar _mac;\n\nfunction _load_mac() {\n    return _mac = require(\"../packager/mac\");\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n// http://www.shanekirk.com/2013/10/creating-flat-packages-in-osx/\nclass PkgTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(packager, outDir) {\n        super(\"pkg\");\n        this.packager = packager;\n        this.outDir = outDir;\n        this.options = this.packager.config.pkg || Object.create(null);\n        this.installLocation = this.options.installLocation || \"/Applications\";\n    }\n    build(appPath, arch) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const packager = _this.packager;\n            const options = _this.options;\n            const appInfo = packager.appInfo;\n            const keychainName = (yield packager.codeSigningInfo).keychainName;\n            const certType = \"Developer ID Installer\";\n            const identity = yield (0, (_codeSign || _load_codeSign()).findIdentity)(certType, options.identity || packager.platformSpecificBuildOptions.identity, keychainName);\n            if (identity == null && packager.forceCodeSigning) {\n                throw new Error(`Cannot find valid \"${certType}\" to sign standalone installer, please see https://github.com/electron-userland/electron-builder/wiki/Code-Signing`);\n            }\n            const appOutDir = _this.outDir;\n            const distInfo = _path.join(appOutDir, \"distribution.xml\");\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"productbuild\", [\"--synthesize\", \"--component\", appPath, _this.installLocation, distInfo], {\n                cwd: appOutDir\n            });\n            // to use --scripts, we must build .app bundle separately using pkgbuild\n            // productbuild --scripts doesn't work (because scripts in this case not added to our package)\n            // https://github.com/electron-userland/electron-osx-sign/issues/96#issuecomment-274986942\n            const innerPackageFile = _path.join(appOutDir, `${(0, (_mac || _load_mac()).filterCFBundleIdentifier)(appInfo.id)}.pkg`);\n            yield _this.buildComponentPackage(appPath, innerPackageFile);\n            const outFile = _path.join(appOutDir, packager.expandArtifactNamePattern(options, \"pkg\"));\n            const args = prepareProductBuildArgs(identity, keychainName);\n            args.push(\"--distribution\", distInfo);\n            args.push(outFile);\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).use)(options.productbuild, function (it) {\n                return args.push.apply(args, _toConsumableArray(it));\n            });\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"productbuild\", args, {\n                cwd: appOutDir\n            });\n            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([(0, (_fsExtraP || _load_fsExtraP()).unlink)(innerPackageFile), (0, (_fsExtraP || _load_fsExtraP()).unlink)(distInfo)]);\n            packager.dispatchArtifactCreated(outFile, _this, arch, `${appInfo.name}-${appInfo.version}.pkg`);\n        })();\n    }\n    buildComponentPackage(appPath, outFile) {\n        var _this2 = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            const options = _this2.options;\n            const args = [\"--component\", appPath, \"--install-location\", _this2.installLocation];\n            if (options.scripts != null) {\n                args.push(\"--scripts\", _path.resolve(_this2.packager.buildResourcesDir, options.scripts));\n            } else if (options.scripts !== null) {\n                const dir = _path.join(_this2.packager.buildResourcesDir, \"pkg-scripts\");\n                const stat = yield (0, (_fs || _load_fs()).statOrNull)(dir);\n                if (stat != null && stat.isDirectory()) {\n                    args.push(\"--scripts\", dir);\n                }\n            }\n            args.push(outFile);\n            yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).exec)(\"pkgbuild\", args);\n        })();\n    }\n}\nexports.PkgTarget = PkgTarget;\nfunction prepareProductBuildArgs(identity, keychain) {\n    const args = [];\n    if (identity != null) {\n        args.push(\"--sign\", identity);\n        if (keychain != null) {\n            args.push(\"--keychain\", keychain);\n        }\n    }\n    return args;\n}\n//# sourceMappingURL=pkg.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/snap.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _log;\n\nfunction _load_log() {\n    return _log = require(\"electron-builder-util/out/log\");\n}\n\nvar _fsExtraP;\n\nfunction _load_fsExtraP() {\n    return _fsExtraP = require(\"fs-extra-p\");\n}\n\nvar _jsYaml;\n\nfunction _load_jsYaml() {\n    return _jsYaml = require(\"js-yaml\");\n}\n\nvar _os;\n\nfunction _load_os() {\n    return _os = require(\"os\");\n}\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nclass SnapTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(name, packager, helper, outDir) {\n        super(name);\n        this.packager = packager;\n        this.helper = helper;\n        this.outDir = outDir;\n        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);\n    }\n    build(appOutDir, arch) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            (0, (_log || _load_log()).log)(`Building Snap for arch ${(_electronBuilderCore || _load_electronBuilderCore()).Arch[arch]}`);\n            const packager = _this.packager;\n            const appInfo = packager.appInfo;\n            const options = _this.options;\n            const stageDir = `${appOutDir}-snap`;\n            const snapDir = _path.join(stageDir, \"snap\");\n            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(stageDir);\n            const extraSnapSourceDir = _path.join(stageDir, \"extra\");\n            const isUseUbuntuPlatform = options.ubuntuAppPlatformContent != null;\n            if (isUseUbuntuPlatform) {\n                // ubuntu-app-platform requires empty directory\n                yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(_path.join(extraSnapSourceDir, \"ubuntu-app-platform\"));\n            }\n            const snap = {};\n            snap.name = packager.executableName.toLowerCase();\n            snap.version = appInfo.version;\n            snap.summary = options.summary || appInfo.productName;\n            snap.description = _this.helper.getDescription(options);\n            snap.confinement = options.confinement || \"strict\";\n            snap.grade = options.grade || \"stable\";\n            yield _this.helper.icons;\n            if (_this.helper.maxIconPath != null) {\n                snap.icon = \"snap/gui/icon.png\";\n                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_this.helper.maxIconPath, _path.join(snapDir, \"gui\", \"icon.png\"));\n            }\n            const desktopFile = yield _this.helper.computeDesktopEntry(_this.options, `${packager.executableName}`, _path.join(snapDir, \"gui\", `${snap.name}.desktop`), {\n                \"Icon\": \"${SNAP}/meta/gui/icon.png\"\n            });\n            if (options.assumes != null) {\n                if (!Array.isArray(options.assumes)) {\n                    throw new Error(\"snap.assumes must be an array of strings\");\n                }\n                snap.assumes = options.assumes;\n            }\n            snap.apps = {\n                [snap.name]: {\n                    command: `env TMPDIR=$XDG_RUNTIME_DIR desktop-launch $SNAP/${packager.executableName}`,\n                    plugs: (0, (_electronBuilderUtil || _load_electronBuilderUtil()).replaceDefault)(options.plugs, [\"home\", \"x11\", \"unity7\", \"browser-support\", \"network\", \"gsettings\", \"pulseaudio\", \"opengl\"])\n                }\n            };\n            if (isUseUbuntuPlatform) {\n                snap.apps[snap.name].plugs.push(\"platform\");\n                snap.plugs = {\n                    platform: {\n                        interface: \"content\",\n                        content: \"ubuntu-app-platform1\",\n                        target: \"ubuntu-app-platform\",\n                        \"default-provider\": \"ubuntu-app-platform\"\n                    }\n                };\n            }\n            // libxss1, libasound2, gconf2 - was \"error while loading shared libraries: libXss.so.1\" on Xubuntu 16.04\n            const isUseDocker = process.platform !== \"linux\";\n            const defaultStagePackages = isUseUbuntuPlatform ? [\"libnss3\"] : [\"libnotify4\", \"libappindicator1\", \"libxtst6\", \"libnss3\", \"libxss1\", \"fontconfig-config\", \"gconf2\", \"libasound2\", \"pulseaudio\"];\n            snap.parts = {\n                app: {\n                    plugin: \"dump\",\n                    \"stage-packages\": (0, (_electronBuilderUtil || _load_electronBuilderUtil()).replaceDefault)(options.stagePackages, defaultStagePackages),\n                    source: isUseDocker ? `/out/${_path.basename(appOutDir)}` : appOutDir,\n                    after: isUseUbuntuPlatform ? [\"extra\", \"desktop-ubuntu-app-platform\"] : [\"desktop-glib-only\"]\n                }\n            };\n            if (isUseUbuntuPlatform) {\n                snap.parts.extra = {\n                    plugin: \"dump\",\n                    source: isUseDocker ? `/out/${_path.basename(stageDir)}/${_path.basename(extraSnapSourceDir)}` : extraSnapSourceDir\n                };\n            }\n            if (packager.packagerOptions.effectiveOptionComputed != null && (yield packager.packagerOptions.effectiveOptionComputed({ snap, desktopFile }))) {\n                return;\n            }\n            const snapcraft = _path.join(snapDir, \"snapcraft.yaml\");\n            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(snapcraft, (0, (_jsYaml || _load_jsYaml()).safeDump)(snap, { lineWidth: 160 }));\n            const snapFileName = `${snap.name}_${snap.version}_${(0, (_electronBuilderCore || _load_electronBuilderCore()).toLinuxArchString)(arch)}.snap`;\n            const resultFile = _path.join(_this.outDir, snapFileName);\n            if (isUseDocker) {\n                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(\"docker\", [\"run\", \"--rm\", \"-v\", `${packager.info.projectDir}:/project`, \"-v\", `${(0, (_os || _load_os()).homedir)()}/.electron:/root/.electron`,\n                // dist dir can be outside of project dir\n                \"-v\", `${_this.outDir}:/out`, \"electronuserland/electron-builder:latest\", \"/bin/bash\", \"-c\", `snapcraft --version && cp -R /out/${_path.basename(stageDir)} /s/ && cd /s && snapcraft snap --target-arch ${(0, (_electronBuilderCore || _load_electronBuilderCore()).toLinuxArchString)(arch)} -o /out/${snapFileName}`], {\n                    cwd: packager.info.projectDir,\n                    stdio: [\"ignore\", \"inherit\", \"inherit\"]\n                });\n            } else {\n                yield (0, (_electronBuilderUtil || _load_electronBuilderUtil()).spawn)(\"snapcraft\", [\"snap\", \"--target-arch\", (0, (_electronBuilderCore || _load_electronBuilderCore()).toLinuxArchString)(arch), \"-o\", resultFile], {\n                    cwd: stageDir,\n                    stdio: [\"ignore\", \"inherit\", \"pipe\"]\n                });\n            }\n            packager.dispatchArtifactCreated(resultFile, _this, arch);\n        })();\n    }\n}\nexports.default = SnapTarget; //# sourceMappingURL=snap.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/targetFactory.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.NoOpTarget = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nexports.computeArchToTargetNamesMap = computeArchToTargetNamesMap;\nexports.createTargets = createTargets;\nexports.createCommonTarget = createCommonTarget;\n\nvar _electronBuilderCore;\n\nfunction _load_electronBuilderCore() {\n    return _electronBuilderCore = require(\"electron-builder-core\");\n}\n\nvar _electronBuilderUtil;\n\nfunction _load_electronBuilderUtil() {\n    return _electronBuilderUtil = require(\"electron-builder-util\");\n}\n\nvar _ArchiveTarget;\n\nfunction _load_ArchiveTarget() {\n    return _ArchiveTarget = require(\"./ArchiveTarget\");\n}\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nconst archiveTargets = new Set([\"zip\", \"7z\", \"tar.xz\", \"tar.lz\", \"tar.gz\", \"tar.bz2\"]);\nfunction computeArchToTargetNamesMap(raw, options, platform) {\n    for (const targetNames of raw.values()) {\n        if (targetNames.length > 0) {\n            // https://github.com/electron-userland/electron-builder/issues/1355\n            return raw;\n        }\n    }\n    const defaultArchs = raw.size === 0 ? [platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC ? \"x64\" : process.arch] : Array.from(raw.keys()).map(it => (_electronBuilderCore || _load_electronBuilderCore()).Arch[it]);\n    const result = new Map(raw);\n    for (const target of (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(options.target).map(it => typeof it === \"string\" ? { target: it } : it)) {\n        let name = target.target;\n        let archs = target.arch;\n        const suffixPos = name.lastIndexOf(\":\");\n        if (suffixPos > 0) {\n            name = target.target.substring(0, suffixPos);\n            if (archs == null) {\n                archs = target.target.substring(suffixPos + 1);\n            }\n        }\n        for (const arch of archs == null ? defaultArchs : (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(archs)) {\n            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).addValue)(result, (0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch), name);\n        }\n    }\n    if (result.size === 0) {\n        for (const arch of defaultArchs) {\n            result.set((0, (_electronBuilderCore || _load_electronBuilderCore()).archFromString)(arch), []);\n        }\n    }\n    return result;\n}\nfunction createTargets(nameToTarget, rawList, outDir, packager, cleanupTasks) {\n    const result = [];\n    const mapper = (name, factory) => {\n        let target = nameToTarget.get(name);\n        if (target == null) {\n            target = factory(outDir);\n            nameToTarget.set(name, target);\n        }\n        result.push(target);\n    };\n    const targets = normalizeTargets(rawList, packager.defaultTarget);\n    packager.createTargets(targets, mapper, cleanupTasks);\n    return result;\n}\nfunction normalizeTargets(targets, defaultTarget) {\n    const list = [];\n    for (const t of targets) {\n        const name = t.toLowerCase().trim();\n        if (name === (_electronBuilderCore || _load_electronBuilderCore()).DEFAULT_TARGET) {\n            list.push.apply(list, _toConsumableArray(defaultTarget));\n        } else {\n            list.push(name);\n        }\n    }\n    return list;\n}\nfunction createCommonTarget(target, outDir, packager) {\n    if (archiveTargets.has(target)) {\n        return new (_ArchiveTarget || _load_ArchiveTarget()).ArchiveTarget(target, outDir, packager);\n    } else if (target === (_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET) {\n        return new NoOpTarget((_electronBuilderCore || _load_electronBuilderCore()).DIR_TARGET);\n    } else {\n        throw new Error(`Unknown target: ${target}`);\n    }\n}\nclass NoOpTarget extends (_electronBuilderCore || _load_electronBuilderCore()).Target {\n    constructor(name) {\n        super(name);\n        this.options = null;\n    }\n    get outDir() {\n        throw new Error(\"NoOpTarget\");\n    }\n    build(appOutDir, arch) {\n        // no build\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {})();\n    }\n}\nexports.NoOpTarget = NoOpTarget; //# sourceMappingURL=targetFactory.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/targets/WebInstallerTarget.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.WebInstallerTarget = undefined;\n\nvar _bluebirdLst;\n\nfunction _load_bluebirdLst() {\n    return _bluebirdLst = require(\"bluebird-lst\");\n}\n\nvar _PublishManager;\n\nfunction _load_PublishManager() {\n    return _PublishManager = require(\"../publish/PublishManager\");\n}\n\nvar _nsis;\n\nfunction _load_nsis() {\n    return _nsis = require(\"./nsis\");\n}\n\nclass WebInstallerTarget extends (_nsis || _load_nsis()).NsisTarget {\n    constructor(packager, outDir, targetName, packageHelper) {\n        super(packager, outDir, targetName, packageHelper);\n    }\n    get isWebInstaller() {\n        return true;\n    }\n    configureDefines(oneClick, defines) {\n        var _this = this;\n\n        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {\n            //noinspection ES6MissingAwait\n            yield (_nsis || _load_nsis()).NsisTarget.prototype.configureDefines.call(_this, oneClick, defines);\n            const packager = _this.packager;\n            const options = _this.options;\n            let appPackageUrl = options.appPackageUrl;\n            if (appPackageUrl == null) {\n                const publishConfigs = yield (0, (_PublishManager || _load_PublishManager()).getPublishConfigsForUpdateInfo)(packager, (yield (0, (_PublishManager || _load_PublishManager()).getPublishConfigs)(packager, _this.options, null)), null);\n                if (publishConfigs == null || publishConfigs.length === 0) {\n                    throw new Error(\"Cannot compute app package download URL\");\n                }\n                appPackageUrl = (0, (_PublishManager || _load_PublishManager()).computeDownloadUrl)(publishConfigs[0], null, packager);\n                defines.APP_PACKAGE_URL_IS_INCOMLETE = null;\n            }\n            defines.APP_PACKAGE_URL = appPackageUrl;\n        })();\n    }\n    get installerFilenamePattern() {\n        return \"${productName} Web Setup ${version}.${ext}\";\n    }\n    generateGitHubInstallerName() {\n        const appInfo = this.packager.appInfo;\n        const classifier = appInfo.name.toLowerCase() === appInfo.name ? \"web-setup\" : \"WebSetup\";\n        return `${appInfo.name}-${classifier}-${appInfo.version}.exe`;\n    }\n}\nexports.WebInstallerTarget = WebInstallerTarget; //# sourceMappingURL=WebInstallerTarget.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder/out/util/filter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.hasMagic = hasMagic;\nexports.createFilter = createFilter;\n\nvar _path = _interopRequireWildcard(require(\"path\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction hasMagic(pattern) {\n    const set = pattern.set;\n    if (set.length > 1) {\n        return true;\n    }\n    for (const i of set[0]) {\n        if (typeof i !== \"string\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction createFilter(src, patterns, ignoreFiles, rawFilter, excludePatterns) {\n    return function (it, stat) {\n        if (src === it) {\n            return true;\n        }\n        if (rawFilter != null && !rawFilter(it)) {\n            return false;\n        }\n        // yes, check before path sep normalization\n        if (ignoreFiles != null && ignoreFiles.has(it)) {\n            return false;\n        }\n        let relative = it.substring(src.length + 1);\n        if (_path.sep === \"\\\\\") {\n            relative = relative.replace(/\\\\/g, \"/\");\n        }\n        return minimatchAll(relative, patterns, stat) && (excludePatterns == null || !minimatchAll(relative, excludePatterns, stat));\n    };\n}\n// https://github.com/joshwnj/minimatch-all/blob/master/index.js\nfunction minimatchAll(path, patterns, stat) {\n    let match = false;\n    for (const pattern of patterns) {\n        // If we've got a match, only re-test for exclusions.\n        // if we don't have a match, only re-test for inclusions.\n        if (match !== pattern.negate) {\n            continue;\n        }\n        // partial match — pattern: foo/bar.txt path: foo — we must allow foo\n        // use it only for non-negate patterns: const m = new Minimatch(\"!node_modules/@(electron-download|electron)/**/*\", {dot: true }); m.match(\"node_modules\", true) will return false, but must be true\n        match = pattern.match(path, stat.isDirectory() && !pattern.negate);\n    }\n    return match;\n}\n//# sourceMappingURL=filter.js.map","/home/travis/build/npmtest/node-npmtest-electron-builder/node_modules/electron-builder-util/out/log.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.setPrinter = setPrinter;\nexports.warn = warn;\nexports.log = log;\nexports.subTask = subTask;\nexports.task = task;\n\nvar _chalk;\n\nfunction _load_chalk() {\n    return _chalk = require(\"chalk\");\n}\n\nvar _nodeEmoji;\n\nfunction _load_nodeEmoji() {\n    return _nodeEmoji = require(\"node-emoji\");\n}\n\nlet printer = null;\nfunction setPrinter(value) {\n    printer = value;\n}\nclass Logger {\n    constructor(stream) {\n        this.stream = stream;\n    }\n    warn(message) {\n        this.log((0, (_chalk || _load_chalk()).yellow)(`Warning: ${message}`));\n    }\n    log(message) {\n        if (printer == null) {\n            this.stream.write(`${message}\\n`);\n        } else {\n            printer(message);\n        }\n    }\n    subTask(title, _promise) {\n        this.log(`  ${title}`);\n        return _promise;\n    }\n    task(title, _promise) {\n        const promise = _promise;\n        this.log(title);\n        return promise;\n    }\n}\nclass TtyLogger extends Logger {\n    constructor(stream) {\n        super(stream);\n    }\n    warn(message) {\n        this.log(`${(0, (_nodeEmoji || _load_nodeEmoji()).get)(\"warning\")}  ${(0, (_chalk || _load_chalk()).yellow)(message)}`);\n    }\n}\nconst logger = process.stdout.isTTY ? new TtyLogger(process.stdout) : new Logger(process.stdout);\nfunction warn(message) {\n    logger.warn(message);\n}\nfunction log(message) {\n    logger.log(message);\n}\nfunction subTask(title, promise) {\n    return logger.subTask(title, promise);\n}\nfunction task(title, promise) {\n    return logger.task(title, promise);\n}\n//# sourceMappingURL=log.js.map"}